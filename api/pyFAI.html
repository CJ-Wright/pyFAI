

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyFAI Package &mdash; pyFAI v0.9.0 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.9.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pyFAI v0.9.0 documentation" href="../index.html" />
    <link rel="up" title="pyFAI API" href="modules.html" />
    <link rel="next" title="Project structure" href="../project.html" />
    <link rel="prev" title="pyFAI API" href="modules.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../project.html" title="Project structure"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="pyFAI API"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">pyFAI v0.9.0 documentation</a> &raquo;</li>
          <li><a href="modules.html" accesskey="U">pyFAI API</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="pyfai-package">
<h1>pyFAI Package<a class="headerlink" href="#pyfai-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">pyFAI</span></tt> Package<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-pyFAI.__init__"></span></div>
<div class="section" id="module-pyFAI.azimuthalIntegrator">
<span id="azimuthalintegrator-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">azimuthalIntegrator</span></tt> Module<a class="headerlink" href="#module-pyFAI.azimuthalIntegrator" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator">
<em class="property">class </em><tt class="descclassname">pyFAI.azimuthalIntegrator.</tt><tt class="descname">AzimuthalIntegrator</tt><big>(</big><em>dist=1</em>, <em>poni1=0</em>, <em>poni2=0</em>, <em>rot1=0</em>, <em>rot2=0</em>, <em>rot3=0</em>, <em>pixel1=None</em>, <em>pixel2=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.geometry.Geometry" title="pyFAI.geometry.Geometry"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.geometry.Geometry</span></tt></a></p>
<p>This class is an azimuthal integrator based on P. Boesecke&#8217;s
geometry and histogram algorithm by Manolo S. del Rio and V.A Sole</p>
<p>All geometry calculation are done in the Geometry class</p>
<p>main methods are:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tth</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">ai</span><span class="o">.</span><span class="n">integrate1d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nbPt</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s">&quot;2th_deg&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">ai</span><span class="o">.</span><span class="n">integrate1d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nbPt</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s">&quot;q_nm^-1&quot;</span><span class="p">,</span> <span class="n">error_model</span><span class="o">=</span><span class="s">&quot;poisson&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regrouped</span> <span class="o">=</span> <span class="n">ai</span><span class="o">.</span><span class="n">integrate2d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nbPt_rad</span><span class="p">,</span> <span class="n">nbPt_azim</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s">&quot;q_nm^-1&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.array_from_unit">
<tt class="descname">array_from_unit</tt><big>(</big><em>shape</em>, <em>typ='center'</em>, <em>unit=2th_deg</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.array_from_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array of position in different dimentions (R, Q,
2Theta)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>shape</strong> (<em>ndarray.shape</em>) &#8211; shape of the expected array</li>
<li><strong>typ</strong> (<em>str</em>) &#8211; &#8220;center&#8221;, &#8220;corner&#8221; or &#8220;delta&#8221;</li>
<li><strong>unit</strong> (<em>pyFAI.units.Enum</em>) &#8211; can be Q, TTH, R for now</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">R, Q or 2Theta array depending on unit</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.darkcurrent">
<tt class="descname">darkcurrent</tt><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.darkcurrent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.flatfield">
<tt class="descname">flatfield</tt><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.flatfield" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_darkcurrent">
<tt class="descname">get_darkcurrent</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_darkcurrent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_flatfield">
<tt class="descname">get_flatfield</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_flatfield" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_mask">
<tt class="descname">get_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_maskfile">
<tt class="descname">get_maskfile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.integrate1d">
<tt class="descname">integrate1d</tt><big>(</big><em>data</em>, <em>nbPt</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>variance=None</em>, <em>error_model=None</em>, <em>radial_range=None</em>, <em>azimuth_range=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>polarization_factor=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>method='lut'</em>, <em>unit=q_nm^-1</em>, <em>safe=True</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.integrate1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the azimuthal integrated Saxs curve in q(nm^-1) by
default</p>
<p>Multi algorithm implementation (tries to be bullet proof)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the Detector/CCD camera</li>
<li><strong>nbPt</strong> (<em>int</em>) &#8211; number of points in the output pattern</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; output filename in 2/3 column ascii format</li>
<li><strong>correctSolidAngle</strong> (<em>bool</em>) &#8211; correct for solid angle of each pixel if True</li>
<li><strong>variance</strong> (<em>ndarray</em>) &#8211; array containing the variance of the data. If not available, no error propagation is done</li>
<li><strong>error_model</strong> (<em>str</em>) &#8211; When the variance is unknown, an error model can be given: &#8220;poisson&#8221; (variance = I), &#8220;azimuthal&#8221; (variance = (I-&lt;I&gt;)^2)</li>
<li><strong>radial_range</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the radial unit. If not provided, range is simply (data.min(), data.max()). Values outside the range are ignored.</li>
<li><strong>azimuth_range</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the azimuthal angle in degree. If not provided, range is simply (data.min(), data.max()). Values outside the range are ignored.</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array (same size as image) with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; polarization factor between -1 and +1. 0 for no correction</li>
<li><strong>dark</strong> (<em>ndarray</em>) &#8211; dark noise image</li>
<li><strong>flat</strong> (<em>ndarray</em>) &#8211; flat field image</li>
<li><strong>method</strong> (<em>str</em>) &#8211; can be &#8220;numpy&#8221;, &#8220;cython&#8221;, &#8220;BBox&#8221; or &#8220;splitpixel&#8221;, &#8220;lut&#8221;, &#8220;lut_ocl&#8221; if you want to go on GPU, ....</li>
<li><strong>unit</strong> (<em>pyFAI.units.Enum</em>) &#8211; can be Q, TTh, R for now</li>
<li><strong>safe</strong> (<em>bool</em>) &#8211; Do some extra checks to ensure LUT is still valid. False is faster.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">azimuthaly regrouped data, 2theta pos. and chi pos.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">3-tuple of ndarrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.integrate2d">
<tt class="descname">integrate2d</tt><big>(</big><em>data</em>, <em>nbPt_rad</em>, <em>nbPt_azim=360</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>variance=None</em>, <em>error_model=None</em>, <em>radial_range=None</em>, <em>azimuth_range=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>polarization_factor=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>method='bbox'</em>, <em>unit=q_nm^-1</em>, <em>safe=True</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.integrate2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the azimuthal regrouped 2d image in q(nm^-1)/deg by default</p>
<p>Multi algorithm implementation (tries to be bullet proof)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the Detector/CCD camera</li>
<li><strong>nbPt_rad</strong> (<em>int</em>) &#8211; number of points in the radial direction</li>
<li><strong>nbPt_azim</strong> (<em>int</em>) &#8211; number of points in the azimuthal direction</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; output image (as edf format)</li>
<li><strong>correctSolidAngle</strong> (<em>bool</em>) &#8211; correct for solid angle of each pixel if True</li>
<li><strong>variance</strong> (<em>ndarray</em>) &#8211; array containing the variance of the data. If not available, no error propagation is done</li>
<li><strong>error_model</strong> (<em>str</em>) &#8211; When the variance is unknown, an error model can be given: &#8220;poisson&#8221; (variance = I), &#8220;azimuthal&#8221; (variance = (I-&lt;I&gt;)^2)</li>
<li><strong>radial_range</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the radial unit. If not provided, range is simply (data.min(), data.max()). Values outside the range are ignored.</li>
<li><strong>azimuth_range</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the azimuthal angle in degree. If not provided, range is simply (data.min(), data.max()). Values outside the range are ignored.</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array (same size as image) with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; polarization factor between -1 and +1. 0 for no correction</li>
<li><strong>dark</strong> (<em>ndarray</em>) &#8211; dark noise image</li>
<li><strong>flat</strong> (<em>ndarray</em>) &#8211; flat field image</li>
<li><strong>method</strong> (<em>str</em>) &#8211; can be &#8220;numpy&#8221;, &#8220;cython&#8221;, &#8220;BBox&#8221; or &#8220;splitpixel&#8221;, &#8220;lut&#8221;, &#8220;lut_ocl&#8221; if you want to go on GPU, ....</li>
<li><strong>unit</strong> (<em>pyFAI.units.Enum</em>) &#8211; can be Q, TTH, R for now</li>
<li><strong>safe</strong> (<em>bool</em>) &#8211; Do some extra checks to ensure LUT is still valid. False is faster.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">azimuthaly regrouped data, 2theta pos. and chi pos.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">3-tuple of ndarrays (2d, 1d, 1d)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.makeHeaders">
<tt class="descname">makeHeaders</tt><big>(</big><em>hdr='#'</em>, <em>dark=None</em>, <em>flat=None</em>, <em>polarization_factor=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.makeHeaders" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hdr</strong> (<em>str</em>) &#8211; string used as comment in the header</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the header</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.makeMask">
<tt class="descname">makeMask</tt><big>(</big><em>data</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>mode='normal'</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.makeMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines various masks into another one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; input array of data</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; input mask (if none, self.mask is used)</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value of dead pixels</li>
<li><strong>delta_dumy</strong> &#8211; precision of dummy pixels</li>
<li><strong>mode</strong> (<em>str</em>) &#8211; can be &#8220;normal&#8221; or &#8220;numpy&#8221; (inverted) or &#8220;where&#8221; applied to the mask</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the new mask</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray of bool</p>
</td>
</tr>
</tbody>
</table>
<p>This method combine two masks (dynamic mask from <em>data &amp;
dummy</em> and <em>mask</em>) to generate a new one with the &#8216;or&#8217; binary
operation.  One can adjuste the level, with the <em>dummy</em> and
the <em>delta_dummy</em> parameter, when you considere the <em>data</em>
values needs to be masked out.</p>
<p>This method can work in two different <em>mode</em>:</p>
<blockquote>
<div><ul class="simple">
<li>&#8220;normal&#8221;: False for valid pixels, True for bad pixels</li>
<li>&#8220;numpy&#8221;: True for valid pixels, false for others</li>
</ul>
</div></blockquote>
<p>This method tries to accomodate various types of masks (like
valid=0 &amp; masked=-1, ...) and guesses if an input mask needs
to be inverted.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.mask">
<tt class="descname">mask</tt><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.maskfile">
<tt class="descname">maskfile</tt><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset azimuthal integrator in addition to other arrays.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.save1D">
<tt class="descname">save1D</tt><big>(</big><em>filename</em>, <em>dim1</em>, <em>I</em>, <em>error=None</em>, <em>dim1_unit=2th_deg</em>, <em>dark=None</em>, <em>flat=None</em>, <em>polarization_factor=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.save1D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.save2D">
<tt class="descname">save2D</tt><big>(</big><em>filename</em>, <em>I</em>, <em>dim1</em>, <em>dim2</em>, <em>error=None</em>, <em>dim1_unit=2th_deg</em>, <em>dark=None</em>, <em>flat=None</em>, <em>polarization_factor=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.save2D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.saxs">
<tt class="descname">saxs</tt><big>(</big><em>data</em>, <em>nbPt</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>variance=None</em>, <em>error_model=None</em>, <em>qRange=None</em>, <em>chiRange=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>polarization_factor=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>method='bbox'</em>, <em>unit=q_nm^-1</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.saxs" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the azimuthal integrated Saxs curve in q in nm^-1.</p>
<p>Wrapper for integrate1d emulating behavour of old saxs method</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the CCD camera</li>
<li><strong>nbPt</strong> (<em>int</em>) &#8211; number of points in the output pattern</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; file to save data to</li>
<li><strong>correctSolidAngle</strong> (<em>bool</em>) &#8211; if True, the data are devided by the solid angle of each pixel</li>
<li><strong>variance</strong> (<em>ndarray</em>) &#8211; array containing the variance of the data, if you know it</li>
<li><strong>error_model</strong> (<em>str</em>) &#8211; When the variance is unknown, an error model can be given: &#8220;poisson&#8221; (variance = I), &#8220;azimuthal&#8221; (variance = (I-&lt;I&gt;)^2)</li>
<li><strong>qRange</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the sctter vector q. If not provided, range is simply (data.min(), data.max()). Values outside the range are ignored.</li>
<li><strong>chiRange</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the chi angle. If not provided, range is simply (data.min(), data.max()). Values outside the range are ignored.</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array (same size as image) with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; polarization factor between -1 and +1. 0 for no correction</li>
<li><strong>dark</strong> (<em>ndarray</em>) &#8211; dark noise image</li>
<li><strong>flat</strong> (<em>ndarray</em>) &#8211; flat field image</li>
<li><strong>method</strong> (<em>str</em>) &#8211; can be &#8220;numpy&#8221;, &#8220;cython&#8221;, &#8220;BBox&#8221; or &#8220;splitpixel&#8221;</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">azimuthaly regrouped data, 2theta pos. and chi pos.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">3-tuple of ndarrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_darkcurrent">
<tt class="descname">set_darkcurrent</tt><big>(</big><em>dark</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_darkcurrent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_darkfiles">
<tt class="descname">set_darkfiles</tt><big>(</big><em>files=None</em>, <em>method='mean'</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_darkfiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the dark current from one or mutliple files, avaraged according to the method provided</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_flatfield">
<tt class="descname">set_flatfield</tt><big>(</big><em>flat</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_flatfield" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_flatfiles">
<tt class="descname">set_flatfiles</tt><big>(</big><em>files</em>, <em>method='mean'</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_flatfiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the flat field from one or mutliple files, avaraged according to the method provided</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_mask">
<tt class="descname">set_mask</tt><big>(</big><em>mask</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_maskfile">
<tt class="descname">set_maskfile</tt><big>(</big><em>maskfile</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.setup_LUT">
<tt class="descname">setup_LUT</tt><big>(</big><em>shape</em>, <em>nbPt</em>, <em>mask=None</em>, <em>pos0_range=None</em>, <em>pos1_range=None</em>, <em>mask_checksum=None</em>, <em>unit=2th_deg</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.setup_LUT" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare a look-up-table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shape</strong> (<em>(int, int)</em>) &#8211; shape of the dataset</li>
<li><strong>nbPt</strong> (<em>int or (int, int)</em>) &#8211; number of points in the the output pattern</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array with masked pixel (1=masked)</li>
<li><strong>pos0_range</strong> (<em>(float, float)</em>) &#8211; range in radial dimension</li>
<li><strong>pos1_range</strong> (<em>(float, float)</em>) &#8211; range in azimuthal dimension</li>
<li><strong>mask_checksum</strong> (<em>int (or anything else ...)</em>) &#8211; checksum of the mask buffer</li>
<li><strong>unit</strong> (<em>pyFAI.units.Enum</em>) &#8211; use to propagate the LUT object for further checkings</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This method is called when a look-up table needs to be set-up.
The <em>shape</em> parameter, correspond to the shape of the original
datatset. It is possible to customize the number of point of
the output histogram with the <em>nbPt</em> parameter which can be
either an integer for an 1D integration or a 2-tuple of
integer in case of a 2D integration. The LUT will have a
different shape: (nbPt, lut_max_size), the later parameter
being calculated during the instanciation of the splitBBoxLUT
class.</p>
<p>It is possible to prepare the LUT with a predefine
<em>mask</em>. This operation can speedup the computation of the
later integrations. Instead of applying the patch on the
dataset, it is taken into account during the histogram
computation. If provided the <em>mask_checksum</em> prevent the
re-calculation of the mask. When the mask changes, its
checksum is used to reset (or not) the LUT (which is a very
time consuming operation !)</p>
<p>It is also possible to restrain the range of the 1D or 2D
pattern with the <em>pos1_range</em> and <em>pos2_range</em>.</p>
<p>The <em>unit</em> parameter is just propagated to the LUT integrator
for further checkings: The aim is to prevent an integration to
be performed in 2th-space when the LUT was setup in q space.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd">
<tt class="descname">xrpd</tt><big>(</big><em>data</em>, <em>nbPt</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>tthRange=None</em>, <em>chiRange=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>polarization_factor=None</em>, <em>dark=None</em>, <em>flat=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the powder diffraction pattern from a set of data,
an image.</p>
<p>Cython implementation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the CCD camera</li>
<li><strong>nbPt</strong> (<em>integer</em>) &#8211; number of points in the output pattern</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; file to save data in ascii format 2 column</li>
<li><strong>correctSolidAngle</strong> (<em>boolean</em>) &#8211; solid angle correction</li>
<li><strong>tthRange</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the 2theta</li>
<li><strong>chiRange</strong> (<em>(float, float), optional, disabled for now</em>) &#8211; The lower and upper range of the chi angle.</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels (dynamic mask)</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; polarization factor correction</li>
<li><strong>dark</strong> (<em>ndarray</em>) &#8211; dark noise image</li>
<li><strong>flat</strong> (<em>ndarray</em>) &#8211; flat field image</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">(2theta, I) in degrees</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2-tuple of 1D arrays</p>
</td>
</tr>
</tbody>
</table>
<p>This method compute the powder diffraction pattern, from a
given <em>data</em> image. The number of point of the pattern is
given by the <em>nbPt</em> parameter. If you give a <em>filename</em>, the
powder diffraction is also saved as a two column text file.</p>
<p>It is possible to correct or not the powder diffraction
pattern using the <em>correctSolidAngle</em> parameter. The weight of
a pixel is ponderate by its solid angle.</p>
<p>The 2theta range of the powder diffraction pattern can be set
using the <em>tthRange</em> parameter. If not given the maximum
available range is used. Indeed pixel outside this range are
ignored.</p>
<p>Each pixel of the <em>data</em> image as also a chi coordinate. So it
is possible to restrain the chi range of the pixels to
consider in the powder diffraction pattern. you just need to
set the range with the <em>chiRange</em> parameter. like the
<em>tthRange</em> parameter, value outside this range are ignored.</p>
<p>Sometimes one needs to mask a few pixels (beamstop, hot
pixels, ...), to ignore a few of them you just need to provide
a <em>mask</em> array with a value of 1 for those pixels. To take a
pixel into account you just need to set a value of 0 in the
mask array. Indeed the shape of the mask array should be
idential to the data shape (size of the array _must_ be the
same). Pixels can also be maseked by seting them to an</p>
<p>Bad pixels can be masked out by setting them to an impossible
value (-1) and calling this value the &#8220;dummy value&#8221;.  Some
Pilatus detectors are setting non existing pixel to -1 and
dead pixels to -2. Then use dummy=-2 &amp; delta_dummy=1.5 so that
any value between -3.5 and -0.5 are considered as bad.</p>
<p>Some Pilatus detectors are setting non existing pixel to -1
and dead pixels to -2. Then use dummy=-2 &amp; delta_dummy=1.5 so
that any value between -3.5 and -0.5 are considered as bad.</p>
<p>The polarisation correction can be taken into account with the
<em>polarization_factor</em> parameter. Set it between [-1, 1], to
correct your data. If set to 0 there is no correction at all.</p>
<p>The <em>dark</em> and the <em>flat</em> can be provided to correct the data
before computing the radial integration.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2">
<tt class="descname">xrpd2</tt><big>(</big><em>data</em>, <em>nbPt2Th</em>, <em>nbPtChi=360</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>tthRange=None</em>, <em>chiRange=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>polarization_factor=None</em>, <em>dark=None</em>, <em>flat=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the 2D powder diffraction pattern (2Theta,Chi) from
a set of data, an image</p>
<p>Split pixels according to their coordinate and a bounding box</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the CCD camera</li>
<li><strong>nbPt2Th</strong> &#8211; number of bin of the Radial (horizontal) axis (2Theta)</li>
<li><strong>nbPtChi</strong> (<em>int</em>) &#8211; number of bin of the Azimuthal (vertical) axis (chi)</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; file to save data in</li>
<li><strong>correctSolidAngle</strong> (<em>boolean</em>) &#8211; solid angle correction</li>
<li><strong>tthRange</strong> (<em>(float, float)</em>) &#8211; The lower and upper range of 2theta</li>
<li><strong>chiRange</strong> (<em>(float, float), disabled for now</em>) &#8211; The lower and upper range of the chi angle.</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels (dynamic mask)</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; polarization factor correction</li>
<li><strong>dark</strong> (<em>ndarray</em>) &#8211; dark noise image</li>
<li><strong>flat</strong> (<em>ndarray</em>) &#8211; flat field image</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">azimuthaly regrouped data, 2theta pos. and chi pos.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">3-tuple of ndarrays</p>
</td>
</tr>
</tbody>
</table>
<p>This method convert the <em>data</em> image from the pixel
coordinates to the 2theta, chi coordinates. This is similar to
a rectangular to polar conversion. The number of point of the
new image is given by <em>nbPt2Th</em> and <em>nbPtChi</em>. If you give a
<em>filename</em>, the new image is also saved as an edf file.</p>
<p>It is possible to correct the 2theta/chi pattern using the
<em>correctSolidAngle</em> parameter. The weight of a pixel is
ponderate by its solid angle.</p>
<p>The 2theta and range of the new image can be set using the
<em>tthRange</em> parameter. If not given the maximum available range
is used. Indeed pixel outside this range are ignored.</p>
<p>Each pixel of the <em>data</em> image has a 2theta and a chi
coordinate. So it is possible to restrain on any of those
ranges ; you just need to set the range with the <em>tthRange</em> or
thee <em>chiRange</em> parameter. like the <em>tthRange</em> parameter,
value outside this range are ignored.</p>
<p>Sometimes one needs to mask a few pixels (beamstop, hot
pixels, ...), to ignore a few of them you just need to provide
a <em>mask</em> array with a value of 1 for those pixels. To take a
pixel into account you just need to set a value of 0 in the
mask array. Indeed the shape of the mask array should be
idential to the data shape (size of the array _must_ be the
same).</p>
<p>Masking can also be achieved by setting masked pixels to an
impossible value (-1) and calling this value the &#8220;dummy
value&#8221;. Some Pilatus detectors are setting non existing pixel
to -1 and dead pixels to -2. Then use dummy=-2 &amp;
delta_dummy=1.5 so that any value between -3.5 and -0.5 are
considered as bad.</p>
<p>the polarisation correction can be taken into account with the
<em>polarization_factor</em> parameter. Set it between [-1, 1], to
correct your data. If set to 0 there is no correction at all.</p>
<p>The <em>dark</em> and the <em>flat</em> can be provided to correct the data
before computing the radial integration.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_histogram">
<tt class="descname">xrpd2_histogram</tt><big>(</big><em>data</em>, <em>nbPt2Th</em>, <em>nbPtChi=360</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>dark=None</em>, <em>flat=None</em>, <em>tthRange=None</em>, <em>chiRange=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the 2D powder diffraction pattern (2Theta,Chi) from
a set of data, an image</p>
<p>Cython implementation: fast but incaccurate</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the CCD camera</li>
<li><strong>nbPt2Th</strong> &#8211; number of bin of the Radial (horizontal) axis (2Theta)</li>
<li><strong>nbPtChi</strong> (<em>int</em>) &#8211; number of bin of the Azimuthal (vertical) axis (chi)</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; file to save data in</li>
<li><strong>correctSolidAngle</strong> (<em>boolean</em>) &#8211; solid angle correction</li>
<li><strong>tthRange</strong> (<em>(float, float)</em>) &#8211; The lower and upper range of 2theta</li>
<li><strong>chiRange</strong> (<em>(float, float), disabled for now</em>) &#8211; The lower and upper range of the chi angle.</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels (dynamic mask)</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">azimuthaly regrouped data, 2theta pos and chipos</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">3-tuple of ndarrays</p>
</td>
</tr>
</tbody>
</table>
<p>This method convert the <em>data</em> image from the pixel
coordinates to the 2theta, chi coordinates. This is simular to
a rectangular to polar conversion. The number of point of the
new image is given by <em>nbPt2Th</em> and <em>nbPtChi</em>. If you give a
<em>filename</em>, the new image is also saved as an edf file.</p>
<p>It is possible to correct the 2theta/chi pattern using the
<em>correctSolidAngle</em> parameter. The weight of a pixel is
ponderate by its solid angle.</p>
<p>The 2theta and range of the new image can be set using the
<em>tthRange</em> parameter. If not given the maximum available range
is used. Indeed pixel outside this range are ignored.</p>
<p>Each pixel of the <em>data</em> image has a 2theta and a chi
coordinate. So it is possible to restrain on any of those
ranges ; you just need to set the range with the <em>tthRange</em> or
thee <em>chiRange</em> parameter. like the <em>tthRange</em> parameter,
value outside this range are ignored.</p>
<p>Sometimes one needs to mask a few pixels (beamstop, hot
pixels, ...), to ignore a few of them you just need to provide
a <em>mask</em> array with a value of 1 for those pixels. To take a
pixel into account you just need to set a value of 0 in the
mask array. Indeed the shape of the mask array should be
idential to the data shape (size of the array _must_ be the
same).</p>
<p>Masking can also be achieved by setting masked pixels to an
impossible value (-1) and calling this value the &#8220;dummy
value&#8221;. Some Pilatus detectors are setting non existing pixel
to -1 and dead pixels to -2. Then use dummy=-2 &amp;
delta_dummy=1.5 so that any value between -3.5 and -0.5 are
considered as bad.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_numpy">
<tt class="descname">xrpd2_numpy</tt><big>(</big><em>data</em>, <em>nbPt2Th</em>, <em>nbPtChi=360</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>dark=None</em>, <em>flat=None</em>, <em>tthRange=None</em>, <em>chiRange=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the 2D powder diffraction pattern (2Theta, Chi) from
a set of data, an image</p>
<p>Pure numpy implementation (VERY SLOW !!!)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the CCD camera</li>
<li><strong>nbPt2Th</strong> &#8211; number of bin of the Radial (horizontal) axis (2Theta)</li>
<li><strong>nbPtChi</strong> (<em>int</em>) &#8211; number of bin of the Azimuthal (vertical) axis (chi)</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; file to save data in</li>
<li><strong>correctSolidAngle</strong> (<em>boolean</em>) &#8211; solid angle correction</li>
<li><strong>tthRange</strong> (<em>(float, float)</em>) &#8211; The lower and upper range of 2theta</li>
<li><strong>chiRange</strong> (<em>(float, float), disabled for now</em>) &#8211; The lower and upper range of the chi angle.</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels (dynamic mask)</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">azimuthaly regrouped data, 2theta pos and chipos</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">3-tuple of ndarrays</p>
</td>
</tr>
</tbody>
</table>
<p>This method convert the <em>data</em> image from the pixel
coordinates to the 2theta, chi coordinates. This is simular to
a rectangular to polar conversion. The number of point of the
new image is given by <em>nbPt2Th</em> and <em>nbPtChi</em>. If you give a
<em>filename</em>, the new image is also saved as an edf file.</p>
<p>It is possible to correct the 2theta/chi pattern using the
<em>correctSolidAngle</em> parameter. The weight of a pixel is
ponderate by its solid angle.</p>
<p>The 2theta and range of the new image can be set using the
<em>tthRange</em> parameter. If not given the maximum available range
is used. Indeed pixel outside this range are ignored.</p>
<p>Each pixel of the <em>data</em> image has a 2theta and a chi
coordinate. So it is possible to restrain on any of those
ranges ; you just need to set the range with the <em>tthRange</em> or
thee <em>chiRange</em> parameter. like the <em>tthRange</em> parameter,
value outside this range are ignored.</p>
<p>Sometimes one needs to mask a few pixels (beamstop, hot
pixels, ...), to ignore a few of them you just need to provide
a <em>mask</em> array with a value of 1 for those pixels. To take a
pixel into account you just need to set a value of 0 in the
mask array. Indeed the shape of the mask array should be
idential to the data shape (size of the array _must_ be the
same).</p>
<p>Masking can also be achieved by setting masked pixels to an
impossible value (-1) and calling this value the &#8220;dummy
value&#8221;.  Some Pilatus detectors are setting non existing pixel
to -1 and dead pixels to -2. Then use dummy=-2 &amp;
delta_dummy=1.5 so that any value between -3.5 and -0.5 are
considered as bad.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_splitBBox">
<tt class="descname">xrpd2_splitBBox</tt><big>(</big><em>data</em>, <em>nbPt2Th</em>, <em>nbPtChi=360</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>tthRange=None</em>, <em>chiRange=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>polarization_factor=None</em>, <em>dark=None</em>, <em>flat=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_splitBBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the 2D powder diffraction pattern (2Theta,Chi) from
a set of data, an image</p>
<p>Split pixels according to their coordinate and a bounding box</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the CCD camera</li>
<li><strong>nbPt2Th</strong> &#8211; number of bin of the Radial (horizontal) axis (2Theta)</li>
<li><strong>nbPtChi</strong> (<em>int</em>) &#8211; number of bin of the Azimuthal (vertical) axis (chi)</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; file to save data in</li>
<li><strong>correctSolidAngle</strong> (<em>boolean</em>) &#8211; solid angle correction</li>
<li><strong>tthRange</strong> (<em>(float, float)</em>) &#8211; The lower and upper range of 2theta</li>
<li><strong>chiRange</strong> (<em>(float, float), disabled for now</em>) &#8211; The lower and upper range of the chi angle.</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels (dynamic mask)</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; polarization factor correction</li>
<li><strong>dark</strong> (<em>ndarray</em>) &#8211; dark noise image</li>
<li><strong>flat</strong> (<em>ndarray</em>) &#8211; flat field image</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">azimuthaly regrouped data, 2theta pos. and chi pos.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">3-tuple of ndarrays</p>
</td>
</tr>
</tbody>
</table>
<p>This method convert the <em>data</em> image from the pixel
coordinates to the 2theta, chi coordinates. This is similar to
a rectangular to polar conversion. The number of point of the
new image is given by <em>nbPt2Th</em> and <em>nbPtChi</em>. If you give a
<em>filename</em>, the new image is also saved as an edf file.</p>
<p>It is possible to correct the 2theta/chi pattern using the
<em>correctSolidAngle</em> parameter. The weight of a pixel is
ponderate by its solid angle.</p>
<p>The 2theta and range of the new image can be set using the
<em>tthRange</em> parameter. If not given the maximum available range
is used. Indeed pixel outside this range are ignored.</p>
<p>Each pixel of the <em>data</em> image has a 2theta and a chi
coordinate. So it is possible to restrain on any of those
ranges ; you just need to set the range with the <em>tthRange</em> or
thee <em>chiRange</em> parameter. like the <em>tthRange</em> parameter,
value outside this range are ignored.</p>
<p>Sometimes one needs to mask a few pixels (beamstop, hot
pixels, ...), to ignore a few of them you just need to provide
a <em>mask</em> array with a value of 1 for those pixels. To take a
pixel into account you just need to set a value of 0 in the
mask array. Indeed the shape of the mask array should be
idential to the data shape (size of the array _must_ be the
same).</p>
<p>Masking can also be achieved by setting masked pixels to an
impossible value (-1) and calling this value the &#8220;dummy
value&#8221;. Some Pilatus detectors are setting non existing pixel
to -1 and dead pixels to -2. Then use dummy=-2 &amp;
delta_dummy=1.5 so that any value between -3.5 and -0.5 are
considered as bad.</p>
<p>the polarisation correction can be taken into account with the
<em>polarization_factor</em> parameter. Set it between [-1, 1], to
correct your data. If set to 0 there is no correction at all.</p>
<p>The <em>dark</em> and the <em>flat</em> can be provided to correct the data
before computing the radial integration.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_splitPixel">
<tt class="descname">xrpd2_splitPixel</tt><big>(</big><em>data</em>, <em>nbPt2Th</em>, <em>nbPtChi=360</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>tthRange=None</em>, <em>chiRange=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>polarization_factor=None</em>, <em>dark=None</em>, <em>flat=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_splitPixel" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the 2D powder diffraction pattern (2Theta,Chi) from
a set of data, an image</p>
<p>Split pixels according to their corner positions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the CCD camera</li>
<li><strong>nbPt2Th</strong> &#8211; number of bin of the Radial (horizontal) axis (2Theta)</li>
<li><strong>nbPtChi</strong> (<em>int</em>) &#8211; number of bin of the Azimuthal (vertical) axis (chi)</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; file to save data in</li>
<li><strong>correctSolidAngle</strong> (<em>boolean</em>) &#8211; solid angle correction</li>
<li><strong>tthRange</strong> (<em>(float, float)</em>) &#8211; The lower and upper range of 2theta</li>
<li><strong>chiRange</strong> (<em>(float, float), disabled for now</em>) &#8211; The lower and upper range of the chi angle.</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels (dynamic mask)</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; polarization factor correction</li>
<li><strong>dark</strong> (<em>ndarray</em>) &#8211; dark noise image</li>
<li><strong>flat</strong> (<em>ndarray</em>) &#8211; flat field image</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">azimuthaly regrouped data, 2theta pos. and chi pos.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">3-tuple of ndarrays</p>
</td>
</tr>
</tbody>
</table>
<p>This method convert the <em>data</em> image from the pixel
coordinates to the 2theta, chi coordinates. This is similar to
a rectangular to polar conversion. The number of point of the
new image is given by <em>nbPt2Th</em> and <em>nbPtChi</em>. If you give a
<em>filename</em>, the new image is also saved as an edf file.</p>
<p>It is possible to correct the 2theta/chi pattern using the
<em>correctSolidAngle</em> parameter. The weight of a pixel is
ponderate by its solid angle.</p>
<p>The 2theta and range of the new image can be set using the
<em>tthRange</em> parameter. If not given the maximum available range
is used. Indeed pixel outside this range are ignored.</p>
<p>Each pixel of the <em>data</em> image has a 2theta and a chi
coordinate. So it is possible to restrain on any of those
ranges ; you just need to set the range with the <em>tthRange</em> or
thee <em>chiRange</em> parameter. like the <em>tthRange</em> parameter,
value outside this range are ignored.</p>
<p>Sometimes one needs to mask a few pixels (beamstop, hot
pixels, ...), to ignore a few of them you just need to provide
a <em>mask</em> array with a value of 1 for those pixels. To take a
pixel into account you just need to set a value of 0 in the
mask array. Indeed the shape of the mask array should be
idential to the data shape (size of the array _must_ be the
same).</p>
<p>Masking can also be achieved by setting masked pixels to an
impossible value (-1) and calling this value the &#8220;dummy
value&#8221;. Some Pilatus detectors are setting non existing pixel
to -1 and dead pixels to -2. Then use dummy=-2 &amp;
delta_dummy=1.5 so that any value between -3.5 and -0.5 are
considered as bad.</p>
<p>the polarisation correction can be taken into account with the
<em>polarization_factor</em> parameter. Set it between [-1, 1], to
correct your data. If set to 0 there is no correction at all.</p>
<p>The <em>dark</em> and the <em>flat</em> can be provided to correct the data
before computing the radial integration.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_LUT">
<tt class="descname">xrpd_LUT</tt><big>(</big><em>data</em>, <em>nbPt</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>tthRange=None</em>, <em>chiRange=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>safe=True</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_LUT" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the powder diffraction pattern from an image.</p>
<p>Parallel Cython implementation using a Look-Up Table (OpenMP).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the CCD camera</li>
<li><strong>nbPt</strong> (<em>integer</em>) &#8211; number of points in the output pattern</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; file to save data in ascii format 2 column</li>
<li><strong>correctSolidAngle</strong> (<em>boolean</em>) &#8211; solid angle correction</li>
<li><strong>tthRange</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the 2theta angle</li>
<li><strong>chiRange</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the chi angle.</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels (dynamic mask)</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>LUT specific parameters:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>safe</strong> (<em>bool</em>) &#8211; set to False if your LUT is already set-up correctly (mask, ranges, ...).</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">(2theta, I) with 2theta angle in degrees</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body">2-tuple of 1D arrays</td>
</tr>
</tbody>
</table>
<p>This method compute the powder diffraction pattern, from a
given <em>data</em> image. The number of point of the pattern is
given by the <em>nbPt</em> parameter. If you give a <em>filename</em>, the
powder diffraction is also saved as a two column text file.</p>
<p>It is possible to correct or not the powder diffraction
pattern using the <em>correctSolidAngle</em> parameter. The weight of
a pixel is ponderate by its solid angle.</p>
<p>The 2theta range of the powder diffraction pattern can be set
using the <em>tthRange</em> parameter. If not given the maximum
available range is used. Indeed pixel outside this range are
ignored.</p>
<p>Each pixel of the <em>data</em> image as also a chi coordinate. So it
is possible to restrain the chi range of the pixels to
consider in the powder diffraction pattern by setting the
range with the <em>chiRange</em> parameter. Like the <em>tthRange</em>
parameter, value outside this range are ignored.</p>
<p>Sometimes one needs to mask a few pixels (beamstop, hot
pixels, ...), to ignore a few of them you just need to provide
a <em>mask</em> array with a value of 1 for those pixels. To take a
pixel into account you just need to set a value of 0 in the
mask array. Indeed the shape of the mask array should be
idential to the data shape (size of the array _must_ be the
same).</p>
<p>Dynamic masking (i.e recalculated for each image) can be
achieved by setting masked pixels to an impossible value (-1)
and calling this value the &#8220;dummy value&#8221;. Dynamic masking is
computed at integration whereas static masking is done at
LUT-generation, hence faster.</p>
<p>Some Pilatus detectors are setting non existing pixel to -1
and dead pixels to -2. Then use dummy=-2 &amp; delta_dummy=1.5 so
that any value between -3.5 and -0.5 are considered as bad.</p>
<p>The <em>safe</em> parameter is specific to the LUT implementation,
you can set it to false if you think the LUT calculated is
already the correct one (setup, mask, 2theta/chi range).</p>
<p>TODO: replace with inegrate1D</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_LUT_OCL">
<tt class="descname">xrpd_LUT_OCL</tt><big>(</big><em>data</em>, <em>nbPt</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>tthRange=None</em>, <em>chiRange=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>safe=True</em>, <em>devicetype='all'</em>, <em>platformid=None</em>, <em>deviceid=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_LUT_OCL" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the powder diffraction pattern from a set of data,
an image.</p>
<p>PyOpenCL implementation using a Look-Up Table (OpenCL). The
look-up table is a Cython module.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the CCD camera</li>
<li><strong>nbPt</strong> (<em>integer</em>) &#8211; number of points in the output pattern</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; file to save data in ascii format 2 column</li>
<li><strong>correctSolidAngle</strong> (<em>boolean</em>) &#8211; solid angle correction</li>
<li><strong>tthRange</strong> (<em>(float, float)</em>) &#8211; The lower and upper range of 2theta</li>
<li><strong>chiRange</strong> (<em>(float, float)</em>) &#8211; The lower and upper range of the chi angle in degrees.</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels (dynamic mask)</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>LUT specific parameters:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>safe</strong> (<em>bool</em>) &#8211; set to False if your LUT &amp; GPU is already set-up correctly</td>
</tr>
</tbody>
</table>
<p>OpenCL specific parameters:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>devicetype</strong> (<em>str</em>) &#8211; can be &#8220;all&#8221;, &#8220;cpu&#8221;, &#8220;gpu&#8221;, &#8220;acc&#8221; or &#8220;def&#8221;</li>
<li><strong>platformid</strong> (<em>int</em>) &#8211; platform number</li>
<li><strong>deviceid</strong> (<em>int</em>) &#8211; device number</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">(2theta, I) in degrees</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2-tuple of 1D arrays</p>
</td>
</tr>
</tbody>
</table>
<p>This method compute the powder diffraction pattern, from a
given <em>data</em> image. The number of point of the pattern is
given by the <em>nbPt</em> parameter. If you give a <em>filename</em>, the
powder diffraction is also saved as a two column text file.</p>
<p>It is possible to correct or not the powder diffraction
pattern using the <em>correctSolidAngle</em> parameter. The weight of
a pixel is ponderate by its solid angle.</p>
<p>The 2theta range of the powder diffraction pattern can be set
using the <em>tthRange</em> parameter. If not given the maximum
available range is used. Indeed pixel outside this range are
ignored.</p>
<p>Each pixel of the <em>data</em> image has also a chi coordinate. So
it is possible to restrain the chi range of the pixels to
consider in the powder diffraction pattern by setting the
<em>chiRange</em> parameter. Like the <em>tthRange</em> parameter, value
outside this range are ignored.</p>
<p>Sometimes one needs to mask a few pixels (beamstop, hot
pixels, ...), to ignore a few of them you just need to provide
a <em>mask</em> array with a value of 1 for those pixels. To take a
pixel into account you just need to set a value of 0 in the
mask array. Indeed the shape of the mask array should be
idential to the data shape (size of the array _must_ be the
same).</p>
<p>Dynamic masking (i.e recalculated for each image) can be
achieved by setting masked pixels to an impossible value (-1)
and calling this value the &#8220;dummy value&#8221;. Dynamic masking is
computed at integration whereas static masking is done at
LUT-generation, hence faster.</p>
<p>Some Pilatus detectors are setting non existing pixel to -1
and dead pixels to -2. Then use dummy=-2 &amp; delta_dummy=1.5 so
that any value between -3.5 and -0.5 are considered as bad.</p>
<p>The <em>safe</em> parameter is specific to the OpenCL/LUT
implementation, you can set it to false if you think the LUT
calculated is already the correct one (setup, mask, 2theta/chi
range) and the device set-up is the expected one.</p>
<p><em>devicetype</em>, <em>platformid</em> and <em>deviceid</em>, parameters are
specific to the OpenCL implementation. If you set <em>devicetype</em>
to &#8216;all&#8217;, &#8216;cpu&#8217;, or &#8216;gpu&#8217; you can force the device used to
perform the computation. By providing the <em>platformid</em> and
<em>deviceid</em> you can chose a specific device (computer
specific).</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_OpenCL">
<tt class="descname">xrpd_OpenCL</tt><big>(</big><em>data</em>, <em>nbPt</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>dark=None</em>, <em>flat=None</em>, <em>tthRange=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>devicetype='gpu'</em>, <em>useFp64=True</em>, <em>platformid=None</em>, <em>deviceid=None</em>, <em>safe=True</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_OpenCL" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the powder diffraction pattern from a set of data,
an image.</p>
<p>This is (now) a pure pyopencl implementation so it just needs
pyopencl which requires a clean OpenCL installation. This
implementation is not slower than the previous Cython and is
less problematic for compilation/installation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the CCD camera</li>
<li><strong>nbPt</strong> (<em>integer</em>) &#8211; number of points in the output pattern</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; file to save data in ascii format 2 column</li>
<li><strong>correctSolidAngle</strong> (<em>boolean</em>) &#8211; solid angle correction</li>
<li><strong>tthRange</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the 2theta</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels (dynamic mask)</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>OpenCL specific parameters:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>devicetype</strong> (<em>str</em>) &#8211; possible values &#8220;cpu&#8221;, &#8220;gpu&#8221;, &#8220;all&#8221; or &#8220;def&#8221;</li>
<li><strong>useFp64</strong> (<em>bool</em>) &#8211; shall histogram be done in double precision (strongly adviced)</li>
<li><strong>platformid</strong> (<em>int</em>) &#8211; platform number</li>
<li><strong>deviceid</strong> (<em>int</em>) &#8211; device number</li>
<li><strong>safe</strong> (<em>bool</em>) &#8211; set to False if your GPU is already set-up correctly</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">(2theta, I) angle being in degrees</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2-tuple of 1D arrays</p>
</td>
</tr>
</tbody>
</table>
<p>This method compute the powder diffraction pattern, from a
given <em>data</em> image. The number of point of the pattern is
given by the <em>nbPt</em> parameter. If you give a <em>filename</em>, the
powder diffraction is also saved as a two column text file.
The powder diffraction is computed internally using an
histogram which by default use should be done in 64bits. One
can switch to 32 bits with the <em>useFp64</em> parameter set to
False. In 32bit mode; do not expect better than 1% error and
one can even observe overflows ! 32 bits is only left for
testing hardware capabilities and should NEVER be used in any
real experiment analysis.</p>
<p>It is possible to correct or not the powder diffraction
pattern using the <em>correctSolidAngle</em> parameter. The weight of
a pixel is ponderate by its solid angle.</p>
<p>The 2theta range of the powder diffraction pattern can be set
using the <em>tthRange</em> parameter. If not given the maximum
available range is used. Indeed pixel outside this range are
ignored.</p>
<p>Each pixel of the <em>data</em> image has also a chi coordinate. So
it is possible to restrain the chi range of the pixels to
consider in the powder diffraction pattern. You just need to
set the range with the <em>chiRange</em> parameter; like the
<em>tthRange</em> parameter, value outside this range are ignored.</p>
<p>Sometimes one needs to mask a few pixels (beamstop, hot
pixels, ...), to ignore a few of them you just need to provide
a <em>mask</em> array with a value of 1 for those pixels. To take a
pixel into account you just need to set a value of 0 in the
mask array. Indeed the shape of the mask array should be
idential to the data shape (size of the array _must_ be the
same).</p>
<p>Bad pixels can also be masked by setting them to an impossible
value (-1) and calling this value the &#8220;dummy value&#8221;.  Some
Pilatus detectors are setting non existing pixel to -1 and
dead pixels to -2. Then use dummy=-2 &amp; delta_dummy=1.5 so that
any value between -3.5 and -0.5 are considered as bad.</p>
<p><em>devicetype</em>, <em>platformid</em> and <em>deviceid</em>, parameters are
specific to the OpenCL implementation. If you set <em>devicetype</em>
to &#8216;all&#8217;, &#8216;cpu&#8217;, &#8216;gpu&#8217;, &#8216;def&#8217; you can force the device used to
perform the computation; the program will select the device
accordinly. By setting <em>platformid</em> and <em>deviceid</em>, you can
directly address a specific device (which is computer
specific).</p>
<p>The <em>safe</em> parameter is specific to the integrator object,
located on the OpenCL device. You can set it to False if you
think the integrator is already setup correcty (device,
geometric arrays, mask, 2theta/chi range). Unless many tests
will be done at each integration.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_cython">
<tt class="descname">xrpd_cython</tt><big>(</big><em>data</em>, <em>nbPt</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>tthRange=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>polarization_factor=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>pixelSize=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_cython" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the powder diffraction pattern from a set of data,
an image.</p>
<p>Cython multithreaded implementation: fast but still lacks
pixels splitting as numpy implementation. This method should
not be used in production, it remains to explain why
histograms are hard to implement in parallel. Use
xrpd_splitBBox instead</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_numpy">
<tt class="descname">xrpd_numpy</tt><big>(</big><em>data</em>, <em>nbPt</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>tthRange=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>polarization_factor=None</em>, <em>dark=None</em>, <em>flat=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the powder diffraction pattern from a set of data,
an image.</p>
<p>Numpy implementation: slow and without pixels splitting.
This method should not be used in production, it remains
to explain how other more sophisticated algorithms works.
Use xrpd_splitBBox instead</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the CCD camera</li>
<li><strong>nbPt</strong> (<em>integer</em>) &#8211; number of points in the output pattern</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; file to save data in ascii format 2 column</li>
<li><strong>correctSolidAngle</strong> (<em>bool</em>) &#8211; solid angle correction</li>
<li><strong>tthRange</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the 2theta</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels (dynamic mask)</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; polarization factor correction</li>
<li><strong>dark</strong> (<em>ndarray</em>) &#8211; dark noise image</li>
<li><strong>flat</strong> (<em>ndarray</em>) &#8211; flat field image</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">(2theta, I) in degrees</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2-tuple of 1D arrays</p>
</td>
</tr>
</tbody>
</table>
<p>This method compute the powder diffraction pattern, from a
given <em>data</em> image. The number of point of the pattern is
given by the <em>nbPt</em> parameter. If you give a <em>filename</em>, the
powder diffraction is also saved as a two column text file.</p>
<p>It is possible to correct or not the powder diffraction
pattern using the <em>correctSolidAngle</em> parameter. The weight of
a pixel is ponderate by its solid angle.</p>
<p>The 2theta range of the powder diffraction pattern can be set
using the <em>tthRange</em> parameter. If not given the maximum
available range is used. Indeed pixel outside this range are
ignored.</p>
<p>Sometimes one needs to mask a few pixels (beamstop, hot
pixels, ...), to ignore a few of them you just need to provide
a <em>mask</em> array with a value of 1 for those pixels. To take a
pixel into account you just need to set a value of 0 in the
mask array. Indeed the shape of the mask array should be
idential to the data shape (size of the array _must_ be the
same).</p>
<p>Bad pixels can be masked out by setting them to an impossible
value (-1) and calling this value the &#8220;dummy value&#8221;.  Some
Pilatus detectors are setting non existing pixel to -1 and
dead pixels to -2. Then use dummy=-2 &amp; delta_dummy=1.5 so that
any value between -3.5 and -0.5 are considered as bad.</p>
<p>The polarisation correction can be taken into account with the
<em>polarization_factor</em> parameter. Set it between [-1, 1], to
correct your data. If set to 0 there is no correction at all.</p>
<p>The <em>dark</em> and the <em>flat</em> can be provided to correct the data
before computing the radial integration.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_splitBBox">
<tt class="descname">xrpd_splitBBox</tt><big>(</big><em>data</em>, <em>nbPt</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>tthRange=None</em>, <em>chiRange=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>polarization_factor=None</em>, <em>dark=None</em>, <em>flat=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_splitBBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the powder diffraction pattern from a set of data,
an image.</p>
<p>Cython implementation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the CCD camera</li>
<li><strong>nbPt</strong> (<em>integer</em>) &#8211; number of points in the output pattern</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; file to save data in ascii format 2 column</li>
<li><strong>correctSolidAngle</strong> (<em>boolean</em>) &#8211; solid angle correction</li>
<li><strong>tthRange</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the 2theta</li>
<li><strong>chiRange</strong> (<em>(float, float), optional, disabled for now</em>) &#8211; The lower and upper range of the chi angle.</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels (dynamic mask)</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; polarization factor correction</li>
<li><strong>dark</strong> (<em>ndarray</em>) &#8211; dark noise image</li>
<li><strong>flat</strong> (<em>ndarray</em>) &#8211; flat field image</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">(2theta, I) in degrees</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2-tuple of 1D arrays</p>
</td>
</tr>
</tbody>
</table>
<p>This method compute the powder diffraction pattern, from a
given <em>data</em> image. The number of point of the pattern is
given by the <em>nbPt</em> parameter. If you give a <em>filename</em>, the
powder diffraction is also saved as a two column text file.</p>
<p>It is possible to correct or not the powder diffraction
pattern using the <em>correctSolidAngle</em> parameter. The weight of
a pixel is ponderate by its solid angle.</p>
<p>The 2theta range of the powder diffraction pattern can be set
using the <em>tthRange</em> parameter. If not given the maximum
available range is used. Indeed pixel outside this range are
ignored.</p>
<p>Each pixel of the <em>data</em> image as also a chi coordinate. So it
is possible to restrain the chi range of the pixels to
consider in the powder diffraction pattern. you just need to
set the range with the <em>chiRange</em> parameter. like the
<em>tthRange</em> parameter, value outside this range are ignored.</p>
<p>Sometimes one needs to mask a few pixels (beamstop, hot
pixels, ...), to ignore a few of them you just need to provide
a <em>mask</em> array with a value of 1 for those pixels. To take a
pixel into account you just need to set a value of 0 in the
mask array. Indeed the shape of the mask array should be
idential to the data shape (size of the array _must_ be the
same). Pixels can also be maseked by seting them to an</p>
<p>Bad pixels can be masked out by setting them to an impossible
value (-1) and calling this value the &#8220;dummy value&#8221;.  Some
Pilatus detectors are setting non existing pixel to -1 and
dead pixels to -2. Then use dummy=-2 &amp; delta_dummy=1.5 so that
any value between -3.5 and -0.5 are considered as bad.</p>
<p>Some Pilatus detectors are setting non existing pixel to -1
and dead pixels to -2. Then use dummy=-2 &amp; delta_dummy=1.5 so
that any value between -3.5 and -0.5 are considered as bad.</p>
<p>The polarisation correction can be taken into account with the
<em>polarization_factor</em> parameter. Set it between [-1, 1], to
correct your data. If set to 0 there is no correction at all.</p>
<p>The <em>dark</em> and the <em>flat</em> can be provided to correct the data
before computing the radial integration.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_splitPixel">
<tt class="descname">xrpd_splitPixel</tt><big>(</big><em>data</em>, <em>nbPt</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>tthRange=None</em>, <em>chiRange=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>polarization_factor=None</em>, <em>dark=None</em>, <em>flat=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_splitPixel" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the powder diffraction pattern from a set of data,
an image.</p>
<p>Cython implementation (single threaded)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the CCD camera</li>
<li><strong>nbPt</strong> (<em>integer</em>) &#8211; number of points in the output pattern</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; file to save data in ascii format 2 column</li>
<li><strong>correctSolidAngle</strong> (<em>boolean</em>) &#8211; solid angle correction</li>
<li><strong>tthRange</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the 2theta</li>
<li><strong>chiRange</strong> (<em>(float, float), optional, disabled for now</em>) &#8211; The lower and upper range of the chi angle.</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels (dynamic mask)</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; polarization factor correction</li>
<li><strong>dark</strong> (<em>ndarray</em>) &#8211; dark noise image</li>
<li><strong>flat</strong> (<em>ndarray</em>) &#8211; flat field image</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">(2theta, I) in degrees</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2-tuple of 1D arrays</p>
</td>
</tr>
</tbody>
</table>
<p>This method compute the powder diffraction pattern, from a
given <em>data</em> image. The number of point of the pattern is
given by the <em>nbPt</em> parameter. If you give a <em>filename</em>, the
powder diffraction is also saved as a two column text file.</p>
<p>It is possible to correct or not the powder diffraction
pattern using the <em>correctSolidAngle</em> parameter. The weight of
a pixel is ponderate by its solid angle.</p>
<p>The 2theta range of the powder diffraction pattern can be set
using the <em>tthRange</em> parameter. If not given the maximum
available range is used. Indeed pixel outside this range are
ignored.</p>
<p>Each pixel of the <em>data</em> image as also a chi coordinate. So it
is possible to restrain the chi range of the pixels to
consider in the powder diffraction pattern. you just need to
set the range with the <em>chiRange</em> parameter. like the
<em>tthRange</em> parameter, value outside this range are ignored.</p>
<p>Sometimes one needs to mask a few pixels (beamstop, hot
pixels, ...), to ignore a few of them you just need to provide
a <em>mask</em> array with a value of 1 for those pixels. To take a
pixel into account you just need to set a value of 0 in the
mask array. Indeed the shape of the mask array should be
idential to the data shape (size of the array _must_ be the
same).</p>
<p>Bad pixels can be masked out by setting them to an impossible
value (-1) and calling this value the &#8220;dummy value&#8221;.  Some
Pilatus detectors are setting non existing pixel to -1 and
dead pixels to -2. Then use dummy=-2 &amp; delta_dummy=1.5 so that
any value between -3.5 and -0.5 are considered as bad.</p>
<p>Some Pilatus detectors are setting non existing pixel to -1
and dead pixels to -2. Then use dummy=-2 &amp; delta_dummy=1.5 so
that any value between -3.5 and -0.5 are considered as bad.</p>
<p>The polarisation correction can be taken into account with the
<em>polarization_factor</em> parameter. Set it between [-1, 1], to
correct your data. If set to 0 there is no correction at all.</p>
<p>The <em>dark</em> and the <em>flat</em> can be provided to correct the data
before computing the radial integration.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.detectors">
<span id="detectors-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">detectors</span></tt> Module<a class="headerlink" href="#module-pyFAI.detectors" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyFAI.detectors.Basler">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Basler</tt><big>(</big><em>pixel=3.7500000000000001e-06</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Basler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Basler camera are simple CCD camara over GigaE</p>
</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Detector">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Detector</tt><big>(</big><em>pixel1=None</em>, <em>pixel2=None</em>, <em>splineFile=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Generic class representing a 2D detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Detector.binning">
<tt class="descname">binning</tt><a class="headerlink" href="#pyFAI.detectors.Detector.binning" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.calc_cartesian_positions">
<tt class="descname">calc_cartesian_positions</tt><big>(</big><em>d1=None</em>, <em>d2=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.calc_cartesian_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of each pixel center in cartesian coordinate
and in meter of a couple of coordinates.
The half pixel offset is taken into account here !!!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the Y pixel positions (slow dimension)</li>
<li><strong>d2</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the X pixel positions (fast dimension)</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">position in meter of the center of each pixels.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
<p>d1 and d2 must have the same shape, returned array will have
the same shape.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Detectors with gaps should overwrite this method with
something actually calculating the mask!</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.getFit2D">
<tt class="descname">getFit2D</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.getFit2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to serialize the description of a detector using the Fit2d units</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">representation of the detector easy to serialize</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.getPyFAI">
<tt class="descname">getPyFAI</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.getPyFAI" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to serialize the description of a detector using the pyFAI way
with everything in S.I units.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">representation of the detector easy to serialize</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_binning">
<tt class="descname">get_binning</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_binning" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_mask">
<tt class="descname">get_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_maskfile">
<tt class="descname">get_maskfile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_pixel1">
<tt class="descname">get_pixel1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_pixel1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_pixel2">
<tt class="descname">get_pixel2</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_pixel2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_splineFile">
<tt class="descname">get_splineFile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.mask">
<tt class="descname">mask</tt><a class="headerlink" href="#pyFAI.detectors.Detector.mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.maskfile">
<tt class="descname">maskfile</tt><a class="headerlink" href="#pyFAI.detectors.Detector.maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.pixel1">
<tt class="descname">pixel1</tt><a class="headerlink" href="#pyFAI.detectors.Detector.pixel1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.pixel2">
<tt class="descname">pixel2</tt><a class="headerlink" href="#pyFAI.detectors.Detector.pixel2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.setFit2D">
<tt class="descname">setFit2D</tt><big>(</big><em>**kwarg</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.setFit2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Twin method of getFit2D: setup a detector instance according to a description</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kwarg</strong> &#8211; dictionary containing pixel1, pixel2 and splineFile</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.setPyFAI">
<tt class="descname">setPyFAI</tt><big>(</big><em>**kwarg</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.setPyFAI" title="Permalink to this definition">¶</a></dt>
<dd><p>Twin method of getPyFAI: setup a detector instance according to a description</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kwarg</strong> &#8211; dictionary containing detector, pixel1, pixel2 and splineFile</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_binning">
<tt class="descname">set_binning</tt><big>(</big><em>bin_size=(1</em>, <em>1)</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the &#8220;binning&#8221; of the detector,</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bin_size</strong> (<em>(int, int)</em>) &#8211; binning as integer or tuple of integers.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_mask">
<tt class="descname">set_mask</tt><big>(</big><em>mask</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_maskfile">
<tt class="descname">set_maskfile</tt><big>(</big><em>maskfile</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_pixel1">
<tt class="descname">set_pixel1</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_pixel1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_pixel2">
<tt class="descname">set_pixel2</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_pixel2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_splineFile">
<tt class="descname">set_splineFile</tt><big>(</big><em>splineFile</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.splineFile">
<tt class="descname">splineFile</tt><a class="headerlink" href="#pyFAI.detectors.Detector.splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Dexela2923">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Dexela2923</tt><big>(</big><em>pixel1=7.4999999999999993e-05</em>, <em>pixel2=7.4999999999999993e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Dexela2923" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Dexela CMOS family detector</p>
</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.FReLoN">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">FReLoN</tt><big>(</big><em>splineFile=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.FReLoN" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>FReLoN detector:
The spline is mandatory to correct for geometric distortion of the taper</p>
<p>TODO: create automatically a mask that removes pixels out of the &#8220;valid reagion&#8221;</p>
<dl class="method">
<dt id="pyFAI.detectors.FReLoN.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.FReLoN.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a generic mask for Frelon detectors...
All pixels which (center) turns to be out of the valid region are by default discarded</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Fairchild">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Fairchild</tt><big>(</big><em>pixel1=1.5e-05</em>, <em>pixel2=1.5e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Fairchild" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Fairchild Condor 486:90 detector</p>
</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Perkin">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Perkin</tt><big>(</big><em>pixel=0.00020000000000000001</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Perkin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Perkin detector</p>
</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus</tt><big>(</big><em>pixel1=0.00017200000000000001</em>, <em>pixel2=0.00017200000000000001</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Pilatus detector: generic description containing mask algorithm</p>
<p>Sub-classed by Pilatus1M, Pilatus2M and Pilatus6M</p>
<dl class="method">
<dt id="pyFAI.detectors.Pilatus.calc_cartesian_positions">
<tt class="descname">calc_cartesian_positions</tt><big>(</big><em>d1=None</em>, <em>d2=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus.calc_cartesian_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of each pixel center in cartesian coordinate
and in meter of a couple of coordinates.
The half pixel offset is taken into account here !!!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the Y pixel positions (slow dimension)</li>
<li><strong>d2</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the X pixel positions (fast dimension)</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">position in meter of the center of each pixels.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
<p>d1 and d2 must have the same shape, returned array will have
the same shape.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Pilatus.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a generic mask for Pilatus detectors...</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Pilatus.get_splineFile">
<tt class="descname">get_splineFile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus.get_splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Pilatus.set_splineFile">
<tt class="descname">set_splineFile</tt><big>(</big><em>splineFile=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus.set_splineFile" title="Permalink to this definition">¶</a></dt>
<dd><p>In this case splinefile is a couple filenames</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus.splineFile">
<tt class="descname">splineFile</tt><a class="headerlink" href="#pyFAI.detectors.Pilatus.splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus1M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus1M</tt><big>(</big><em>pixel1=0.00017200000000000001</em>, <em>pixel2=0.00017200000000000001</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus1M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus 1M detector</p>
</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus2M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus2M</tt><big>(</big><em>pixel1=0.00017200000000000001</em>, <em>pixel2=0.00017200000000000001</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus2M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus 2M detector</p>
</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus6M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus6M</tt><big>(</big><em>pixel1=0.00017200000000000001</em>, <em>pixel2=0.00017200000000000001</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus6M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus 6M detector</p>
</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Xpad_flat">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Xpad_flat</tt><big>(</big><em>pixel1=0.00012999999999999999</em>, <em>pixel2=0.00012999999999999999</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Xpad_flat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Xpad detector: generic description for
ImXPad detector with 8x7modules</p>
<dl class="method">
<dt id="pyFAI.detectors.Xpad_flat.calc_cartesian_positions">
<tt class="descname">calc_cartesian_positions</tt><big>(</big><em>d1=None</em>, <em>d2=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.calc_cartesian_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of each pixel center in cartesian coordinate
and in meter of a couple of coordinates.
The half pixel offset is taken into account here !!!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the Y pixel positions (slow dimension)</li>
<li><strong>d2</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the X pixel positions (fast dimension)</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">position in meter of the center of each pixels.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
<p>d1 and d2 must have the same shape, returned array will have
the same shape.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Xpad_flat.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a generic mask for Xpad detectors...
discards the first line and raw form all modules:
those are 2.5x bigger and often mis - behaving</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.detectors.detector_factory">
<tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">detector_factory</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.detector_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A kind of factory...
:param name: name of a detector
:type name: str</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">an instance of the right detector</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body">pyFAI.detectors.Detector</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pyFAI.geometry">
<span id="geometry-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">geometry</span></tt> Module<a class="headerlink" href="#module-pyFAI.geometry" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyFAI.geometry.Geometry">
<em class="property">class </em><tt class="descclassname">pyFAI.geometry.</tt><tt class="descname">Geometry</tt><big>(</big><em>dist=1</em>, <em>poni1=0</em>, <em>poni2=0</em>, <em>rot1=0</em>, <em>rot2=0</em>, <em>rot3=0</em>, <em>pixel1=None</em>, <em>pixel2=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class is an azimuthal integrator based on P. Boesecke&#8217;s geometry and
histogram algorithm by Manolo S. del Rio and V.A Sole</p>
<p>Detector is assumed to be corrected from &#8220;raster orientation&#8221; effect.
It is not addressed here but rather in the Detector object or at read time.
Considering there is no tilt:</p>
<ul class="simple">
<li>Detector fast dimension (dim2) is supposed to be horizontal
(dimension X of the image)</li>
<li>Detector slow dimension (dim1) is supposed to be vertical, upwards
(dimension Y of the image)</li>
<li>The third dimension is chose such as the referential is
orthonormal, so dim3 is along incoming X-ray beam</li>
</ul>
<p>Axis 1 is along first dimension of detector (when not tilted),
this is the slow dimension of the image array in C or Y
x1={1,0,0}</p>
<p>Axis 2 is along second dimension of detector (when not tilted),
this is the fast dimension of the image in C or X
x2={0,1,0}</p>
<p>Axis 3 is along the incident X-Ray beam
x3={0,0,1}</p>
<p>We define the 3 rotation around axis 1, 2 and 3:</p>
<p>rotM1 = RotationMatrix[rot1,x1] =  {{1,0,0},{0,cos[rot1],-sin[rot1]},{0,sin[rot1],cos[rot1]}}
rotM2 =  RotationMatrix[rot2,x2] = {{cos[rot2],0,sin[rot2]},{0,1,0},{-sin[rot2],0,cos[rot2]}}
rotM3 =  RotationMatrix[rot3,x3] = {{cos[rot3],-sin[rot3],0},{sin[rot3],cos[rot3],0},{0,0,1}}</p>
<p>Rotations of the detector are applied first Rot around axis 1,
then axis 2 and finally around axis 3:</p>
<p>R = rotM3.rotM2.rotM1</p>
<dl class="docutils">
<dt>R = {{cos[rot2] cos[rot3],cos[rot3] sin[rot1] sin[rot2]-cos[rot1] sin[rot3],cos[rot1] cos[rot3] sin[rot2]+sin[rot1] sin[rot3]},</dt>
<dd>{cos[rot2] sin[rot3],cos[rot1] cos[rot3]+sin[rot1] sin[rot2] sin[rot3],-cos[rot3] sin[rot1]+cos[rot1] sin[rot2] sin[rot3]},
{-sin[rot2],cos[rot2] sin[rot1],cos[rot1] cos[rot2]}}</dd>
</dl>
<p>In Python notation:</p>
<p>R.x1 = [cos(rot2)*cos(rot3),cos(rot2)*sin(rot3),-sin(rot2)]</p>
<p>R.x2 = [cos(rot3)*sin(rot1)*sin(rot2) - cos(rot1)*sin(rot3),cos(rot1)*cos(rot3) + sin(rot1)*sin(rot2)*sin(rot3), cos(rot2)*sin(rot1)]</p>
<p>R.x3 = [cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3),-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3), cos(rot1)*cos(rot2)]</p>
<ul>
<li><p class="first">Coordinates of the Point of Normal Incidence:</p>
<p>PONI = R.{0,0,L}</p>
<dl class="docutils">
<dt>PONI = [L*(cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3)),</dt>
<dd><p class="first last">L*(-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3)),L*cos(rot1)*cos(rot2)]</p>
</dd>
</dl>
</li>
<li><p class="first">Any pixel on detector plan at coordinate (d1, d2) in
meters. Detector is at z=L</p>
<p>P={d1,d2,L}</p>
<p>R.P = [t1, t2, t3]
t1 = R.P.x1 = d1*cos(rot2)*cos(rot3) + d2*(cos(rot3)*sin(rot1)*sin(rot2) - cos(rot1)*sin(rot3)) + L*(cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3))
t2 = R.P.x2 = d1*cos(rot2)*sin(rot3)  + d2*(cos(rot1)*cos(rot3) + sin(rot1)*sin(rot2)*sin(rot3)) + L*(-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3))
t3 = R.P.x3 = d2*cos(rot2)*sin(rot1) - d1*sin(rot2) + L*cos(rot1)*cos(rot2)</p>
</li>
<li><p class="first">Distance sample (origin) to detector point (d1,d2)</p>
<dl class="docutils">
<dt><a href="#id6"><span class="problematic" id="id7">|R.P|</span></a> = sqrt(pow(Abs(L*cos(rot1)*cos(rot2) + d2*cos(rot2)*sin(rot1) - d1*sin(rot2)),2) +</dt>
<dd><p class="first last">pow(Abs(d1*cos(rot2)*cos(rot3) + d2*(cos(rot3)*sin(rot1)*sin(rot2) - cos(rot1)*sin(rot3)) +
L*(cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3))),2) +
pow(Abs(d1*cos(rot2)*sin(rot3) + L*(-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3)) +
d2*(cos(rot1)*cos(rot3) + sin(rot1)*sin(rot2)*sin(rot3))),2))</p>
</dd>
</dl>
</li>
<li><p class="first">cos(2theta) is defined as (R.P component along x3) over the distance from origin to data point <a href="#id8"><span class="problematic" id="id9">|R.P|</span></a></p>
</li>
</ul>
<p>tth = ArcCos [-(R.P).x3/<a href="#id10"><span class="problematic" id="id11">|R.P|</span></a>]</p>
<dl class="docutils">
<dt>tth = Arccos((-(L*cos(rot1)*cos(rot2)) - d2*cos(rot2)*sin(rot1) + d1*sin(rot2))/</dt>
<dd><dl class="first last docutils">
<dt>sqrt(pow(Abs(L*cos(rot1)*cos(rot2) + d2*cos(rot2)*sin(rot1) - d1*sin(rot2)),2) +</dt>
<dd><blockquote class="first">
<div>pow(Abs(d1*cos(rot2)*cos(rot3) + d2*(cos(rot3)*sin(rot1)*sin(rot2) - cos(rot1)*sin(rot3)) +</div></blockquote>
<dl class="docutils">
<dt>L*(cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3))),2) +</dt>
<dd>pow(Abs(d1*cos(rot2)*sin(rot3) + L*(-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3)) +</dd>
</dl>
<p class="last">d2*(cos(rot1)*cos(rot3) + sin(rot1)*sin(rot2)*sin(rot3))),2)))</p>
</dd>
</dl>
</dd>
</dl>
<ul class="simple">
<li>tan(2theta) is defined as sqrt(t1**2 + t2**2) / t3</li>
</ul>
<p>tth = ArcTan2 [sqrt(t1**2 + t2**2) , t3 ]</p>
<p>Getting 2theta from it&#8217;s tangeant seems both more precise (around
beam stop very far from sample) and faster by about 25% Currently
there is a swich in the method to follow one path or the other.</p>
<ul class="simple">
<li>Tangeant of angle chi is defined as (R.P component along x1)
over (R.P component along x2). Arctan2 should be used in actual
calculation</li>
</ul>
<blockquote>
<div><p>chi = ArcTan[((R.P).x1) / ((R.P).x2)]</p>
<dl class="docutils">
<dt>chi = ArcTan2(d1*cos(rot2)*cos(rot3) + d2*(cos(rot3)*sin(rot1)*sin(rot2) - cos(rot1)*sin(rot3)) +</dt>
<dd><blockquote class="first">
<div>L*(cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3)),</div></blockquote>
<dl class="last docutils">
<dt>d1*cos(rot2)*sin(rot3) + L*(-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3)) +</dt>
<dd>d2*(cos(rot1)*cos(rot3) + sin(rot1)*sin(rot2)*sin(rot3)))</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl class="method">
<dt id="pyFAI.geometry.Geometry.calcfrom1d">
<tt class="descname">calcfrom1d</tt><big>(</big><em>tth</em>, <em>I</em>, <em>shape=None</em>, <em>mask=None</em>, <em>dim1_unit=2th_deg</em>, <em>correctSolidAngle=True</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.calcfrom1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a 2D image from a 1D integrated profile</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tth</strong> &#8211; 1D array with 2theta in degrees</li>
<li><strong>I</strong> &#8211; scattering intensity</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2D image reconstructed</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.chi">
<tt class="descname">chi</tt><big>(</big><em>d1</em>, <em>d2</em>, <em>path='cython'</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.chi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the chi (azimuthal angle) for the centre of a pixel
at coordinate d1,d2 which in the lab ref has coordinate:</p>
<p>X1 = p1*cos(rot2)*cos(rot3) + p2*(cos(rot3)*sin(rot1)*sin(rot2) - cos(rot1)*sin(rot3)) -  L*(cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3))
X2 = p1*cos(rot2)*sin(rot3) - L*(-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3)) +  p2*(cos(rot1)*cos(rot3) + sin(rot1)*sin(rot2)*sin(rot3))
X3 = -(L*cos(rot1)*cos(rot2)) + p2*cos(rot2)*sin(rot1) - p1*sin(rot2)
hence tan(Chi) =  X2 / X1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>float or array of them</em>) &#8211; pixel coordinate along the 1st dimention (C convention)</li>
<li><strong>d2</strong> (<em>float or array of them</em>) &#8211; pixel coordinate along the 2nd dimention (C convention)</li>
<li><strong>path</strong> &#8211; can be &#8220;tan&#8221; (i.e via numpy) or &#8220;cython&#8221;</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">chi, the azimuthal angle in rad</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.chiArray">
<tt class="descname">chiArray</tt><big>(</big><em>shape</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.chiArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array of the given shape with chi(i,j) (azimuthal
angle) for all elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> (<em>ndarray.shape</em>) &#8211; the shape of the chi array</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the chi array</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body">ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.chi_corner">
<tt class="descname">chi_corner</tt><big>(</big><em>d1</em>, <em>d2</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.chi_corner" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the chi (azimuthal angle) for the corner of a pixel
at coordinate d1,d2 which in the lab ref has coordinate:</p>
<p>X1 = p1*cos(rot2)*cos(rot3) + p2*(cos(rot3)*sin(rot1)*sin(rot2) - cos(rot1)*sin(rot3)) -  L*(cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3))
X2 = p1*cos(rot2)*sin(rot3) - L*(-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3)) +  p2*(cos(rot1)*cos(rot3) + sin(rot1)*sin(rot2)*sin(rot3))
X3 = -(L*cos(rot1)*cos(rot2)) + p2*cos(rot2)*sin(rot1) - p1*sin(rot2)
hence tan(Chi) =  X2 / X1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>float or array of them</em>) &#8211; pixel coordinate along the 1st dimention (C convention)</li>
<li><strong>d2</strong> (<em>float or array of them</em>) &#8211; pixel coordinate along the 2nd dimention (C convention)</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">chi, the azimuthal angle in rad</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.chia">
<tt class="descname">chia</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.chia" title="Permalink to this definition">¶</a></dt>
<dd><p>chi array in cache</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.cornerArray">
<tt class="descname">cornerArray</tt><big>(</big><em>shape</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.cornerArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 3D array of the given shape with (i,j) (radial
angle 2th, azimuthal angle chi ) for all elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> (<em>ndarray.shape</em>) &#8211; expected shape</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">3d array with shape=(<a href="#id2"><span class="problematic" id="id3">*</span></a>shape,2) the two elements are (radial angle 2th, azimuthal angle chi)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.cornerQArray">
<tt class="descname">cornerQArray</tt><big>(</big><em>shape</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.cornerQArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 3D array of the given shape with (i,j) (azimuthal
angle) for all elements.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.cornerRArray">
<tt class="descname">cornerRArray</tt><big>(</big><em>shape</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.cornerRArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 3D array of the given shape with (i,j) (azimuthal
angle) for all elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.correct_SA_spline">
<tt class="descname">correct_SA_spline</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.correct_SA_spline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.del_chia">
<tt class="descname">del_chia</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.del_chia" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.del_dssa">
<tt class="descname">del_dssa</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.del_dssa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.del_qa">
<tt class="descname">del_qa</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.del_qa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.del_ttha">
<tt class="descname">del_ttha</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.del_ttha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.delta2Theta">
<tt class="descname">delta2Theta</tt><big>(</big><em>shape</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.delta2Theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 3D array of the given shape with (i,j) with the max
distance between the center and any corner in 2 theta</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; The shape of the detector array: 2-tuple of integer</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">2D-array containing the max delta angle between a pixel center and any corner in 2theta-angle (rad)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.deltaChi">
<tt class="descname">deltaChi</tt><big>(</big><em>shape</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.deltaChi" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 3D array of the given shape with (i,j) with the max
distance between the center and any corner in chi-angle (rad)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; The shape of the detector array: 2-tuple of integer</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">2D-array  containing the max delta angle between a pixel center and any corner in chi-angle (rad)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.deltaQ">
<tt class="descname">deltaQ</tt><big>(</big><em>shape</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.deltaQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 2D array of the given shape with (i,j) with the max
distance between the center and any corner in q_vector unit
(nm^-1)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; The shape of the detector array: 2-tuple of integer</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">array 2D containing the max delta Q between a pixel center and any corner in q_vector unit (nm^-1)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.deltaR">
<tt class="descname">deltaR</tt><big>(</big><em>shape</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.deltaR" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 2D array of the given shape with (i,j) with the max
distance between the center and any corner in radius unit (mm)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; The shape of the detector array: 2-tuple of integer</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">array 2D containing the max delta Q between a pixel center and any corner in q_vector unit (nm^-1)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.diffSolidAngle">
<tt class="descname">diffSolidAngle</tt><big>(</big><em>d1</em>, <em>d2</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.diffSolidAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Calulate the solid angle of the current pixels (P) versus the PONI (C)</p>
<blockquote>
<div>Omega(P)    A cos(a)     SC^2         3       SC^3</div></blockquote>
<dl class="docutils">
<dt>dOmega = &#8212;&#8212;&#8212; = &#8212;&#8212;&#8212; x &#8212;&#8212;&#8212; = cos (a) = &#8212;&#8212;</dt>
<dd>Omega(C)    SP^2        A cos(0)              SP^3</dd>
</dl>
<p>cos(a) = SC/SP</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> &#8211; 1d or 2d set of points</li>
<li><strong>d2</strong> &#8211; 1d or 2d set of points (same size&amp;shape as d1)</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">solid angle correction array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.dist">
<tt class="descname">dist</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.dist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.dssa">
<tt class="descname">dssa</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.dssa" title="Permalink to this definition">¶</a></dt>
<dd><p>solid angle array in cache</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.getFit2D">
<tt class="descname">getFit2D</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.getFit2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Export geometry setup with the geometry of Fit2D</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">dict with parameters compatible with fit2D geometry</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.getPyFAI">
<tt class="descname">getPyFAI</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.getPyFAI" title="Permalink to this definition">¶</a></dt>
<dd><p>Export geometry setup with the geometry of PyFAI</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">dict with the parameter-set of the PyFAI geometry</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_chia">
<tt class="descname">get_chia</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_chia" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_correct_solid_angle_for_spline">
<tt class="descname">get_correct_solid_angle_for_spline</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_correct_solid_angle_for_spline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_dist">
<tt class="descname">get_dist</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_dist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_dssa">
<tt class="descname">get_dssa</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_dssa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_pixel1">
<tt class="descname">get_pixel1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_pixel1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_pixel2">
<tt class="descname">get_pixel2</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_pixel2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_poni1">
<tt class="descname">get_poni1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_poni1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_poni2">
<tt class="descname">get_poni2</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_poni2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_qa">
<tt class="descname">get_qa</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_qa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_rot1">
<tt class="descname">get_rot1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_rot1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_rot2">
<tt class="descname">get_rot2</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_rot2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_rot3">
<tt class="descname">get_rot3</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_rot3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_spline">
<tt class="descname">get_spline</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_spline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_splineFile">
<tt class="descname">get_splineFile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_ttha">
<tt class="descname">get_ttha</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_ttha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_wavelength">
<tt class="descname">get_wavelength</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.load">
<tt class="descname">load</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the refined parameters from a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; name of the file to load</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.oversampleArray">
<tt class="descname">oversampleArray</tt><big>(</big><em>myarray</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.oversampleArray" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.pixel1">
<tt class="descname">pixel1</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.pixel1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.pixel2">
<tt class="descname">pixel2</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.pixel2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.polarization">
<tt class="descname">polarization</tt><big>(</big><em>shape=None</em>, <em>factor=None</em>, <em>axis_offset=0</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.polarization" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the polarization correction accoding to the
polarization factor:</p>
<ul class="simple">
<li>If the polarization factor is None, the correction is not applied (returns 1)</li>
<li>If the polarization factor is 0 (circular polarization), the correction correspond to (1+(cos2θ)^2)/2</li>
<li>If the polarization factor is 1 (linear horizontal polarization), there is no correction in the vertical plane  and a node at 2th=90, chi=0</li>
<li>If the polarization factor is -1 (linear vertical polarization), there is no correction in the horizontal plane and a node at 2th=90, chi=90</li>
<li>If the polarization is elliptical, the polarization factor varies between -1 and +1.</li>
</ul>
<p>The axis_offset parameter allows correction for the misalignement of the polarization plane (or ellipse main axis) and the the detector&#8217;s X axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>factor</strong> &#8211; (Ih-Iv)/(Ih+Iv): varies between 0 (no polarization) and 1 (where division by 0 could occure at 2th=90, chi=0)</li>
<li><strong>axis_offset</strong> &#8211; Angle between the polarization main axis and detector X direction (in radians !!!)</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2D array with polarization correction array (intensity/polarisation)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.poni1">
<tt class="descname">poni1</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.poni1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.poni2">
<tt class="descname">poni2</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.poni2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.qArray">
<tt class="descname">qArray</tt><big>(</big><em>shape</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.qArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array of the given shape with q(i,j) for all
elements.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.qCornerFunct">
<tt class="descname">qCornerFunct</tt><big>(</big><em>d1</em>, <em>d2</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.qCornerFunct" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the q_vector for any pixel corner (in nm^-1)</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.qFunction">
<tt class="descname">qFunction</tt><big>(</big><em>d1</em>, <em>d2</em>, <em>param=None</em>, <em>path='cython'</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.qFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the q value for the center of a given pixel (or set
of pixels) in nm-1</p>
<p>q = 4pi/lambda sin( 2theta / 2 )</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in first dimension (c order)</li>
<li><strong>d2</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in second dimension (c order)</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">q in in nm^(-1)</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float or array of floats.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.qa">
<tt class="descname">qa</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.qa" title="Permalink to this definition">¶</a></dt>
<dd><p>Q array in cache</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.rArray">
<tt class="descname">rArray</tt><big>(</big><em>shape</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.rArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array of the given shape with r(i,j) for all
elements; r in mm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; expected shape</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">2d array of the given shape with radius in mm from beam stop.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.rCornerFunct">
<tt class="descname">rCornerFunct</tt><big>(</big><em>d1</em>, <em>d2</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.rCornerFunct" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the radius array for any pixel corner (in mm)</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.rFunction">
<tt class="descname">rFunction</tt><big>(</big><em>d1</em>, <em>d2</em>, <em>param=None</em>, <em>path='numpy'</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.rFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the radius value for the center of a given pixel
(or set of pixels) in mm</p>
<p>r = direct_distance  * tan( 2theta )</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in first dimension (c order)</li>
<li><strong>d2</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in second dimension (c order)</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">r in in mm</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float or array of floats.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.read">
<tt class="descname">read</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the refined parameters from a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; name of the file to load</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset most arrays that are cached: used when a parameter
changes.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.rot1">
<tt class="descname">rot1</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.rot1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.rot2">
<tt class="descname">rot2</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.rot2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.rot3">
<tt class="descname">rot3</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.rot3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.save">
<tt class="descname">save</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the refined parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; name of the file where to save the parameters</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.setChiDiscAtPi">
<tt class="descname">setChiDiscAtPi</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.setChiDiscAtPi" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the position of the discontinuity of the chi axis between
-pi and +pi.  This is the default behavour</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.setChiDiscAtZero">
<tt class="descname">setChiDiscAtZero</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.setChiDiscAtZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the position of the discontinuity of the chi axis between
0 and 2pi.  By default it is between pi and -pi</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.setFit2D">
<tt class="descname">setFit2D</tt><big>(</big><em>directDist</em>, <em>centerX</em>, <em>centerY</em>, <em>tilt=0.0</em>, <em>tiltPlanRotation=0.0</em>, <em>pixelX=None</em>, <em>pixelY=None</em>, <em>splineFile=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.setFit2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the Fit2D-like parameter set: For geometry description see
HPR 1996 (14) pp-240</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>direct</strong> &#8211; direct distance from sample to detector along the incident beam (in millimeter as in fit2d)</li>
<li><strong>tilt</strong> &#8211; tilt in degrees</li>
<li><strong>tiltPlanRotation</strong> &#8211; Rotation (in degrees) of the tilt plan arround the Z-detector axis
* 0deg -&gt; Y does not move, +X goes to Z&lt;0
* 90deg -&gt; X does not move, +Y goes to Z&lt;0
* 180deg -&gt; Y does not move, +X goes to Z&gt;0
* 270deg -&gt; X does not move, +Y goes to Z&gt;0</li>
<li><strong>pixelX,pixelY</strong> &#8211; as in fit2d they ar given in micron, not in meter</li>
<li><strong>centerY</strong> (<em>centerX,</em>) &#8211; pixel position of the beam center</li>
<li><strong>splineFile</strong> &#8211; name of the file containing the spline</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.setOversampling">
<tt class="descname">setOversampling</tt><big>(</big><em>iOversampling</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.setOversampling" title="Permalink to this definition">¶</a></dt>
<dd><p>set the oversampling factor</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.setPyFAI">
<tt class="descname">setPyFAI</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.setPyFAI" title="Permalink to this definition">¶</a></dt>
<dd><p>set the geometry from a pyFAI-like dict</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_chia">
<tt class="descname">set_chia</tt><big>(</big><em>_</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_chia" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_correct_solid_angle_for_spline">
<tt class="descname">set_correct_solid_angle_for_spline</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_correct_solid_angle_for_spline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_dist">
<tt class="descname">set_dist</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_dist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_dssa">
<tt class="descname">set_dssa</tt><big>(</big><em>_</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_dssa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_pixel1">
<tt class="descname">set_pixel1</tt><big>(</big><em>pixel1</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_pixel1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_pixel2">
<tt class="descname">set_pixel2</tt><big>(</big><em>pixel2</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_pixel2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_poni1">
<tt class="descname">set_poni1</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_poni1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_poni2">
<tt class="descname">set_poni2</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_poni2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_qa">
<tt class="descname">set_qa</tt><big>(</big><em>_</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_qa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_rot1">
<tt class="descname">set_rot1</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_rot1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_rot2">
<tt class="descname">set_rot2</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_rot2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_rot3">
<tt class="descname">set_rot3</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_rot3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_spline">
<tt class="descname">set_spline</tt><big>(</big><em>spline</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_spline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_splineFile">
<tt class="descname">set_splineFile</tt><big>(</big><em>splineFile</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_ttha">
<tt class="descname">set_ttha</tt><big>(</big><em>_</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_ttha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_wavelength">
<tt class="descname">set_wavelength</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pyFAI.geometry.Geometry.sload">
<em class="property">classmethod </em><tt class="descname">sload</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.sload" title="Permalink to this definition">¶</a></dt>
<dd><p>A static method combining the constructor and the loader from
a file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; name of the file to load</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">instance of Gerometry of AzimuthalIntegrator set-up with the parameter from the file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.solidAngleArray">
<tt class="descname">solidAngleArray</tt><big>(</big><em>shape</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.solidAngleArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array of the given shape with the solid angle of
the current element two-theta(i,j) for all elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.spline">
<tt class="descname">spline</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.spline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.splineFile">
<tt class="descname">splineFile</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.tth">
<tt class="descname">tth</tt><big>(</big><em>d1</em>, <em>d2</em>, <em>param=None</em>, <em>path='cython'</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.tth" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the 2theta value for the center of a given pixel
(or set of pixels)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in first dimension (c order)</li>
<li><strong>d2</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in second dimension (c order)</li>
<li><strong>path</strong> &#8211; can be &#8220;cos&#8221;, &#8220;tan&#8221; or &#8220;cython&#8221;</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">2theta in radians</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">floar or array of floats.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.tth_corner">
<tt class="descname">tth_corner</tt><big>(</big><em>d1</em>, <em>d2</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.tth_corner" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the 2theta value for the corner of a given pixel
(or set of pixels)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in first dimension (c order)</li>
<li><strong>d2</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in second dimension (c order)</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">2theta in radians</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">floar or array of floats.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.ttha">
<tt class="descname">ttha</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.ttha" title="Permalink to this definition">¶</a></dt>
<dd><p>2theta array in cache</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.twoThetaArray">
<tt class="descname">twoThetaArray</tt><big>(</big><em>shape</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.twoThetaArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array of the given shape with two-theta(i,j) for
all elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.wavelength">
<tt class="descname">wavelength</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.write">
<tt class="descname">write</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the refined parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; name of the file where to save the parameters</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.geometryRefinement">
<span id="geometryrefinement-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">geometryRefinement</span></tt> Module<a class="headerlink" href="#module-pyFAI.geometryRefinement" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyFAI.geometryRefinement.GeometryRefinement">
<em class="property">class </em><tt class="descclassname">pyFAI.geometryRefinement.</tt><tt class="descname">GeometryRefinement</tt><big>(</big><em>data</em>, <em>dist=1</em>, <em>poni1=None</em>, <em>poni2=None</em>, <em>rot1=0</em>, <em>rot2=0</em>, <em>rot3=0</em>, <em>pixel1=None</em>, <em>pixel2=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>wavelength=None</em>, <em>dSpacing=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator" title="pyFAI.azimuthalIntegrator.AzimuthalIntegrator"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.azimuthalIntegrator.AzimuthalIntegrator</span></tt></a></p>
<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.anneal">
<tt class="descname">anneal</tt><big>(</big><em>maxiter=1000000</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.anneal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.calc_2th">
<tt class="descname">calc_2th</tt><big>(</big><em>rings</em>, <em>wavelength</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.calc_2th" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rings</strong> &#8211; indices of the rings. starts at 0 and self.dSpacing should be long enough !!!</li>
<li><strong>wavelength</strong> &#8211; wavelength in meter</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.chi2">
<tt class="descname">chi2</tt><big>(</big><em>param=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.chi2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.chi2_wavelength">
<tt class="descname">chi2_wavelength</tt><big>(</big><em>param=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.chi2_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.dist_max">
<tt class="descname">dist_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.dist_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.dist_min">
<tt class="descname">dist_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.dist_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_dist_max">
<tt class="descname">get_dist_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_dist_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_dist_min">
<tt class="descname">get_dist_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_dist_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_poni1_max">
<tt class="descname">get_poni1_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_poni1_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_poni1_min">
<tt class="descname">get_poni1_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_poni1_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_poni2_max">
<tt class="descname">get_poni2_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_poni2_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_poni2_min">
<tt class="descname">get_poni2_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_poni2_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_rot1_max">
<tt class="descname">get_rot1_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_rot1_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_rot1_min">
<tt class="descname">get_rot1_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_rot1_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_rot2_max">
<tt class="descname">get_rot2_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_rot2_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_rot2_min">
<tt class="descname">get_rot2_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_rot2_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_rot3_max">
<tt class="descname">get_rot3_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_rot3_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_rot3_min">
<tt class="descname">get_rot3_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_rot3_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_wavelength_max">
<tt class="descname">get_wavelength_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_wavelength_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_wavelength_min">
<tt class="descname">get_wavelength_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_wavelength_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.guess_poni">
<tt class="descname">guess_poni</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.guess_poni" title="Permalink to this definition">¶</a></dt>
<dd><p>Poni can be guessed by the centroid of the ring with lowest 2Theta</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.poni1_max">
<tt class="descname">poni1_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.poni1_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.poni1_min">
<tt class="descname">poni1_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.poni1_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.poni2_max">
<tt class="descname">poni2_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.poni2_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.poni2_min">
<tt class="descname">poni2_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.poni2_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.refine1">
<tt class="descname">refine1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.refine1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.refine2">
<tt class="descname">refine2</tt><big>(</big><em>maxiter=1000000, fix=['wavelength']</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.refine2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.refine2_wavelength">
<tt class="descname">refine2_wavelength</tt><big>(</big><em>maxiter=1000000, fix=['wavelength']</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.refine2_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.residu1">
<tt class="descname">residu1</tt><big>(</big><em>param</em>, <em>d1</em>, <em>d2</em>, <em>rings</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.residu1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.residu1_wavelength">
<tt class="descname">residu1_wavelength</tt><big>(</big><em>param</em>, <em>d1</em>, <em>d2</em>, <em>rings</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.residu1_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.residu2">
<tt class="descname">residu2</tt><big>(</big><em>param</em>, <em>d1</em>, <em>d2</em>, <em>rings</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.residu2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.residu2_wavelength">
<tt class="descname">residu2_wavelength</tt><big>(</big><em>param</em>, <em>d1</em>, <em>d2</em>, <em>rings</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.residu2_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.residu2_wavelength_weighted">
<tt class="descname">residu2_wavelength_weighted</tt><big>(</big><em>param</em>, <em>d1</em>, <em>d2</em>, <em>rings</em>, <em>weight</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.residu2_wavelength_weighted" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.residu2_weighted">
<tt class="descname">residu2_weighted</tt><big>(</big><em>param</em>, <em>d1</em>, <em>d2</em>, <em>rings</em>, <em>weight</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.residu2_weighted" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.roca">
<tt class="descname">roca</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.roca" title="Permalink to this definition">¶</a></dt>
<dd><p>run roca to optimise the parameter set</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.rot1_max">
<tt class="descname">rot1_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.rot1_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.rot1_min">
<tt class="descname">rot1_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.rot1_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.rot2_max">
<tt class="descname">rot2_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.rot2_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.rot2_min">
<tt class="descname">rot2_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.rot2_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.rot3_max">
<tt class="descname">rot3_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.rot3_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.rot3_min">
<tt class="descname">rot3_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.rot3_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_dist_max">
<tt class="descname">set_dist_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_dist_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_dist_min">
<tt class="descname">set_dist_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_dist_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_poni1_max">
<tt class="descname">set_poni1_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_poni1_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_poni1_min">
<tt class="descname">set_poni1_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_poni1_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_poni2_max">
<tt class="descname">set_poni2_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_poni2_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_poni2_min">
<tt class="descname">set_poni2_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_poni2_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_rot1_max">
<tt class="descname">set_rot1_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_rot1_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_rot1_min">
<tt class="descname">set_rot1_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_rot1_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_rot2_max">
<tt class="descname">set_rot2_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_rot2_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_rot2_min">
<tt class="descname">set_rot2_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_rot2_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_rot3_max">
<tt class="descname">set_rot3_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_rot3_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_rot3_min">
<tt class="descname">set_rot3_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_rot3_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_tolerance">
<tt class="descname">set_tolerance</tt><big>(</big><em>value=10</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_tolerance" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>value</strong> &#8211; Tolerance as a percentage</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_wavelength_max">
<tt class="descname">set_wavelength_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_wavelength_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_wavelength_min">
<tt class="descname">set_wavelength_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_wavelength_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.simplex">
<tt class="descname">simplex</tt><big>(</big><em>maxiter=1000000</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.simplex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.wavelength_max">
<tt class="descname">wavelength_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.wavelength_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.wavelength_min">
<tt class="descname">wavelength_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.wavelength_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.ocl_azim">
<span id="ocl-azim-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">ocl_azim</span></tt> Module<a class="headerlink" href="#module-pyFAI.ocl_azim" title="Permalink to this headline">¶</a></h2>
<p>C++ less implementation of Dimitris&#8217; code based on PyOpenCL</p>
<dl class="docutils">
<dt>TODO and trick from dimitris still missing:</dt>
<dd><ul class="first last simple">
<li>dark-current subtraction is still missing</li>
<li>In fact you might want to consider doing the conversion on the GPU when
possible. Think about it, you have a uint16 to float which for large arrays
was slow.. You load on the graphic card a uint16 (2x transfer speed) and
you convert to float inside so it should be blazing fast.</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="pyFAI.ocl_azim.Integrator1d">
<em class="property">class </em><tt class="descclassname">pyFAI.ocl_azim.</tt><tt class="descname">Integrator1d</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Attempt to implements ocl_azim using pyopencl</p>
<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.clean">
<tt class="descname">clean</tt><big>(</big><em>preserve_context=False</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>Free OpenCL related resources allocated by the library.</p>
<p>clean() is used to reinitiate the library back in a vanilla
state.  It may be asked to preserve the context created by
init or completely clean up OpenCL. Guard/Status flags that
are set will be reset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>preserve_context</strong> (<em>bool</em>) &#8211; preserves or destroys all OpenCL resources</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.configure">
<tt class="descname">configure</tt><big>(</big><em>kernel=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.configure" title="Permalink to this definition">¶</a></dt>
<dd><p>The method configure() allocates the OpenCL resources required
and compiled the OpenCL kernels.  An active context must exist
before a call to configure() and getConfiguration() must have
been called at least once. Since the compiled OpenCL kernels
carry some information on the integration parameters, a change
to any of the parameters of getConfiguration() requires a
subsequent call to configure() for them to take effect.</p>
<p>If a configuration exists and configure() is called, the
configuration is cleaned up first to avoid OpenCL memory leaks</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kernel_path</strong> &#8211; is the path to the actual kernel</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.execute">
<tt class="descname">execute</tt><big>(</big><em>image</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a 1D azimuthal integration</p>
<p>execute() may be called only after an OpenCL device is
configured and a Tth array has been loaded (at least once) It
takes the input image and based on the configuration provided
earlier it performs the 1D integration.  Notice that if the
provided image is bigger than N then only N points will be
taked into account, while if the image is smaller than N the
result may be catastrophic.  set/unset and loadTth methods
have a direct impact on the execute() method.  All the rest of
the methods will require at least a new configuration via
configure().</p>
<p>Takes an image, integrate and return the histogram and weights</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image</strong> &#8211; image to be processed as a numpy array</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">tth_out, histogram, bins</td>
</tr>
</tbody>
</table>
<p>TODO: to improve performances, the image should be casted to
float32 in an optimal way: currently using numpy machinery but
would be better if done in OpenCL</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.getConfiguration">
<tt class="descname">getConfiguration</tt><big>(</big><em>Nimage</em>, <em>Nbins</em>, <em>useFp64=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.getConfiguration" title="Permalink to this definition">¶</a></dt>
<dd><p>getConfiguration gets the description of the integrations
to be performed and keeps an internal copy</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>Nimage</strong> &#8211; number of pixel in image</li>
<li><strong>Nbins</strong> &#8211; number of bins in regrouped histogram</li>
<li><strong>useFp64</strong> &#8211; use double precision. By default the same as init!</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.get_status">
<tt class="descname">get_status</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.get_status" title="Permalink to this definition">¶</a></dt>
<dd><p>return a dictionnary with the status of the integrator: for
compatibilty with former implementation</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.init">
<tt class="descname">init</tt><big>(</big><em>devicetype='GPU'</em>, <em>useFp64=True</em>, <em>platformid=None</em>, <em>deviceid=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial configuration: Choose a device and initiate a
context.  Devicetypes can be GPU, gpu, CPU, cpu, DEF, ACC,
ALL. Suggested are GPU,CPU. For each setting to work there
must be such an OpenCL device and properly installed. E.g.: If
Nvidia driver is installed, GPU will succeed but CPU will
fail. The AMD SDK kit (AMD APP) is required for CPU via
OpenCL.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>devicetype</strong> &#8211; string in [&#8220;cpu&#8221;,&#8221;gpu&#8221;, &#8220;all&#8221;, &#8220;acc&#8221;]</li>
<li><strong>useFp64</strong> &#8211; boolean specifying if double precision will be used</li>
<li><strong>platformid</strong> &#8211; integer</li>
<li><strong>devid</strong> &#8211; integer</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.loadTth">
<tt class="descname">loadTth</tt><big>(</big><em>tth</em>, <em>dtth</em>, <em>tth_min=None</em>, <em>tth_max=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.loadTth" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the 2th arrays along with the min and max value.</p>
<p>loadTth maybe be recalled at any time of the execution in
order to update the 2th arrays.</p>
<p>loadTth is required and must be called at least once after a
configure()</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.log">
<tt class="descname">log</tt><big>(</big><em>**kwarg</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.log" title="Permalink to this definition">¶</a></dt>
<dd><p>log in a file all opencl events</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.setDummyValue">
<tt class="descname">setDummyValue</tt><big>(</big><em>dummy</em>, <em>delta_dummy</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.setDummyValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Enables dummy value functionality and uploads the value to the
OpenCL device.</p>
<p>Image values that are similar to the dummy value are set to 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dummy</strong> &#8211; value in image of missing values (masked pixels?)</li>
<li><strong>delta_dummy</strong> &#8211; precision for dummy values</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.setMask">
<tt class="descname">setMask</tt><big>(</big><em>mask</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.setMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Enables the use of a Mask during integration. The Mask can be
updated by recalling setMask at any point.</p>
<p>The Mask must be a PyFAI Mask. Pixels with 0 are masked
out. TODO: check and invert!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mask</strong> &#8211; numpy.ndarray of integer.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.setRange">
<tt class="descname">setRange</tt><big>(</big><em>lowerBound</em>, <em>upperBound</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.setRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Instructs the program to use a user - defined range for 2th
values</p>
<p>setRange is optional. By default the integration will use the
tth_min and tth_max given by loadTth() as integration
range. When setRange is called it sets a new integration range
without affecting the 2th array. All values outside that range
will then be discarded when interpolating.  Currently, if the
interval of 2th (2th + -d2th) is not all inside the range
specified, it is discarded. The bins of the histogram are
RESCALED to the defined range and not the original tth_max -
tth_min range.</p>
<p>setRange can be called at any point and as many times required
after a valid configuration is created.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lowerBound</strong> (<em>float</em>) &#8211; lower bound of the integration range</li>
<li><strong>upperBound</strong> (<em>float</em>) &#8211; upper bound of the integration range</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.setSolidAngle">
<tt class="descname">setSolidAngle</tt><big>(</big><em>solidAngle</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.setSolidAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Enables SolidAngle correction and uploads the suitable array
to the OpenCL device.</p>
<p>By default the program will assume no solidangle correction
unless setSolidAngle() is called.  From then on, all
integrations will be corrected via the SolidAngle array.</p>
<p>If the SolidAngle array needs to be changes, one may just call
setSolidAngle() again with that array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>solidAngle</strong> (<em>ndarray</em>) &#8211; the solid angle of the given pixel</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.unsetDummyValue">
<tt class="descname">unsetDummyValue</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.unsetDummyValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable a dummy value.
May be re-enabled at any time by setDummyValue</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.unsetMask">
<tt class="descname">unsetMask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.unsetMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Disables the use of a Mask from that point.
It may be re-enabled at any point via setMask</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.unsetRange">
<tt class="descname">unsetRange</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.unsetRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable the use of a user-defined 2th range and revert to
tth_min,tth_max range</p>
<p>unsetRange instructs the program to revert to its default
integration range. If the method is called when no
user-defined range had been previously specified, no action
will be performed</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.unsetSolidAngle">
<tt class="descname">unsetSolidAngle</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.unsetSolidAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Instructs the program to not perform solidangle correction from now on.</p>
<p>SolidAngle correction may be turned back on at any point</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.ocl_azim_lut">
<span id="ocl-azim-lut-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">ocl_azim_lut</span></tt> Module<a class="headerlink" href="#module-pyFAI.ocl_azim_lut" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyFAI.ocl_azim_lut.OCL_LUT_Integrator">
<em class="property">class </em><tt class="descclassname">pyFAI.ocl_azim_lut.</tt><tt class="descname">OCL_LUT_Integrator</tt><big>(</big><em>lut</em>, <em>image_size</em>, <em>devicetype='all'</em>, <em>platformid=None</em>, <em>deviceid=None</em>, <em>checksum=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_lut.OCL_LUT_Integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="pyFAI.ocl_azim_lut.OCL_LUT_Integrator.integrate">
<tt class="descname">integrate</tt><big>(</big><em>data</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>solidAngle=None</em>, <em>polarization=None</em>, <em>dark_checksum=None</em>, <em>flat_checksum=None</em>, <em>solidAngle_checksum=None</em>, <em>polarization_checksum=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_lut.OCL_LUT_Integrator.integrate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.opencl">
<span id="opencl-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">opencl</span></tt> Module<a class="headerlink" href="#module-pyFAI.opencl" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyFAI.opencl.Device">
<em class="property">class </em><tt class="descclassname">pyFAI.opencl.</tt><tt class="descname">Device</tt><big>(</big><em>name='None'</em>, <em>type=None</em>, <em>version=None</em>, <em>driver_version=None</em>, <em>extensions=''</em>, <em>memory=None</em>, <em>available=None</em>, <em>cores=None</em>, <em>frequency=None</em>, <em>flop_core=None</em>, <em>id=0</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.Device" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple class that contains the structure of an OpenCL device</p>
</dd></dl>

<dl class="class">
<dt id="pyFAI.opencl.OpenCL">
<em class="property">class </em><tt class="descclassname">pyFAI.opencl.</tt><tt class="descname">OpenCL</tt><a class="headerlink" href="#pyFAI.opencl.OpenCL" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple class that wraps the structure ocl_tools_extended.h</p>
<dl class="method">
<dt id="pyFAI.opencl.OpenCL.create_context">
<tt class="descname">create_context</tt><big>(</big><em>devicetype='ALL'</em>, <em>useFp64=False</em>, <em>platformid=None</em>, <em>deviceid=None</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.OpenCL.create_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose a device and initiate a context.</p>
<p>Devicetypes can be GPU,gpu,CPU,cpu,DEF,ACC,ALL.
Suggested are GPU,CPU.
For each setting to work there must be such an OpenCL device and properly installed.
E.g.: If Nvidia driver is installed, GPU will succeed but CPU will fail. The AMD SDK kit is required for CPU via OpenCL.
:param devicetype: string in [&#8220;cpu&#8221;,&#8221;gpu&#8221;, &#8220;all&#8221;, &#8220;acc&#8221;]
:param useFp64: boolean specifying if double precision will be used
:param platformid: integer
:param devid: integer
:return: OpenCL context on the selected device</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.opencl.OpenCL.get_platform">
<tt class="descname">get_platform</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.OpenCL.get_platform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a platform according</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>int or str</em>) &#8211; identifier for a platform, either an Id (int) or it&#8217;s name</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.opencl.OpenCL.select_device">
<tt class="descname">select_device</tt><big>(</big><em>type='ALL'</em>, <em>memory=None</em>, <em>extensions=</em><span class="optional">[</span><span class="optional">]</span>, <em>best=True</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.OpenCL.select_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Select a device based on few parameters (at the end, keep the one with most memory)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>type</strong> &#8211; &#8220;gpu&#8221; or &#8220;cpu&#8221; or &#8220;all&#8221; ....</li>
<li><strong>memory</strong> &#8211; minimum amount of memory (int)</li>
<li><strong>extensions</strong> &#8211; list of extensions to be present</li>
<li><strong>best</strong> &#8211; shall we look for the</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.opencl.Platform">
<em class="property">class </em><tt class="descclassname">pyFAI.opencl.</tt><tt class="descname">Platform</tt><big>(</big><em>name='None'</em>, <em>vendor='None'</em>, <em>version=None</em>, <em>extensions=None</em>, <em>id=0</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.Platform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple class that contains the structure of an OpenCL platform</p>
<dl class="method">
<dt id="pyFAI.opencl.Platform.add_device">
<tt class="descname">add_device</tt><big>(</big><em>device</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.Platform.add_device" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.opencl.Platform.get_device">
<tt class="descname">get_device</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.Platform.get_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a device according to key</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>int or str</em>) &#8211; identifier for a device, either it&#8217;s id (int) or it&#8217;s name</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.peakPicker">
<span id="peakpicker-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">peakPicker</span></tt> Module<a class="headerlink" href="#module-pyFAI.peakPicker" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyFAI.peakPicker.ControlPoints">
<em class="property">class </em><tt class="descclassname">pyFAI.peakPicker.</tt><tt class="descname">ControlPoints</tt><big>(</big><em>filename=None</em>, <em>dSpacing=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class contains a set of control points with (optionally) their ring number hence d-spacing and diffraction  2Theta angle ...</p>
<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.append">
<tt class="descname">append</tt><big>(</big><em>points</em>, <em>angle=None</em>, <em>ring=None</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.append" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>point</strong> &#8211; list of points</li>
<li><strong>angle</strong> &#8211; 2-theta angle in radians</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.append_2theta_deg">
<tt class="descname">append_2theta_deg</tt><big>(</big><em>points</em>, <em>angle=None</em>, <em>ring=None</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.append_2theta_deg" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>point</strong> &#8211; list of points</li>
<li><strong>angle</strong> &#8211; 2-theta angle in degrees</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.check">
<tt class="descname">check</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.check" title="Permalink to this definition">¶</a></dt>
<dd><p>check internal consistency of the class</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.getList">
<tt class="descname">getList</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.getList" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the list of control points suitable for geometry refinement with ring number</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.getList2theta">
<tt class="descname">getList2theta</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.getList2theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the list of control points suitable for geometry refinement</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.getListRing">
<tt class="descname">getListRing</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.getListRing" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the list of control points suitable for geometry refinement with ring number</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.getWavelength">
<tt class="descname">getWavelength</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.getWavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.getWeightedList">
<tt class="descname">getWeightedList</tt><big>(</big><em>image</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.getWeightedList" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the list of control points suitable for geometry refinement with ring number and intensities
:param image:
:return: a (x,4) array with pos0, pos1, ring nr and intensity</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.load">
<tt class="descname">load</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.load" title="Permalink to this definition">¶</a></dt>
<dd><p>load all control points from a file</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.load_dSpacing">
<tt class="descname">load_dSpacing</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.load_dSpacing" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a d-spacing file containing the inter-reticular plan distance in Angstrom</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.pop">
<tt class="descname">pop</tt><big>(</big><em>idx=None</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the set of points at given index (by default the last)
:param idx: position of the point to remove</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.readAngleFromKeyboard">
<tt class="descname">readAngleFromKeyboard</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.readAngleFromKeyboard" title="Permalink to this definition">¶</a></dt>
<dd><p>Ask the 2theta values for the given points</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.readRingNrFromKeyboard">
<tt class="descname">readRingNrFromKeyboard</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.readRingNrFromKeyboard" title="Permalink to this definition">¶</a></dt>
<dd><p>Ask the ring number values for the given points</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all stored values and resets them to default</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.save">
<tt class="descname">save</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a set of control points to a file
:param filename: name of the file
:return: None</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.save_dSpacing">
<tt class="descname">save_dSpacing</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.save_dSpacing" title="Permalink to this definition">¶</a></dt>
<dd><p>save the d-spacing to a file</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.setWavelength">
<tt class="descname">setWavelength</tt><big>(</big><em>value=None</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.setWavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.setWavelength_change2th">
<tt class="descname">setWavelength_change2th</tt><big>(</big><em>value=None</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.setWavelength_change2th" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.ControlPoints.setWavelength_changeDs">
<tt class="descname">setWavelength_changeDs</tt><big>(</big><em>value=None</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.setWavelength_changeDs" title="Permalink to this definition">¶</a></dt>
<dd><p>This is probably not a good idea, but who knows !</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.peakPicker.ControlPoints.wavelength">
<tt class="descname">wavelength</tt><a class="headerlink" href="#pyFAI.peakPicker.ControlPoints.wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.peakPicker.Event">
<em class="property">class </em><tt class="descclassname">pyFAI.peakPicker.</tt><tt class="descname">Event</tt><big>(</big><em>width</em>, <em>height</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.Event" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Dummy class for dumm things</p>
</dd></dl>

<dl class="class">
<dt id="pyFAI.peakPicker.Massif">
<em class="property">class </em><tt class="descclassname">pyFAI.peakPicker.</tt><tt class="descname">Massif</tt><big>(</big><em>data=None</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.Massif" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A massif is defined as an area around a peak, it is used to find neighbouring peaks</p>
<dl class="method">
<dt id="pyFAI.peakPicker.Massif.calculate_massif">
<tt class="descname">calculate_massif</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.Massif.calculate_massif" title="Permalink to this definition">¶</a></dt>
<dd><p>defines a map of the massif around x and returns the mask</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.Massif.delValleySize">
<tt class="descname">delValleySize</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.Massif.delValleySize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.Massif.find_peaks">
<tt class="descname">find_peaks</tt><big>(</big><em>x</em>, <em>nmax=200</em>, <em>annotate=None</em>, <em>massif_contour=None</em>, <em>stdout=&lt;open file '&lt;stdout&gt;'</em>, <em>mode 'w' at 0x7f860f641150&gt;</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.Massif.find_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>All in one function that finds a maximum from the given seed (x)
then calculates the region extension and extract position of the neighboring peaks.
:param x: seed for the calculation, input coordinates
:param nmax: maximum number of peak per region
:param annotate: call back method taking number of points + coordinate as input.
:param massif_contour: callback to show the contour of a massif with the given index.
:param stdout: this is the file where output is written by default.
:return: list of peaks</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.Massif.getBinnedData">
<tt class="descname">getBinnedData</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.Massif.getBinnedData" title="Permalink to this definition">¶</a></dt>
<dd><p>:return binned data</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.Massif.getBluredData">
<tt class="descname">getBluredData</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.Massif.getBluredData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.Massif.getLabeledMassif">
<tt class="descname">getLabeledMassif</tt><big>(</big><em>pattern=None</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.Massif.getLabeledMassif" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.Massif.getMedianData">
<tt class="descname">getMedianData</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.Massif.getMedianData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.Massif.getValleySize">
<tt class="descname">getValleySize</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.Massif.getValleySize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.Massif.initValleySize">
<tt class="descname">initValleySize</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.Massif.initValleySize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.Massif.nearest_peak">
<tt class="descname">nearest_peak</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.Massif.nearest_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>:returns the coordinates of the nearest peak</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.Massif.setValleySize">
<tt class="descname">setValleySize</tt><big>(</big><em>size</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.Massif.setValleySize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.peakPicker.Massif.valley_size">
<tt class="descname">valley_size</tt><a class="headerlink" href="#pyFAI.peakPicker.Massif.valley_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the minimum distance between two massifs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.peakPicker.PeakPicker">
<em class="property">class </em><tt class="descclassname">pyFAI.peakPicker.</tt><tt class="descname">PeakPicker</tt><big>(</big><em>strFilename</em>, <em>reconst=False</em>, <em>mask=None</em>, <em>pointfile=None</em>, <em>dSpacing=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.PeakPicker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="pyFAI.peakPicker.PeakPicker.closeGUI">
<tt class="descname">closeGUI</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.PeakPicker.closeGUI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.PeakPicker.contour">
<tt class="descname">contour</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.PeakPicker.contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Overlay a contour-plot</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> &#8211; 2darray with the 2theta values in radians...</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.PeakPicker.display_points">
<tt class="descname">display_points</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.PeakPicker.display_points" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.PeakPicker.finish">
<tt class="descname">finish</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.PeakPicker.finish" title="Permalink to this definition">¶</a></dt>
<dd><p>Ask the ring number for the given points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; file with the point coordinates saved</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.PeakPicker.gui">
<tt class="descname">gui</tt><big>(</big><em>log=False</em>, <em>maximize=False</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.PeakPicker.gui" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>log</strong> &#8211; show z in log scale</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.PeakPicker.load">
<tt class="descname">load</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.PeakPicker.load" title="Permalink to this definition">¶</a></dt>
<dd><p>load a filename and plot data on the screen (if GUI)</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.PeakPicker.massif_contour">
<tt class="descname">massif_contour</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.PeakPicker.massif_contour" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> &#8211; </td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.PeakPicker.onclick">
<tt class="descname">onclick</tt><big>(</big><em>event</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.PeakPicker.onclick" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peakPicker.PeakPicker.readFloatFromKeyboard">
<tt class="descname">readFloatFromKeyboard</tt><big>(</big><em>text</em>, <em>dictVar</em><big>)</big><a class="headerlink" href="#pyFAI.peakPicker.PeakPicker.readFloatFromKeyboard" title="Permalink to this definition">¶</a></dt>
<dd><p>Read float from the keyboard ....
:param text: string to be displayed
:param dictVar: dict of this type: {1: [set_dist_min],3: [set_dist_min, set_dist_guess, set_dist_max]}</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.refinment2D">
<span id="refinment2d-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">refinment2D</span></tt> Module<a class="headerlink" href="#module-pyFAI.refinment2D" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyFAI.refinment2D.Refinment2D">
<em class="property">class </em><tt class="descclassname">pyFAI.refinment2D.</tt><tt class="descname">Refinment2D</tt><big>(</big><em>img</em>, <em>ai=None</em><big>)</big><a class="headerlink" href="#pyFAI.refinment2D.Refinment2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>refine the parameters from image itself ...
(Jerome est-ce que tu peux elaborer un petit peu plus ???)</p>
<dl class="method">
<dt id="pyFAI.refinment2D.Refinment2D.diff_Fit2D">
<tt class="descname">diff_Fit2D</tt><big>(</big><em>axis='all'</em>, <em>dx=0.10000000000000001</em><big>)</big><a class="headerlink" href="#pyFAI.refinment2D.Refinment2D.diff_Fit2D" title="Permalink to this definition">¶</a></dt>
<dd><p>???</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>axis</strong> &#8211; <p>???</p>
</li>
<li><strong>dx</strong> &#8211; <p>???</p>
</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>???</p>
</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><p>???</p>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.refinment2D.Refinment2D.diff_tth_X">
<tt class="descname">diff_tth_X</tt><big>(</big><em>dx=0.10000000000000001</em><big>)</big><a class="headerlink" href="#pyFAI.refinment2D.Refinment2D.diff_tth_X" title="Permalink to this definition">¶</a></dt>
<dd><p>Jerome peux-tu décrire de quoi il retourne ???</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dx</strong> &#8211; <p>???</p>
</td>
</tr>
<tr class="field"><th class="field-name">Type :</th><td class="field-body">float ???</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">???</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body">???</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.refinment2D.Refinment2D.diff_tth_tilt">
<tt class="descname">diff_tth_tilt</tt><big>(</big><em>dx=0.10000000000000001</em><big>)</big><a class="headerlink" href="#pyFAI.refinment2D.Refinment2D.diff_tth_tilt" title="Permalink to this definition">¶</a></dt>
<dd><p>idem ici ???</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dx</strong> (<em>float ???</em>) &#8211; <p>???</p>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">???</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body">???</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.refinment2D.Refinment2D.get_shape">
<tt class="descname">get_shape</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.refinment2D.Refinment2D.get_shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.refinment2D.Refinment2D.reconstruct">
<tt class="descname">reconstruct</tt><big>(</big><em>tth</em>, <em>I</em><big>)</big><a class="headerlink" href="#pyFAI.refinment2D.Refinment2D.reconstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct a perfect image according to 2th / I given in
input</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tth</strong> (<em>ndarray</em>) &#8211; 2 theta array</li>
<li><strong>I</strong> (<em>ndarray</em>) &#8211; intensity array</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a reconstructed image</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.refinment2D.Refinment2D.scan_Fit2D">
<tt class="descname">scan_Fit2D</tt><big>(</big><em>width=1.0</em>, <em>points=10</em>, <em>axis='tilt'</em>, <em>dx=0.10000000000000001</em><big>)</big><a class="headerlink" href="#pyFAI.refinment2D.Refinment2D.scan_Fit2D" title="Permalink to this definition">¶</a></dt>
<dd><p>???</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>width</strong> (<em>float ???</em>) &#8211; <p>???</p>
</li>
<li><strong>points</strong> (<em>int ???</em>) &#8211; <p>???</p>
</li>
<li><strong>axis</strong> (<em>str ???</em>) &#8211; <p>???</p>
</li>
<li><strong>dx</strong> (<em>float ???</em>) &#8211; <p>???</p>
</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>???</p>
</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><p>???</p>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.refinment2D.Refinment2D.scan_centerX">
<tt class="descname">scan_centerX</tt><big>(</big><em>width=1.0</em>, <em>points=10</em><big>)</big><a class="headerlink" href="#pyFAI.refinment2D.Refinment2D.scan_centerX" title="Permalink to this definition">¶</a></dt>
<dd><p>???</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>width</strong> (<em>float ???</em>) &#8211; <p>???</p>
</li>
<li><strong>points</strong> (<em>int ???</em>) &#8211; <p>???</p>
</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>???</p>
</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><p>???</p>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.refinment2D.Refinment2D.scan_tilt">
<tt class="descname">scan_tilt</tt><big>(</big><em>width=1.0</em>, <em>points=10</em><big>)</big><a class="headerlink" href="#pyFAI.refinment2D.Refinment2D.scan_tilt" title="Permalink to this definition">¶</a></dt>
<dd><p>???</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>width</strong> (<em>float ???</em>) &#8211; <p>???</p>
</li>
<li><strong>points</strong> (<em>int ???</em>) &#8211; <p>???</p>
</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>???</p>
</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><p>???</p>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.refinment2D.Refinment2D.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#pyFAI.refinment2D.Refinment2D.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.spline">
<span id="spline-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">spline</span></tt> Module<a class="headerlink" href="#module-pyFAI.spline" title="Permalink to this headline">¶</a></h2>
<p>This is piece of software aims at manipulating spline files
describing for geometric corrections of the 2D detectors using cubic-spline.</p>
<p>Mainly used at ESRF with FReLoN CCD camera.</p>
<dl class="class">
<dt id="pyFAI.spline.Spline">
<em class="property">class </em><tt class="descclassname">pyFAI.spline.</tt><tt class="descname">Spline</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is a python representation of the spline file</p>
<p>Those file represent cubic splines for 2D detector distortions and
makes heavy use of fitpack (dierckx in netlib) &#8212; A Python-C
wrapper to FITPACK (by P. Dierckx). FITPACK is a collection of
FORTRAN programs for curve and surface fitting with splines and
tensor product splines.  See
_http://www.cs.kuleuven.ac.be/cwis/research/nalag/research/topics/fitpack.html
or _http://www.netlib.org/dierckx/index.html</p>
<dl class="method">
<dt id="pyFAI.spline.Spline.array2spline">
<tt class="descname">array2spline</tt><big>(</big><em>smoothing=1000</em>, <em>timing=False</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.array2spline" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the spline coefficients from the displacements
matrix using fitpack.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>smoothing</strong> (<em>float</em>) &#8211; the greater the smoothing, the fewer the number of knots remaining</li>
<li><strong>timing</strong> (<em>bool</em>) &#8211; print the profiling of the calculation</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.bin">
<tt class="descname">bin</tt><big>(</big><em>binning=None</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the binning of a spline (same camera with different binning)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>binning</strong> &#8211; binning factor as integer or 2-tuple of integers</td>
</tr>
<tr class="field"><th class="field-name">Type :</th><td class="field-body">int or (int, int)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.comparison">
<tt class="descname">comparison</tt><big>(</big><em>ref</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.comparison" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares the current spline distortion with a reference</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ref</strong> (<em>Spline instance</em>) &#8211; another spline file</li>
<li><strong>verbose</strong> (<em>bool</em>) &#8211; print or not pylab plots</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">True or False depending if the splines are the same or not</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.correct">
<tt class="descname">correct</tt><big>(</big><em>pos</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.correct" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.getPixelSize">
<tt class="descname">getPixelSize</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.getPixelSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of the pixel from as a 2-tuple of floats expressed
in meters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the size of the pixel from a 2D detector</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body">2-tuple of floats expressed in meter.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.read">
<tt class="descname">read</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.read" title="Permalink to this definition">¶</a></dt>
<dd><p>read an ascii spline file from file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>str</em>) &#8211; file containing the cubic spline distortion file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.setPixelSize">
<tt class="descname">setPixelSize</tt><big>(</big><em>pixelSize</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.setPixelSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the size of the pixel from a 2-tuple of floats expressed
in meters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Param :</th><td class="field-body">pixel size in meter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.spline2array">
<tt class="descname">spline2array</tt><big>(</big><em>timing=False</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.spline2array" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the displacement matrix using fitpack
bisplev(x, y, tck, dx = 0, dy = 0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>timing</strong> (<em>bool</em>) &#8211; profile the calculation or not</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Nothing !</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body">float or ndarray</td>
</tr>
</tbody>
</table>
<p>Evaluate a bivariate B-spline and its derivatives. Return a
rank-2 array of spline function values (or spline derivative
values) at points given by the cross-product of the rank-1
arrays x and y. In special cases, return an array or just a
float if either x or y or both are floats.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.splineFuncX">
<tt class="descname">splineFuncX</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.splineFuncX" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the displacement matrix using fitpack for the X
direction on the given grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>ndarray</em>) &#8211; points of the grid in the x direction</li>
<li><strong>y</strong> (<em>ndarray</em>) &#8211; points of the grid  in the y direction</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">displacement matrix for the X direction</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.splineFuncY">
<tt class="descname">splineFuncY</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.splineFuncY" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the displacement matrix using fitpack for the Y
direction</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>ndarray</em>) &#8211; points in the x direction</li>
<li><strong>y</strong> (<em>ndarray</em>) &#8211; points in the y direction</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">displacement matrix for the Y direction</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.tilt">
<tt class="descname">tilt</tt><big>(</big><em>center=(0.0</em>, <em>0.0)</em>, <em>tiltAngle=0.0</em>, <em>tiltPlanRot=0.0</em>, <em>distanceSampleDetector=1.0</em>, <em>timing=False</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.tilt" title="Permalink to this definition">¶</a></dt>
<dd><p>The tilt method apply a virtual tilt on the detector, the
point of tilt is given by the center</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>center</strong> (<em>2-tuple of floats</em>) &#8211; position of the point of tilt, this point will not be moved.</li>
<li><strong>tiltAngle</strong> (<em>float in the range [-90:+90] degrees</em>) &#8211; the value of the tilt in degrees</li>
<li><strong>tiltPlanRot</strong> (<em>Float in the range [-180:180]</em>) &#8211; the rotation of the tilt plan with the Ox axis (0 deg for y axis invariant, 90 deg for x axis invariant)</li>
<li><strong>distanceSampleDetector</strong> (<em>float</em>) &#8211; the distance from sample to detector in meter (along the beam, so distance from sample to center)</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">tilted Spline instance</p>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Spline</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.write">
<tt class="descname">write</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.write" title="Permalink to this definition">¶</a></dt>
<dd><p>save the cubic spline in an ascii file usable with Fit2D or
SPD</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>str</em>) &#8211; name of the file containing the cubic spline distortion file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.writeEDF">
<tt class="descname">writeEDF</tt><big>(</big><em>basename</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.writeEDF" title="Permalink to this definition">¶</a></dt>
<dd><p>save the distortion matrices into a couple of files called
basename-x.edf and basename-y.edf</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>basename</strong> (<em>str</em>) &#8211; base of the name used to save the data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.zeros">
<tt class="descname">zeros</tt><big>(</big><em>xmin=0.0</em>, <em>ymin=0.0</em>, <em>xmax=2048.0</em>, <em>ymax=2048.0</em>, <em>pixSize=None</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a spline file with no ( zero ) displacement.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>xmin</strong> (<em>float</em>) &#8211; minimum coordinate in x, usually zero</li>
<li><strong>xmax</strong> (<em>float</em>) &#8211; maximum coordinate in x (+1) usually 2048</li>
<li><strong>ymin</strong> (<em>float</em>) &#8211; minimum coordinate in y, usually zero</li>
<li><strong>ymax</strong> (<em>float</em>) &#8211; maximum coordinate y (+1) usually 2048</li>
<li><strong>pixSize</strong> (<em>float</em>) &#8211; size of the pixel</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.zeros_like">
<tt class="descname">zeros_like</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.zeros_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a spline file with no ( zero ) displacement with the
same shape as the other one given.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<em>Spline instance</em>) &#8211; another Spline instance</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.spline.main">
<tt class="descclassname">pyFAI.spline.</tt><tt class="descname">main</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.spline.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Some tests ....</p>
</dd></dl>

</div>
<div class="section" id="module-pyFAI.utils">
<span id="utils-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">utils</span></tt> Module<a class="headerlink" href="#module-pyFAI.utils" title="Permalink to this headline">¶</a></h2>
<p>Utilities, mainly for image treatment</p>
<dl class="function">
<dt id="pyFAI.utils.averageDark">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">averageDark</tt><big>(</big><em>lstimg</em>, <em>center_method='mean'</em>, <em>cutoff=None</em><big>)</big><a class="headerlink" href="#pyFAI.utils.averageDark" title="Permalink to this definition">¶</a></dt>
<dd><p>Averages a serie of dark (or flat) images.
Centers the result on the mean or the median ...
but averages all frames within  cutoff*std</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lstimg</strong> &#8211; list of 2D images or a 3D stack</li>
<li><strong>center_method</strong> &#8211; is the center calculated by a &#8220;mean&#8221; or a &#8220;median&#8221;</li>
<li><strong>cutoff</strong> &#8211; keep all data where (I-center)/std &lt; cutoff</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2D image averaged</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.averageImages">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">averageImages</tt><big>(</big><em>listImages</em>, <em>output=None</em>, <em>threshold=0.10000000000000001</em>, <em>minimum=None</em>, <em>maximum=None</em>, <em>darks=None</em>, <em>flats=None</em>, <em>filter_='mean'</em>, <em>correct_flat_from_dark=False</em><big>)</big><a class="headerlink" href="#pyFAI.utils.averageImages" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of filenames and create an average frame discarding all saturated pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>listImages</strong> &#8211; list of string representing the filenames</li>
<li><strong>output</strong> &#8211; name of the optional output file</li>
<li><strong>threshold</strong> &#8211; what is the upper limit? all pixel &gt; max*(1-threshold) are discareded.</li>
<li><strong>minimum</strong> &#8211; minimum valid value or True</li>
<li><strong>maximum</strong> &#8211; maximum valid value</li>
<li><strong>darks</strong> &#8211; list of dark current images for subtraction</li>
<li><strong>flats</strong> &#8211; list of flat field images for division</li>
<li><strong>filter</strong> &#8211; can be maximum, mean or median (default=mean)</li>
<li><strong>correct_flat_from_dark</strong> &#8211; shall the flat be re-corrected ?</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.binning">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">binning</tt><big>(</big><em>input_img</em>, <em>binsize</em><big>)</big><a class="headerlink" href="#pyFAI.utils.binning" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>input_img</strong> &#8211; input ndarray</li>
<li><strong>binsize</strong> &#8211; int or 2-tuple representing the size of the binning</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">binned input ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.boundingBox">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">boundingBox</tt><big>(</big><em>img</em><big>)</big><a class="headerlink" href="#pyFAI.utils.boundingBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to guess the bounding box around a valid massif</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>img</strong> &#8211; 2D array like</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">4-typle (d0_min, d1_min, d0_max, d1_max)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.center_of_mass">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">center_of_mass</tt><big>(</big><em>img</em><big>)</big><a class="headerlink" href="#pyFAI.utils.center_of_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the center of mass of of the array.
Like scipy.ndimage.measurements.center_of_mass
:param img: 2-D array
:return: 2-tuple of float with the center of mass</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.deprecated">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">deprecated</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#pyFAI.utils.deprecated" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyFAI.utils.dog">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">dog</tt><big>(</big><em>s1</em>, <em>s2</em>, <em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.utils.dog" title="Permalink to this definition">¶</a></dt>
<dd><p>2D difference of gaussian
typically 1 to 10 parameters</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.dog_filter">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">dog_filter</tt><big>(</big><em>input_img</em>, <em>sigma1</em>, <em>sigma2</em>, <em>mode='reflect'</em>, <em>cval=0.0</em><big>)</big><a class="headerlink" href="#pyFAI.utils.dog_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>2-dimensional Difference of Gaussian filter implemented with FFTw</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_img</strong> (<em>array-like</em>) &#8211; input_img array to filter</li>
<li><strong>sigma</strong> (<em>scalar or sequence of scalars</em>) &#8211; standard deviation for Gaussian kernel.
The standard deviations of the Gaussian filter are given for each axis as a sequence,
or as a single number, in which case it is equal for all axes.</li>
<li><strong>mode</strong> &#8211; {&#8216;reflect&#8217;,&#8217;constant&#8217;,&#8217;nearest&#8217;,&#8217;mirror&#8217;, &#8216;wrap&#8217;}, optional
The <tt class="docutils literal"><span class="pre">mode</span></tt> parameter determines how the array borders are
handled, where <tt class="docutils literal"><span class="pre">cval</span></tt> is the value when mode is equal to
&#8216;constant&#8217;. Default is &#8216;reflect&#8217;</li>
<li><strong>cval</strong> &#8211; scalar, optional
Value to fill past edges of input if <tt class="docutils literal"><span class="pre">mode</span></tt> is &#8216;constant&#8217;. Default is 0.0</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.expand">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">expand</tt><big>(</big><em>input_img</em>, <em>sigma</em>, <em>mode='constant'</em>, <em>cval=0.0</em><big>)</big><a class="headerlink" href="#pyFAI.utils.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand array a with its reflection on boundaries</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; 2D array</li>
<li><strong>sigma</strong> &#8211; float or 2-tuple of floats.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param mode:&#8221;constant&#8221;, &#8220;nearest&#8221;, &#8220;reflect&#8221; or mirror
:param cval: filling value used for constant, 0.0 by default</p>
<p>Nota: sigma is the half-width of the kernel. For gaussian convolution it is adviced that it is 4*sigma_of_gaussian</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.expand_args">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">expand_args</tt><big>(</big><em>args</em><big>)</big><a class="headerlink" href="#pyFAI.utils.expand_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes an argv and expand it (under Windows, cmd does not convert <a href="#id4"><span class="problematic" id="id5">*</span></a>.tif into a list of files.
Keeps only valid files (thanks to glob)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> &#8211; list of files or wilcards</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of actual args</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.float_">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">float_</tt><big>(</big><em>val</em><big>)</big><a class="headerlink" href="#pyFAI.utils.float_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert anything to a float ... or None if not applicable</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.gaussian">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">gaussian</tt><big>(</big><em>M</em>, <em>std</em><big>)</big><a class="headerlink" href="#pyFAI.utils.gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Gaussian window of length M with standard-deviation std.</p>
<p>This differs from the scipy.signal.gaussian implementation as:
- The default for sym=False (needed for gaussian filtering without shift)
- This implementation is normalized</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>M</strong> &#8211; length of the windows (int)</li>
<li><strong>std</strong> &#8211; standatd deviation sigma</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The FWHM is 2*numpy.sqrt(2 * numpy.pi)*std</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.gaussian_filter">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">gaussian_filter</tt><big>(</big><em>input_img</em>, <em>sigma</em>, <em>mode='reflect'</em>, <em>cval=0.0</em><big>)</big><a class="headerlink" href="#pyFAI.utils.gaussian_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>2-dimensional Gaussian filter implemented with FFTw</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_img</strong> (<em>array-like</em>) &#8211; input array to filter</li>
<li><strong>sigma</strong> (<em>scalar or sequence of scalars</em>) &#8211; standard deviation for Gaussian kernel.
The standard deviations of the Gaussian filter are given for each axis as a sequence,
or as a single number, in which case it is equal for all axes.</li>
<li><strong>mode</strong> &#8211; {&#8216;reflect&#8217;,&#8217;constant&#8217;,&#8217;nearest&#8217;,&#8217;mirror&#8217;, &#8216;wrap&#8217;}, optional
The <tt class="docutils literal"><span class="pre">mode</span></tt> parameter determines how the array borders are
handled, where <tt class="docutils literal"><span class="pre">cval</span></tt> is the value when mode is equal to
&#8216;constant&#8217;. Default is &#8216;reflect&#8217;</li>
<li><strong>cval</strong> &#8211; scalar, optional
Value to fill past edges of input if <tt class="docutils literal"><span class="pre">mode</span></tt> is &#8216;constant&#8217;. Default is 0.0</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.int_">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">int_</tt><big>(</big><em>val</em><big>)</big><a class="headerlink" href="#pyFAI.utils.int_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert anything to an int ... or None if not applicable</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.maximum_position">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">maximum_position</tt><big>(</big><em>img</em><big>)</big><a class="headerlink" href="#pyFAI.utils.maximum_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as scipy.ndimage.measurements.maximum_position:
Find the position of the maximum of the values of the array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>img</strong> &#8211; 2-D image</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">2-tuple of int with the position of the maximum</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.measure_offset">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">measure_offset</tt><big>(</big><em>img1</em>, <em>img2</em>, <em>method='numpy'</em>, <em>withLog=False</em>, <em>withCorr=False</em><big>)</big><a class="headerlink" href="#pyFAI.utils.measure_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Measure the actual offset between 2 images
:param img1: ndarray, first image
:param img2: ndarray, second image, same shape as img1
:param withLog: shall we return logs as well ? boolean
:return: tuple of floats with the offsets</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.relabel">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">relabel</tt><big>(</big><em>label</em>, <em>data</em>, <em>blured</em>, <em>max_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.utils.relabel" title="Permalink to this definition">¶</a></dt>
<dd><p>Relabel limits the number of region in the label array.
They are ranked relatively to their max(I0)-max(blur(I0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>label</strong> &#8211; a label array coming out of scipy.ndimage.measurement.label</li>
<li><strong>data</strong> &#8211; an array containing the raw data</li>
<li><strong>blured</strong> &#8211; an array containing the blured data</li>
<li><strong>max_size</strong> &#8211; the max number of label wanted</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return array like label</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.removeSaturatedPixel">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">removeSaturatedPixel</tt><big>(</big><em>ds</em>, <em>threshold=0.10000000000000001</em>, <em>minimum=None</em>, <em>maximum=None</em><big>)</big><a class="headerlink" href="#pyFAI.utils.removeSaturatedPixel" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ds</strong> &#8211; a dataset as  ndarray</li>
<li><strong>threshold</strong> &#8211; what is the upper limit? all pixel &gt; max*(1-threshold) are discareded.</li>
<li><strong>minimum</strong> &#8211; minumum valid value (or True for auto-guess)</li>
<li><strong>maximum</strong> &#8211; maximum valid value</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">another dataset</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.shift">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">shift</tt><big>(</big><em>input_img</em>, <em>shift_val</em><big>)</big><a class="headerlink" href="#pyFAI.utils.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift an array like  scipy.ndimage.interpolation.shift(input_img, shift_val, mode=&#8221;wrap&#8221;, order=0) but faster
:param input_img: 2d numpy array
:param shift_val: 2-tuple of integers
:return: shifted image</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.shiftFFT">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">shiftFFT</tt><big>(</big><em>input_img</em>, <em>shift_val</em>, <em>method='fftw'</em><big>)</big><a class="headerlink" href="#pyFAI.utils.shiftFFT" title="Permalink to this definition">¶</a></dt>
<dd><p>Do shift using FFTs
Shift an array like  scipy.ndimage.interpolation.shift(input, shift, mode=&#8221;wrap&#8221;, order=&#8221;infinity&#8221;) but faster
:param input_img: 2d numpy array
:param shift_val: 2-tuple of float
:return: shifted image</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.str_">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">str_</tt><big>(</big><em>val</em><big>)</big><a class="headerlink" href="#pyFAI.utils.str_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert anything to a string ... but None -&gt; &#8220;&#8221;</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.timeit">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">timeit</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#pyFAI.utils.timeit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyFAI.utils.unBinning">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">unBinning</tt><big>(</big><em>binnedArray</em>, <em>binsize</em>, <em>norm=True</em><big>)</big><a class="headerlink" href="#pyFAI.utils.unBinning" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>binnedArray</strong> &#8211; input ndarray</li>
<li><strong>binsize</strong> &#8211; 2-tuple representing the size of the binning</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">unBinned input ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pyFAI Package</a><ul>
<li><a class="reference internal" href="#id1"><tt class="docutils literal"><span class="pre">pyFAI</span></tt> Package</a></li>
<li><a class="reference internal" href="#module-pyFAI.azimuthalIntegrator"><tt class="docutils literal"><span class="pre">azimuthalIntegrator</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.detectors"><tt class="docutils literal"><span class="pre">detectors</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.geometry"><tt class="docutils literal"><span class="pre">geometry</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.geometryRefinement"><tt class="docutils literal"><span class="pre">geometryRefinement</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.ocl_azim"><tt class="docutils literal"><span class="pre">ocl_azim</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.ocl_azim_lut"><tt class="docutils literal"><span class="pre">ocl_azim_lut</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.opencl"><tt class="docutils literal"><span class="pre">opencl</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.peakPicker"><tt class="docutils literal"><span class="pre">peakPicker</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.refinment2D"><tt class="docutils literal"><span class="pre">refinment2D</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.spline"><tt class="docutils literal"><span class="pre">spline</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.utils"><tt class="docutils literal"><span class="pre">utils</span></tt> Module</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="modules.html"
                        title="previous chapter">pyFAI API</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../project.html"
                        title="next chapter">Project structure</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/api/pyFAI.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../project.html" title="Project structure"
             >next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="pyFAI API"
             >previous</a> |</li>
        <li><a href="../index.html">pyFAI v0.9.0 documentation</a> &raquo;</li>
          <li><a href="modules.html" >pyFAI API</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Jerome Kieffer.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.8.
    </div>
  </body>
</html>
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#    Project: Azimuthal integration
#             https://forge.epn-campus.eu/projects/azimuthal
#
#    File: "$Id$"
#
#    Copyright (C) European Synchrotron Radiation Facility, Grenoble, France
#
#    Principal author:       Jérôme Kieffer (Jerome.Kieffer@ESRF.eu)
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""
pyFAI-calib

A tool for determining the geometry of a detector using a reference sample.

usage:
  python2.6 pyFAI-calib [-g=100] [-nd] [-d] [-pix=172e-6,172e-6] inputFile.edf

"""

__author__ = "Jerome Kieffer"
__contact__ = "Jerome.Kieffer@ESRF.eu"
__license__ = "GPLv3+"
__copyright__ = "European Synchrotron Radiation Facility, Grenoble, France"
__date__ = "20/07/2012"
__satus__ = "development"

import os, sys, gc, threading, time, logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("pyFAI.calib")
import numpy
from numpy import sin, cos, arccos, sqrt, floor, ceil, radians, degrees, pi
import fabio
import matplotlib
import pylab
from scipy.optimize import fmin, leastsq, fmin_slsqp, anneal
from scipy.interpolate import interp2d
import pyFAI
from pyFAI.detectors import detector_factory, Detector
from pyFAI.geometryRefinement import GeometryRefinement
from pyFAI.peakPicker import PeakPicker
from pyFAI.utils import averageImages
from  matplotlib.path import Path
import matplotlib.path as mpath
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt


try:
    from rfoo.utils import rconsole
    rconsole.spawn_server()
except ImportError:
    logging.info("No socket opened for debugging -> install rfoo")

class Calibration(object):
    """
    class doing the calibration of frames
    """
    def __init__(self, dataFiles=None, darkFiles=None, flatFiles=None, pixelSize=None, splineFile=None, detector=None, gaussianWidth=None):
        """
        """
        self.dataFiles = dataFiles or []
        self.darkFiles = darkFiles or []
        self.flatFiles = flatFiles or []
        self.pointfile = None
        self.gaussianWidth = gaussianWidth
        self.labelPattern = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]
        if not detector:
            self.detector = Detector()
        if splineFile and os.path.isfile(splineFile):
            self.detector.splineFile = os.path.abspath(splineFile)
        if pixelSize:
            if __len__ in pixelSize and len(pixelSize) >= 2:
                self.detector.pixel1 = float(pixelSize[0])
                self.detector.pixel2 = float(pixelSize[1])
            else:
                self.detector.pixel1 = self.detector.pixel2 = float(pixelSize)
        self.cutBackground = None
        self.outfile = "merged.edf"
        self.peakPicker = None
        self.data = None
        self.basename = None
        self.geoRef = None
        self.reconstruct = False
        self.mask = None
        self.max_iter = 1000
        self.maximum_filter = False
        self.threshold = 0.1

    def __repr__(self):
        lst = ["Calibration object:",
             "data= " + ", ".join(self.dataFiles),
             "dark= " + ", ".join(self.darkFiles),
             "flat= " + ", ".join(self.flatFiles)]
        lst.append(self.detector.__repr__())
        lst.append("gaussian= %s" % self.gaussianWidth)
        return os.linesep.join(lst)

    def parse(self):
        """
        parse options from command line
        """
        from optparse import OptionParser
        parser = OptionParser()
        parser.add_option("-V", "--version", dest="version", action="store_true",
                          help="print version of the program and quit", metavar="FILE", default=False)
        parser.add_option("-o", "--out", dest="outfile",
                          help="Filename where processed image is saved", metavar="FILE", default="merged.edf")
        parser.add_option("-v", "--verbose",
                          action="store_true", dest="debug", default=False,
                          help="switch to debug/verbose mode")
        parser.add_option("-g", "--gaussian", dest="gaussian", help="""Size of the gaussian kernel.
Size of the gap (in pixels) between two consecutive rings, by default 100
Increase the value if the arc is not complete;
decrease the value if arcs are mixed together.""", default=None)
        parser.add_option("-c", "--square", dest="square", action="store_true",
                      help="Use square kernel shape for neighbor search instead of diamond shape", default=False)
        parser.add_option("-b", "--background", dest="background",
                      help="Automatic background subtraction if no value are provided", default=None)
        parser.add_option("-d", "--dark", dest="dark",
                      help="list of dark images to average and subtract", default=None)
        parser.add_option("-f", "--flat", dest="flat",
                      help="list of flat images to average and divide", default=None)
        parser.add_option("-r", "--reconstruct", dest="reconstruct",
                      help="Reconstruct image where data are masked or <0  (for Pilatus detectors or detectors with modules)",
                      action="store_true", default=False)
        parser.add_option("-s", "--spline", dest="spline",
                      help="spline file describing the detector distortion", default=None)
        parser.add_option("-p", "--pixel", dest="pixel",
                      help="size of the pixel in micron", default=None)
        parser.add_option("-D", "--detector", dest="detector_name",
                      help="Detector name (instead of pixel size+spline)", default=None)
        parser.add_option("-m", "--mask", dest="mask",
                      help="file containing the mask (for image reconstruction)", default=None)
        parser.add_option("-n", "--npt", dest="npt",
                      help="file with datapoints saved", default=None)
        parser.add_option("--max", dest="maximum_filter",
                      help="perform a maximum filter instead of a mean filter when multiple input files are provided",
                       default=False, action="store_true")
        parser.add_option("--saturation", dest="saturation",
                      help="consider all pixel>max*(1-saturation) as saturated and reconstruct them",
                      default=0.1, type="float")

        (options, args) = parser.parse_args()

        # Analyse aruments and options
        if options.version:
            print("pyFAI-calib version %s" % pyFAI.version)
            sys.exit(0)
        if options.debug:
            logger.setLevel(logging.DEBUG)
        self.outfile = options.outfile
        self.gaussianWidth = options.gaussian
        if options.square:
            self.labelPattern = [[1] * 3] * 3
        else:
            self.labelPattern = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]
        if options.background is not None:
            try:
                self.cutBackground = float(options.background)
            except Exception:
                self.cutBackground = True
        if options.dark:
            print options.dark, type(options.dark)
            self.darkFiles = [f for f in options.dark.split(",") if os.path.isfile(f)]
        if options.flat:
            print options.flat, type(options.flat)
            self.flatFiles = [f for f in options.flat.split(",") if os.path.isfile(f)]
        self.reconstruct = options.reconstruct
        if options.mask and os.path.isfile(options.mask):
            self.mask = fabio.open(options.mask).data


        self.pointfile = options.npt
        if options.detector_name:
            self.detector = detector_factory(options.detector_name)
        if options.spline:
            if os.path.isfile(options.spline):
                self.detector.splineFile = os.path.abspath(options.spline)
            else:
                logger.error("Unknown spline file %s" % (options.spline))
        if options.pixel is not None:
            self.get_pixelSize(options.pixel)
        self.maximum_filter = options.maximum_filter
        self.threshold = options.saturation
        self.dataFiles = [f for f in args if os.path.isfile(f)]
        if not self.dataFiles:
            raise RuntimeError("Please provide some calibration images ... if you want to analyze them. Try also the --help option to see all options!")

    def get_pixelSize(self, ans):
        """convert a comma separated sting into pixel size"""
        sp = ans.split(",")
        if len(sp) >= 2:
            try:
                pixelSizeXY = [float(i) * 1e-6 for i in sp[:2]]
            except Exception:
                logger.error("error in reading pixel size_2")
                return
        elif len(sp) == 1:
            px = sp[0]
            try:
                pixelSizeXY = [float(px) * 1e-6, float(px) * 1e-6]
            except Exception:
                logger.error("error in reading pixel size_1")
                return
        else:
            logger.error("error in reading pixel size_0")
            return
        self.detector.pixel1 = pixelSizeXY[1]
        self.detector.pixel2 = pixelSizeXY[0]

    def read_pixelsSize(self):
        """Read the pixel size from prompt if not available"""
        if (self.detector.pixel1 is None) and (self.detector.splineFile is None):
            pixelSize = [15, 15]
            ans = raw_input("Please enter the pixel size (in micron, comma separated X, Y , i.e. %.2e,%.2e) or a spline file: " % tuple(pixelSize)).strip()
            if os.path.isfile(ans):
                self.detector.splineFile = ans
            else:
                self.get_pixelSize(ans)


    def preprocess(self):
        """
        do dark, flat correction thresholding, ...
        """
        if len(self.dataFiles) > 1 or self.cutBackground or self.darkFiles or self.flatFiles:
            self.outfile = averageImages(self.dataFiles, self.outfile, threshold=self.threshold, minimum=self.cutBackground,
                                      darks=self.darkFiles, flats=self.flatFiles, max_filter=self.maximum_filter)
        else:
            self.outfile = self.dataFiles[0]
        self.basename = os.path.splitext(self.outfile)[0]
        self.peakPicker = PeakPicker(self.outfile, reconst=self.reconstruct, mask=self.mask)
        if self.gaussianWidth is not None:
            self.peakPicker.massif.setValleySize(self.gaussianWidth)
        else:
            self.peakPicker.massif.initValleySize()

    def gui_peakPicker(self):
        if self.peakPicker is None:
            self.preprocess()
        self.pointfile = self.basename + ".npt"
        self.peakPicker.gui(True)
        if os.path.isfile(self.pointfile):
            self.peakPicker.load(self.pointfile)
        self.data = self.peakPicker.finish(self.pointfile)

    def refine(self):
        if os.name == "nt" and self.peakPicker is not None:
            logging.info("We are under windows, matplotlib is not able to display too many images without crashing, this is why the window showing the diffraction image is closed")
            self.peakPicker.closeGUI()
        self.geoRef = GeometryRefinement(self.data, dist=0.1, detector=self.detector)
        paramfile = self.basename + ".poni"
        if os.path.isfile(paramfile):
            self.geoRef.load(paramfile)
        print self.geoRef
        previous = sys.maxint
        finished = False
        fig2 = None
        while not finished:
            count = 0
            while (previous > self.geoRef.chi2()) and (count < self.max_iter):
                previous = self.geoRef.chi2()
                self.geoRef.refine2(1000000)
                print(self.geoRef)
                count += 1
            print(self.geoRef)
            self.geoRef.save(self.basename + ".poni")
            self.geoRef.del_ttha()
            self.geoRef.del_dssa()
            self.geoRef.del_chia()
            t0 = time.time()
            tth = self.geoRef.twoThetaArray(self.peakPicker.shape)
            t1 = time.time()
            dsa = self.geoRef.solidAngleArray(self.peakPicker.shape)
            t2 = time.time()
            self.geoRef.chiArray(self.peakPicker.shape)
            t2a = time.time()
            self.geoRef.cornerArray(self.peakPicker.shape)
            t2b = time.time()
            if os.name == "nt":
                logger.info("We are under windows, matplotlib is not able to display too many images without crashing, this is why little information is displayed")
            else:
                self.peakPicker.contour(tth)
                if fig2 is None:
                    fig2 = pylab.plt.figure()
                    sp = fig2.add_subplot(111)
                else:
                    sp.images.pop()
                sp.imshow(dsa, origin="lower")
                # self.fig.canvas.draw()
                fig2.show()

            change = raw_input("Modify parameters ?\t ").strip()
            if (change == '') or (change.lower()[0] == "n"):
                finished = True
            else:
                self.peakPicker.readFloatFromKeyboard("Enter Distance in meter (or dist_min[%.3f] dist[%.3f] dist_max[%.3f]):\t " % (self.geoRef.dist_min, self.geoRef.dist, self.geoRef.dist_max), {1:[self.geoRef.set_dist], 3:[ self.geoRef.set_dist_min, self.geoRef.set_dist, self.geoRef.set_dist_max]})
                self.peakPicker.readFloatFromKeyboard("Enter Poni1 in meter (or poni1_min[%.3f] poni1[%.3f] poni1_max[%.3f]):\t " % (self.geoRef.poni1_min, self.geoRef.poni1, self.geoRef.poni1_max), {1:[self.geoRef.set_poni1], 3:[ self.geoRef.set_poni1_min, self.geoRef.set_poni1, self.geoRef.set_poni1_max]})
                self.peakPicker.readFloatFromKeyboard("Enter Poni2 in meter (or poni2_min[%.3f] poni2[%.3f] poni2_max[%.3f]):\t " % (self.geoRef.poni2_min, self.geoRef.poni2, self.geoRef.poni2_max), {1:[self.geoRef.set_poni2], 3:[ self.geoRef.set_poni2_min, self.geoRef.set_poni2, self.geoRef.set_poni2_max]})
                self.peakPicker.readFloatFromKeyboard("Enter Rot1 in rad (or rot1_min[%.3f] rot1[%.3f] rot1_max[%.3f]):\t " % (self.geoRef.rot1_min, self.geoRef.rot1, self.geoRef.rot1_max), {1:[self.geoRef.set_rot1], 3:[ self.geoRef.set_rot1_min, self.geoRef.set_rot1, self.geoRef.set_rot1_max]})
                self.peakPicker.readFloatFromKeyboard("Enter Rot2 in rad (or rot2_min[%.3f] rot2[%.3f] rot2_max[%.3f]):\t " % (self.geoRef.rot2_min, self.geoRef.rot2, self.geoRef.rot2_max), {1:[self.geoRef.set_rot2], 3:[ self.geoRef.set_rot2_min, self.geoRef.set_rot2, self.geoRef.set_rot2_max]})
                self.peakPicker.readFloatFromKeyboard("Enter Rot3 in rad (or rot3_min[%.3f] rot3[%.3f] rot3_max[%.3f]):\t " % (self.geoRef.rot3_min, self.geoRef.rot3, self.geoRef.rot3_max), {1:[self.geoRef.set_rot3], 3:[ self.geoRef.set_rot3_min, self.geoRef.set_rot3, self.geoRef.set_rot3_max]})
                previous = sys.maxint


    def postProcess(self):
        if self.geoRef is None:
            self.refine()
        self.geoRef.save(self.basename + ".poni")
        self.geoRef.del_ttha()
        self.geoRef.del_dssa()
        self.geoRef.del_chia()
        t0 = time.time()
        tth = self.geoRef.twoThetaArray(self.peakPicker.shape)
        t1 = time.time()
        dsa = self.geoRef.solidAngleArray(self.peakPicker.shape)
        t2 = time.time()
        self.geoRef.chiArray(self.peakPicker.shape)
        t2a = time.time()
        self.geoRef.cornerArray(self.peakPicker.shape)
        t2b = time.time()

        fig3 = pylab.plt.figure()
        xrpd = fig3.add_subplot(111)
        fig4 = pylab.plt.figure()
        xrpd2 = fig4.add_subplot(111)
        t3 = time.time()
        a, b = self.geoRef.xrpd(self.peakPicker.data, 1024, self.basename + ".xy", mask=self.mask)
        t4 = time.time()
        img = self.geoRef.xrpd2(self.peakPicker.data, 400, 360, self.basename + ".azim", mask=self.mask)[0]
        t5 = time.time()
        print ("Timings:\n two theta array generation %.3fs\n diff Solid Angle  %.3fs\n\
     chi array generation %.3fs\n\
     corner coordinate array %.3fs\n\
     1D Azimuthal integration: %.3fs\n\
     2D Azimuthal integration: %.3fs" % (t1 - t0, t2 - t1, t2a - t2, t2b - t2a, t4 - t3, t5 - t4))
        xrpd.plot(a, b)
        fig3.show()
        xrpd2.imshow(numpy.log(img - img.min() + 1e-3), origin="lower")
        fig4.show()

# This is for debugin wtih rconsole
c = None
if __name__ == "__main__":
    c = Calibration()
    c.parse()
    c.read_pixelsSize()
    c.preprocess()
    c.gui_peakPicker()
    c.refine()
    c.postProcess()
    raw_input("Press enter to quit")

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyFAI Package &mdash; pyFAI 0.13.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.13.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pyFAI 0.13.0 documentation" href="../index.html" />
    <link rel="up" title="pyFAI API" href="modules.html" />
    <link rel="next" title="Installation of Python Fast Azimuthal Integration library" href="../operations/index.html" />
    <link rel="prev" title="pyFAI API" href="modules.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../operations/index.html" title="Installation of Python Fast Azimuthal Integration library"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="pyFAI API"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">pyFAI 0.13.0 documentation</a> &raquo;</li>
          <li><a href="modules.html" accesskey="U">pyFAI API</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-pyFAI.__init__">
<span id="pyfai-package"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">pyFAI</span></tt> Package<a class="headerlink" href="#module-pyFAI.__init__" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="pyFAI.__init__.benchmarks">
<tt class="descclassname">pyFAI.__init__.</tt><tt class="descname">benchmarks</tt><big>(</big><em>*arg</em>, <em>**kwarg</em><big>)</big><a class="headerlink" href="#pyFAI.__init__.benchmarks" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the integrated benchmarks.</p>
<p>See the documentation of pyFAI.benchmark.run_benchmark</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.__init__.tests">
<tt class="descclassname">pyFAI.__init__.</tt><tt class="descname">tests</tt><big>(</big><em>deprecation=False</em><big>)</big><a class="headerlink" href="#pyFAI.__init__.tests" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the test suite of the installed version</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>deprecation</strong> &#8211; enable/disables deprecation warning in the tests</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pyFAI.average">
<span id="average-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">average</span></tt> Module<a class="headerlink" href="#module-pyFAI.average" title="Permalink to this headline">¶</a></h1>
<p>Utilities, mainly for image treatment</p>
<dl class="exception">
<dt id="pyFAI.average.AlgorithmCreationError">
<em class="property">exception </em><tt class="descclassname">pyFAI.average.</tt><tt class="descname">AlgorithmCreationError</tt><a class="headerlink" href="#pyFAI.average.AlgorithmCreationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.RuntimeError</span></tt></p>
<p>Exception returned if creation of an ImageReductionFilter is not
possible</p>
</dd></dl>

<dl class="class">
<dt id="pyFAI.average.Average">
<em class="property">class </em><tt class="descclassname">pyFAI.average.</tt><tt class="descname">Average</tt><a class="headerlink" href="#pyFAI.average.Average" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Process images to generate an average using different algorithms.</p>
<dl class="method">
<dt id="pyFAI.average.Average.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.average.Average.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.Average.add_algorithm">
<tt class="descname">add_algorithm</tt><big>(</big><em>algorithm</em><big>)</big><a class="headerlink" href="#pyFAI.average.Average.add_algorithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines another algorithm which will be computed on the source.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>algorithm</strong> (<em>ImageReductionFilter</em>) &#8211; An averaging algorithm.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.Average.get_counter_frames">
<tt class="descname">get_counter_frames</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.average.Average.get_counter_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of frames used for the process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.Average.get_fabio_images">
<tt class="descname">get_fabio_images</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.average.Average.get_fabio_images" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns source images as fabio images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list(fabio.fabioimage.FabioImage)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.Average.get_image_reduction">
<tt class="descname">get_image_reduction</tt><big>(</big><em>algorithm</em><big>)</big><a class="headerlink" href="#pyFAI.average.Average.get_image_reduction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of an algorithm. The <cite>process</cite> must be already
done.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>algorithm</strong> (<em>ImageReductionFilter</em>) &#8211; An averaging algorithm</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">numpy.ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.Average.process">
<tt class="descname">process</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.average.Average.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Process source images to all defined averaging algorithms defined
using defined parameters. To access to the results you have to define
a writer (<cite>AverageWriter</cite>). To follow the process forward you have to
define an observer (<cite>AverageObserver</cite>).</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.Average.set_correct_flat_from_dark">
<tt class="descname">set_correct_flat_from_dark</tt><big>(</big><em>correct_flat_from_dark</em><big>)</big><a class="headerlink" href="#pyFAI.average.Average.set_correct_flat_from_dark" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines if the dark must be applied on the flat.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>correct_flat_from_dark</strong> (<em>bool</em>) &#8211; If true, the dark is applied.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.Average.set_dark">
<tt class="descname">set_dark</tt><big>(</big><em>dark_list</em><big>)</big><a class="headerlink" href="#pyFAI.average.Average.set_dark" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines images used as dark.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dark_list</strong> (<em>list</em>) &#8211; List of dark used</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.Average.set_flat">
<tt class="descname">set_flat</tt><big>(</big><em>flat_list</em><big>)</big><a class="headerlink" href="#pyFAI.average.Average.set_flat" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines images used as flat.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>flat_list</strong> (<em>list</em>) &#8211; List of dark used</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.Average.set_images">
<tt class="descname">set_images</tt><big>(</big><em>image_list</em><big>)</big><a class="headerlink" href="#pyFAI.average.Average.set_images" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the set set of source images to used to process an average.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image_list</strong> (<em>list</em>) &#8211; List of filename, numpy arrays, fabio images
used as source for the computation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.Average.set_monitor_name">
<tt class="descname">set_monitor_name</tt><big>(</big><em>monitor_name</em><big>)</big><a class="headerlink" href="#pyFAI.average.Average.set_monitor_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the monitor name used to correct images before processing
the average. This monitor must be part of the file header, else the
image is skipped.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>monitor_name</strong> (<em>str</em>) &#8211; Name of the monitor available on the header
file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.Average.set_observer">
<tt class="descname">set_observer</tt><big>(</big><em>observer</em><big>)</big><a class="headerlink" href="#pyFAI.average.Average.set_observer" title="Permalink to this definition">¶</a></dt>
<dd><p>Set an observer to the average process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>observer</strong> (<em>AverageObserver</em>) &#8211; An observer</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.Average.set_pixel_filter">
<tt class="descname">set_pixel_filter</tt><big>(</big><em>threshold</em>, <em>minimum</em>, <em>maximum</em><big>)</big><a class="headerlink" href="#pyFAI.average.Average.set_pixel_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the filter applied on each pixels of the images before
processing the average.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>threshold</strong> &#8211; what is the upper limit?
all pixel &gt; max*(1-threshold) are discareded.</li>
<li><strong>minimum</strong> &#8211; minimum valid value or True</li>
<li><strong>maximum</strong> &#8211; maximum valid value</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.Average.set_writer">
<tt class="descname">set_writer</tt><big>(</big><em>writer</em><big>)</big><a class="headerlink" href="#pyFAI.average.Average.set_writer" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the object write which will be used to store the result.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>writer</strong> (<em>AverageWriter</em>) &#8211; The writer to use.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.average.AverageDarkFilter">
<em class="property">class </em><tt class="descclassname">pyFAI.average.</tt><tt class="descname">AverageDarkFilter</tt><big>(</big><em>filter_name</em>, <em>cut_off</em>, <em>quantiles</em><big>)</big><a class="headerlink" href="#pyFAI.average.AverageDarkFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.average.ImageStackFilter" title="pyFAI.average.ImageStackFilter"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.average.ImageStackFilter</span></tt></a></p>
<p>Filter based on the algorithm of average_dark</p>
<p>TODO: Must be split according to each filter_name, and removed</p>
<dl class="method">
<dt id="pyFAI.average.AverageDarkFilter.__init__">
<tt class="descname">__init__</tt><big>(</big><em>filter_name</em>, <em>cut_off</em>, <em>quantiles</em><big>)</big><a class="headerlink" href="#pyFAI.average.AverageDarkFilter.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.average.AverageDarkFilter.get_parameters">
<tt class="descname">get_parameters</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.average.AverageDarkFilter.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary containing filter parameters</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.average.AverageDarkFilter.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyFAI.average.AverageDarkFilter.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.average.AverageObserver">
<em class="property">class </em><tt class="descclassname">pyFAI.average.</tt><tt class="descname">AverageObserver</tt><a class="headerlink" href="#pyFAI.average.AverageObserver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="pyFAI.average.AverageObserver.algorithm_finished">
<tt class="descname">algorithm_finished</tt><big>(</big><em>algorithm</em><big>)</big><a class="headerlink" href="#pyFAI.average.AverageObserver.algorithm_finished" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when an algorithm is finished</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.AverageObserver.algorithm_started">
<tt class="descname">algorithm_started</tt><big>(</big><em>algorithm</em><big>)</big><a class="headerlink" href="#pyFAI.average.AverageObserver.algorithm_started" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when an algorithm is started</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.AverageObserver.frame_processed">
<tt class="descname">frame_processed</tt><big>(</big><em>algorithm</em>, <em>frame_index</em>, <em>frames_count</em><big>)</big><a class="headerlink" href="#pyFAI.average.AverageObserver.frame_processed" title="Permalink to this definition">¶</a></dt>
<dd><p>Called after providing a frame to an algorithm</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.AverageObserver.image_loaded">
<tt class="descname">image_loaded</tt><big>(</big><em>fabio_image</em>, <em>image_index</em>, <em>images_count</em><big>)</big><a class="headerlink" href="#pyFAI.average.AverageObserver.image_loaded" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when an input image is loaded</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.AverageObserver.process_finished">
<tt class="descname">process_finished</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.average.AverageObserver.process_finished" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when the full process is finished</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.AverageObserver.process_started">
<tt class="descname">process_started</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.average.AverageObserver.process_started" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when the full processing is started</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.AverageObserver.result_processing">
<tt class="descname">result_processing</tt><big>(</big><em>algorithm</em><big>)</big><a class="headerlink" href="#pyFAI.average.AverageObserver.result_processing" title="Permalink to this definition">¶</a></dt>
<dd><p>Called before the result of an algorithm is computed</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.average.AverageWriter">
<em class="property">class </em><tt class="descclassname">pyFAI.average.</tt><tt class="descname">AverageWriter</tt><a class="headerlink" href="#pyFAI.average.AverageWriter" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface for using writer in <cite>Average</cite> process.</p>
<dl class="method">
<dt id="pyFAI.average.AverageWriter.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.average.AverageWriter.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the writer. Must not be used anymore.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.AverageWriter.write_header">
<tt class="descname">write_header</tt><big>(</big><em>merged_files</em>, <em>nb_frames</em>, <em>monitor_name</em><big>)</big><a class="headerlink" href="#pyFAI.average.AverageWriter.write_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the header of the average</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>merged_files</strong> (<em>list</em>) &#8211; List of files used to generate this output</li>
<li><strong>nb_frames</strong> (<em>int</em>) &#8211; Number of frames used</li>
<li><strong>monitor_name</strong> (<em>str</em>) &#8211; Name of the monitor used. Can be None.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.AverageWriter.write_reduction">
<tt class="descname">write_reduction</tt><big>(</big><em>algorithm</em>, <em>data</em><big>)</big><a class="headerlink" href="#pyFAI.average.AverageWriter.write_reduction" title="Permalink to this definition">¶</a></dt>
<dd><p>Write one reduction</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>algorithm</strong> (<em>ImageReductionFilter</em>) &#8211; Algorithm used</li>
<li><strong>data</strong> (<em>object</em>) &#8211; Data of this reduction</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.average.ImageAccumulatorFilter">
<em class="property">class </em><tt class="descclassname">pyFAI.average.</tt><tt class="descname">ImageAccumulatorFilter</tt><a class="headerlink" href="#pyFAI.average.ImageAccumulatorFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.average.ImageReductionFilter" title="pyFAI.average.ImageReductionFilter"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.average.ImageReductionFilter</span></tt></a></p>
<p>Filter applied in a set of images in which it is possible
to reduce data step by step into a single merged image.</p>
<dl class="method">
<dt id="pyFAI.average.ImageAccumulatorFilter.add_image">
<tt class="descname">add_image</tt><big>(</big><em>image</em><big>)</big><a class="headerlink" href="#pyFAI.average.ImageAccumulatorFilter.add_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an image to the filter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image</strong> (<em>numpy.ndarray</em>) &#8211; image to add</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.ImageAccumulatorFilter.get_result">
<tt class="descname">get_result</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.average.ImageAccumulatorFilter.get_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the result of the filter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">result filter</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">numpy.ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.ImageAccumulatorFilter.init">
<tt class="descname">init</tt><big>(</big><em>max_images=None</em><big>)</big><a class="headerlink" href="#pyFAI.average.ImageAccumulatorFilter.init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.average.ImageReductionFilter">
<em class="property">class </em><tt class="descclassname">pyFAI.average.</tt><tt class="descname">ImageReductionFilter</tt><a class="headerlink" href="#pyFAI.average.ImageReductionFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Generic filter applied in a set of images.</p>
<dl class="method">
<dt id="pyFAI.average.ImageReductionFilter.add_image">
<tt class="descname">add_image</tt><big>(</big><em>image</em><big>)</big><a class="headerlink" href="#pyFAI.average.ImageReductionFilter.add_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an image to the filter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image</strong> (<em>numpy.ndarray</em>) &#8211; image to add</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.ImageReductionFilter.get_parameters">
<tt class="descname">get_parameters</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.average.ImageReductionFilter.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary containing filter parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.ImageReductionFilter.get_result">
<tt class="descname">get_result</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.average.ImageReductionFilter.get_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the result of the filter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">result filter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.ImageReductionFilter.init">
<tt class="descname">init</tt><big>(</big><em>max_images=None</em><big>)</big><a class="headerlink" href="#pyFAI.average.ImageReductionFilter.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the filter before using it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>max_images</strong> (<em>int</em>) &#8211; Max images supported by the filter</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.average.ImageStackFilter">
<em class="property">class </em><tt class="descclassname">pyFAI.average.</tt><tt class="descname">ImageStackFilter</tt><a class="headerlink" href="#pyFAI.average.ImageStackFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.average.ImageReductionFilter" title="pyFAI.average.ImageReductionFilter"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.average.ImageReductionFilter</span></tt></a></p>
<p>Filter creating a stack from all images and computing everything at the
end.</p>
<dl class="method">
<dt id="pyFAI.average.ImageStackFilter.add_image">
<tt class="descname">add_image</tt><big>(</big><em>image</em><big>)</big><a class="headerlink" href="#pyFAI.average.ImageStackFilter.add_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an image to the filter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image</strong> (<em>numpy.ndarray</em>) &#8211; image to add</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.ImageStackFilter.get_result">
<tt class="descname">get_result</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.average.ImageStackFilter.get_result" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.average.ImageStackFilter.init">
<tt class="descname">init</tt><big>(</big><em>max_images=None</em><big>)</big><a class="headerlink" href="#pyFAI.average.ImageStackFilter.init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.average.MaxAveraging">
<em class="property">class </em><tt class="descclassname">pyFAI.average.</tt><tt class="descname">MaxAveraging</tt><a class="headerlink" href="#pyFAI.average.MaxAveraging" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.average.ImageAccumulatorFilter" title="pyFAI.average.ImageAccumulatorFilter"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.average.ImageAccumulatorFilter</span></tt></a></p>
<dl class="attribute">
<dt id="pyFAI.average.MaxAveraging.name">
<tt class="descname">name</tt><em class="property"> = 'max'</em><a class="headerlink" href="#pyFAI.average.MaxAveraging.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.average.MeanAveraging">
<em class="property">class </em><tt class="descclassname">pyFAI.average.</tt><tt class="descname">MeanAveraging</tt><a class="headerlink" href="#pyFAI.average.MeanAveraging" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.average.SumAveraging" title="pyFAI.average.SumAveraging"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.average.SumAveraging</span></tt></a></p>
<dl class="method">
<dt id="pyFAI.average.MeanAveraging.get_result">
<tt class="descname">get_result</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.average.MeanAveraging.get_result" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.average.MeanAveraging.name">
<tt class="descname">name</tt><em class="property"> = 'mean'</em><a class="headerlink" href="#pyFAI.average.MeanAveraging.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.average.MinAveraging">
<em class="property">class </em><tt class="descclassname">pyFAI.average.</tt><tt class="descname">MinAveraging</tt><a class="headerlink" href="#pyFAI.average.MinAveraging" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.average.ImageAccumulatorFilter" title="pyFAI.average.ImageAccumulatorFilter"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.average.ImageAccumulatorFilter</span></tt></a></p>
<dl class="attribute">
<dt id="pyFAI.average.MinAveraging.name">
<tt class="descname">name</tt><em class="property"> = 'min'</em><a class="headerlink" href="#pyFAI.average.MinAveraging.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="pyFAI.average.MonitorNotFound">
<em class="property">exception </em><tt class="descclassname">pyFAI.average.</tt><tt class="descname">MonitorNotFound</tt><a class="headerlink" href="#pyFAI.average.MonitorNotFound" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></tt></p>
<p>Raised when monitor information in not found or is not valid.</p>
</dd></dl>

<dl class="class">
<dt id="pyFAI.average.MultiFilesAverageWriter">
<em class="property">class </em><tt class="descclassname">pyFAI.average.</tt><tt class="descname">MultiFilesAverageWriter</tt><big>(</big><em>file_name_pattern</em>, <em>file_format</em>, <em>dry_run=False</em><big>)</big><a class="headerlink" href="#pyFAI.average.MultiFilesAverageWriter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.average.AverageWriter" title="pyFAI.average.AverageWriter"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.average.AverageWriter</span></tt></a></p>
<p>Write reductions into multi files. File headers are duplicated.</p>
<dl class="method">
<dt id="pyFAI.average.MultiFilesAverageWriter.__init__">
<tt class="descname">__init__</tt><big>(</big><em>file_name_pattern</em>, <em>file_format</em>, <em>dry_run=False</em><big>)</big><a class="headerlink" href="#pyFAI.average.MultiFilesAverageWriter.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_name_pattern</strong> (<em>str</em>) &#8211; File name pattern for the output files.
If it contains &#8220;{method_name}&#8221;, it is updated for each
reduction writing with the name of the reduction.</li>
<li><strong>file_format</strong> (<em>str</em>) &#8211; File format used. It is the default
extension file.</li>
<li><strong>dry_run</strong> (<em>bool</em>) &#8211; If dry_run, the file is created on memory but not
saved on the file system at the end</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.MultiFilesAverageWriter.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.average.MultiFilesAverageWriter.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the writer. Must not be used anymore.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.MultiFilesAverageWriter.get_fabio_image">
<tt class="descname">get_fabio_image</tt><big>(</big><em>algorithm</em><big>)</big><a class="headerlink" href="#pyFAI.average.MultiFilesAverageWriter.get_fabio_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the constructed fabio image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">fabio.fabioimage.FabioImage</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.average.MultiFilesAverageWriter.write_header">
<tt class="descname">write_header</tt><big>(</big><em>merged_files</em>, <em>nb_frames</em>, <em>monitor_name</em><big>)</big><a class="headerlink" href="#pyFAI.average.MultiFilesAverageWriter.write_header" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.average.MultiFilesAverageWriter.write_reduction">
<tt class="descname">write_reduction</tt><big>(</big><em>algorithm</em>, <em>data</em><big>)</big><a class="headerlink" href="#pyFAI.average.MultiFilesAverageWriter.write_reduction" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.average.SumAveraging">
<em class="property">class </em><tt class="descclassname">pyFAI.average.</tt><tt class="descname">SumAveraging</tt><a class="headerlink" href="#pyFAI.average.SumAveraging" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.average.ImageAccumulatorFilter" title="pyFAI.average.ImageAccumulatorFilter"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.average.ImageAccumulatorFilter</span></tt></a></p>
<dl class="attribute">
<dt id="pyFAI.average.SumAveraging.name">
<tt class="descname">name</tt><em class="property"> = 'sum'</em><a class="headerlink" href="#pyFAI.average.SumAveraging.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.average.average_dark">
<tt class="descclassname">pyFAI.average.</tt><tt class="descname">average_dark</tt><big>(</big><em>lstimg</em>, <em>center_method='mean'</em>, <em>cutoff=None</em>, <em>quantiles=(0.5</em>, <em>0.5)</em><big>)</big><a class="headerlink" href="#pyFAI.average.average_dark" title="Permalink to this definition">¶</a></dt>
<dd><p>Averages a serie of dark (or flat) images.
Centers the result on the mean or the median ...
but averages all frames within  cutoff*std</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lstimg</strong> &#8211; list of 2D images or a 3D stack</li>
<li><strong>center_method</strong> (<em>str</em>) &#8211; is the center calculated by a &#8220;mean&#8221;, &#8220;median&#8221;,
&#8220;quantile&#8221;, &#8220;std&#8221;</li>
<li><strong>cutoff</strong> (<em>float or None</em>) &#8211; keep all data where (I-center)/std &lt; cutoff</li>
<li><strong>quantiles</strong> (<em>tuple(float, float) or None</em>) &#8211; 2-tuple of floats average out data between the two
quantiles</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2D image averaged</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.average.average_images">
<tt class="descclassname">pyFAI.average.</tt><tt class="descname">average_images</tt><big>(</big><em>listImages</em>, <em>output=None</em>, <em>threshold=0.1</em>, <em>minimum=None</em>, <em>maximum=None</em>, <em>darks=None</em>, <em>flats=None</em>, <em>filter_='mean'</em>, <em>correct_flat_from_dark=False</em>, <em>cutoff=None</em>, <em>quantiles=None</em>, <em>fformat='edf'</em>, <em>monitor_key=None</em><big>)</big><a class="headerlink" href="#pyFAI.average.average_images" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Takes a list of filenames and create an average frame discarding all</dt>
<dd>saturated pixels.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>listImages</strong> &#8211; list of string representing the filenames</li>
<li><strong>output</strong> &#8211; name of the optional output file</li>
<li><strong>threshold</strong> &#8211; what is the upper limit? all pixel &gt; max*(1-threshold)
are discareded.</li>
<li><strong>minimum</strong> &#8211; minimum valid value or True</li>
<li><strong>maximum</strong> &#8211; maximum valid value</li>
<li><strong>darks</strong> &#8211; list of dark current images for subtraction</li>
<li><strong>flats</strong> &#8211; list of flat field images for division</li>
<li><strong>filter</strong> &#8211; can be &#8220;min&#8221;, &#8220;max&#8221;, &#8220;median&#8221;, &#8220;mean&#8221;, &#8220;sum&#8221;, &#8220;quantiles&#8221;
(default=&#8217;mean&#8217;)</li>
<li><strong>correct_flat_from_dark</strong> &#8211; shall the flat be re-corrected ?</li>
<li><strong>cutoff</strong> &#8211; keep all data where (I-center)/std &lt; cutoff</li>
<li><strong>quantiles</strong> &#8211; 2-tuple containing the lower and upper quantile (0&lt;q&lt;1)
to average out.</li>
<li><strong>fformat</strong> &#8211; file format of the output image, default: edf</li>
<li><strong>str</strong> (<em>monitor_key</em>) &#8211; Key containing the monitor. Can be none.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">filename with the data or the data ndarray in case format=None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.average.bounding_box">
<tt class="descclassname">pyFAI.average.</tt><tt class="descname">bounding_box</tt><big>(</big><em>img</em><big>)</big><a class="headerlink" href="#pyFAI.average.bounding_box" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to guess the bounding box around a valid massif</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>img</strong> &#8211; 2D array like</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">4-typle (d0_min, d1_min, d0_max, d1_max)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.average.common_prefix">
<tt class="descclassname">pyFAI.average.</tt><tt class="descname">common_prefix</tt><big>(</big><em>string_list</em><big>)</big><a class="headerlink" href="#pyFAI.average.common_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the common prefix of a list of strings</p>
<p>TODO: move it into utils package</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>string_list</strong> (<em>list(str)</em>) &#8211; List of strings</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.average.create_algorithm">
<tt class="descclassname">pyFAI.average.</tt><tt class="descname">create_algorithm</tt><big>(</big><em>filter_name</em>, <em>cut_off=None</em>, <em>quantiles=None</em><big>)</big><a class="headerlink" href="#pyFAI.average.create_algorithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create algorithm according to parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cutoff</strong> (<em>float or None</em>) &#8211; keep all data where (I-center)/std &lt; cutoff</li>
<li><strong>quantiles</strong> (<em>tuple(float, float) or None</em>) &#8211; 2-tuple of floats average out data between the two
quantiles</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An algorithm</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">ImageReductionFilter</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises AlgorithmCreationError:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">If it is not possible to create the
algorithm</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.average.f">
<tt class="descclassname">pyFAI.average.</tt><tt class="descname">f</tt><a class="headerlink" href="#pyFAI.average.f" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyFAI.average.SumAveraging" title="pyFAI.average.SumAveraging"><tt class="xref py py-class docutils literal"><span class="pre">SumAveraging</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.average.is_algorithm_name_exists">
<tt class="descclassname">pyFAI.average.</tt><tt class="descname">is_algorithm_name_exists</tt><big>(</big><em>filter_name</em><big>)</big><a class="headerlink" href="#pyFAI.average.is_algorithm_name_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the name is a name of a filter algorithm</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.average.remove_saturated_pixel">
<tt class="descclassname">pyFAI.average.</tt><tt class="descname">remove_saturated_pixel</tt><big>(</big><em>ds</em>, <em>threshold=0.1</em>, <em>minimum=None</em>, <em>maximum=None</em><big>)</big><a class="headerlink" href="#pyFAI.average.remove_saturated_pixel" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove saturated fixes from an array inplace.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ds</strong> &#8211; a dataset as ndarray</li>
<li><strong>threshold</strong> (<em>float</em>) &#8211; what is the upper limit?
all pixel &gt; max*(1-threshold) are discareded.</li>
<li><strong>minimum</strong> (<em>float</em>) &#8211; minumum valid value (or True for auto-guess)</li>
<li><strong>maximum</strong> (<em>float</em>) &#8211; maximum valid value</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the input dataset</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pyFAI.azimuthalIntegrator">
<span id="azimuthalintegrator-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">azimuthalIntegrator</span></tt> Module<a class="headerlink" href="#module-pyFAI.azimuthalIntegrator" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator">
<em class="property">class </em><tt class="descclassname">pyFAI.azimuthalIntegrator.</tt><tt class="descname">AzimuthalIntegrator</tt><big>(</big><em>dist=1</em>, <em>poni1=0</em>, <em>poni2=0</em>, <em>rot1=0</em>, <em>rot2=0</em>, <em>rot3=0</em>, <em>pixel1=None</em>, <em>pixel2=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.geometry.Geometry" title="pyFAI.geometry.Geometry"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.geometry.Geometry</span></tt></a></p>
<p>This class is an azimuthal integrator based on P. Boesecke&#8217;s
geometry and histogram algorithm by Manolo S. del Rio and V.A Sole</p>
<p>All geometry calculation are done in the Geometry class</p>
<p>main methods are:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tth</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">ai</span><span class="o">.</span><span class="n">integrate1d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">npt</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s">&quot;2th_deg&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">ai</span><span class="o">.</span><span class="n">integrate1d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">npt</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s">&quot;q_nm^-1&quot;</span><span class="p">,</span> <span class="n">error_model</span><span class="o">=</span><span class="s">&quot;poisson&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regrouped</span> <span class="o">=</span> <span class="n">ai</span><span class="o">.</span><span class="n">integrate2d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">npt_rad</span><span class="p">,</span> <span class="n">npt_azim</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s">&quot;q_nm^-1&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.DEFAULT_METHOD">
<tt class="descname">DEFAULT_METHOD</tt><em class="property"> = 'splitbbox'</em><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.DEFAULT_METHOD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.__init__">
<tt class="descname">__init__</tt><big>(</big><em>dist=1</em>, <em>poni1=0</em>, <em>poni2=0</em>, <em>rot1=0</em>, <em>rot2=0</em>, <em>rot3=0</em>, <em>pixel1=None</em>, <em>pixel2=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dist</strong> (<em>float</em>) &#8211; distance sample - detector plan (orthogonal distance, not along the beam), in meter.</li>
<li><strong>poni1</strong> (<em>float</em>) &#8211; coordinate of the point of normal incidence along the detector&#8217;s first dimension, in meter</li>
<li><strong>poni2</strong> (<em>float</em>) &#8211; coordinate of the point of normal incidence along the detector&#8217;s second dimension, in meter</li>
<li><strong>rot1</strong> (<em>float</em>) &#8211; first rotation from sample ref to detector&#8217;s ref, in radians</li>
<li><strong>rot2</strong> (<em>float</em>) &#8211; second rotation from sample ref to detector&#8217;s ref, in radians</li>
<li><strong>rot3</strong> (<em>float</em>) &#8211; third rotation from sample ref to detector&#8217;s ref, in radians</li>
<li><strong>pixel1</strong> (<em>float</em>) &#8211; Deprecated. Pixel size of the fist dimension of the detector,  in meter.
If both pixel1 and pixel2 are not None, detector pixel size is overwritten.
Prefer defining the detector pixel size on the provided detector object.
Prefer defining the detector pixel size on the provided detector
object (<tt class="docutils literal"><span class="pre">detector.pixel1</span> <span class="pre">=</span> <span class="pre">5e-6</span></tt>).</li>
<li><strong>pixel2</strong> (<em>float</em>) &#8211; Deprecated. Pixel size of the second dimension of the detector,  in meter.
If both pixel1 and pixel2 are not None, detector pixel size is overwritten.
Prefer defining the detector pixel size on the provided detector
object (<tt class="docutils literal"><span class="pre">detector.pixel2</span> <span class="pre">=</span> <span class="pre">5e-6</span></tt>).</li>
<li><strong>splineFile</strong> (<em>str</em>) &#8211; Deprecated. File containing the geometric distortion of the detector.
If not None, pixel1 and pixel2 are ignored and detector spline is overwritten.
Prefer defining the detector spline manually
(<tt class="docutils literal"><span class="pre">detector.splineFile</span> <span class="pre">=</span> <span class="pre">&quot;file.spline&quot;</span></tt>).</li>
<li><strong>detector</strong> (<em>str or pyFAI.Detector</em>) &#8211; name of the detector or Detector instance. String
description is deprecated. Prefer using the result of the detector
factory: <tt class="docutils literal"><span class="pre">pyFAI.detector_factory(&quot;eiger4m&quot;)</span></tt></li>
<li><strong>wavelength</strong> (<em>float</em>) &#8211; Wave length used in meter</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.create_mask">
<tt class="descname">create_mask</tt><big>(</big><em>data</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>mode='normal'</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.create_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines various masks into another one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; input array of data</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; input mask (if none, self.mask is used)</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value of dead pixels</li>
<li><strong>delta_dumy</strong> &#8211; precision of dummy pixels</li>
<li><strong>mode</strong> (<em>str</em>) &#8211; can be &#8220;normal&#8221; or &#8220;numpy&#8221; (inverted) or &#8220;where&#8221; applied to the mask</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the new mask</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray of bool</p>
</td>
</tr>
</tbody>
</table>
<p>This method combine two masks (dynamic mask from <em>data &amp;
dummy</em> and <em>mask</em>) to generate a new one with the &#8216;or&#8217; binary
operation.  One can adjust the level, with the <em>dummy</em> and
the <em>delta_dummy</em> parameter, when you consider the <em>data</em>
values needs to be masked out.</p>
<p>This method can work in two different <em>mode</em>:</p>
<blockquote>
<div><ul class="simple">
<li>&#8220;normal&#8221;: False for valid pixels, True for bad pixels</li>
<li>&#8220;numpy&#8221;: True for valid pixels, false for others</li>
</ul>
</div></blockquote>
<p>This method tries to accomodate various types of masks (like
valid=0 &amp; masked=-1, ...) and guesses if an input mask needs
to be inverted.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.dark_correction">
<tt class="descname">dark_correction</tt><big>(</big><em>data</em>, <em>dark=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.dark_correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct for Dark-current effects.
If dark is not defined, correct for a dark set by &#8220;set_darkfiles&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> &#8211; input ndarray with the image</li>
<li><strong>dark</strong> &#8211; ndarray with dark noise or None</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2tuple: corrected_data, dark_actually used (or None)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.darkcurrent">
<tt class="descname">darkcurrent</tt><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.darkcurrent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.empty">
<tt class="descname">empty</tt><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.empty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.flat_correction">
<tt class="descname">flat_correction</tt><big>(</big><em>data</em>, <em>flat=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.flat_correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct for flat field.
If flat is not defined, correct for a flat set by &#8220;set_flatfiles&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> &#8211; input ndarray with the image</li>
<li><strong>dark</strong> &#8211; ndarray with dark noise or None</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2tuple: corrected_data, flat_actually used (or None)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.flatfield">
<tt class="descname">flatfield</tt><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.flatfield" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_darkcurrent">
<tt class="descname">get_darkcurrent</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_darkcurrent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_empty">
<tt class="descname">get_empty</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_empty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_flatfield">
<tt class="descname">get_flatfield</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_flatfield" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.integrate1d">
<tt class="descname">integrate1d</tt><big>(</big><em>data</em>, <em>npt</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>variance=None</em>, <em>error_model=None</em>, <em>radial_range=None</em>, <em>azimuth_range=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>polarization_factor=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>method='csr'</em>, <em>unit=q_nm^-1</em>, <em>safe=True</em>, <em>normalization_factor=1.0</em>, <em>block_size=32</em>, <em>profile=False</em>, <em>all=False</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.integrate1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the azimuthal integrated Saxs curve in q(nm^-1) by default</p>
<p>Multi algorithm implementation (tries to be bullet proof), suitable for SAXS, WAXS, ... and much more</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the Detector/CCD camera</li>
<li><strong>npt</strong> (<em>int</em>) &#8211; number of points in the output pattern</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; output filename in 2/3 column ascii format</li>
<li><strong>correctSolidAngle</strong> (<em>bool</em>) &#8211; correct for solid angle of each pixel if True</li>
<li><strong>variance</strong> (<em>ndarray</em>) &#8211; array containing the variance of the data. If not available, no error propagation is done</li>
<li><strong>error_model</strong> (<em>str</em>) &#8211; When the variance is unknown, an error model can be given: &#8220;poisson&#8221; (variance = I), &#8220;azimuthal&#8221; (variance = (I-&lt;I&gt;)^2)</li>
<li><strong>radial_range</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the radial unit. If not provided, range is simply (data.min(), data.max()). Values outside the range are ignored.</li>
<li><strong>azimuth_range</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the azimuthal angle in degree. If not provided, range is simply (data.min(), data.max()). Values outside the range are ignored.</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array (same size as image) with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; polarization factor between -1 (vertical) and +1 (horizontal). 
0 for circular polarization or random, 
None for no correction, 
True for using the former correction</li>
<li><strong>dark</strong> (<em>ndarray</em>) &#8211; dark noise image</li>
<li><strong>flat</strong> (<em>ndarray</em>) &#8211; flat field image</li>
<li><strong>method</strong> (<em>str</em>) &#8211; can be &#8220;numpy&#8221;, &#8220;cython&#8221;, &#8220;BBox&#8221; or &#8220;splitpixel&#8221;, &#8220;lut&#8221;, &#8220;csr&#8221;, &#8220;nosplit_csr&#8221;, &#8220;full_csr&#8221;, &#8220;lut_ocl&#8221; and &#8220;csr_ocl&#8221; if you want to go on GPU. To Specify the device: &#8220;csr_ocl_1,2&#8221;</li>
<li><strong>unit</strong> (<em>pyFAI.units.Enum</em>) &#8211; Output units, can be &#8220;q_nm^-1&#8221;, &#8220;q_A^-1&#8221;, &#8220;2th_deg&#8221;, &#8220;2th_rad&#8221;, &#8220;r_mm&#8221; for now</li>
<li><strong>safe</strong> (<em>bool</em>) &#8211; Do some extra checks to ensure LUT/CSR is still valid. False is faster.</li>
<li><strong>normalization_factor</strong> (<em>float</em>) &#8211; Value of a normalization monitor</li>
<li><strong>block_size</strong> &#8211; size of the block for OpenCL integration (unused?)</li>
<li><strong>profile</strong> &#8211; set to True to enable profiling in OpenCL</li>
<li><strong>all</strong> (<em>bool</em>) &#8211; if true return a dictionary with many more parameters (deprecated, please refer to the documentation of Integrate1dResult).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">q/2th/r bins center positions and regrouped intensity (and error array if variance or variance model provided), uneless all==True.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Integrate1dResult, dict</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.integrate2d">
<tt class="descname">integrate2d</tt><big>(</big><em>data</em>, <em>npt_rad</em>, <em>npt_azim=360</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>variance=None</em>, <em>error_model=None</em>, <em>radial_range=None</em>, <em>azimuth_range=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>polarization_factor=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>method='bbox'</em>, <em>unit=q_nm^-1</em>, <em>safe=True</em>, <em>normalization_factor=1.0</em>, <em>all=False</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.integrate2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the azimuthal regrouped 2d image in q(nm^-1)/chi(deg) by default</p>
<p>Multi algorithm implementation (tries to be bullet proof)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the Detector/CCD camera</li>
<li><strong>npt_rad</strong> (<em>int</em>) &#8211; number of points in the radial direction</li>
<li><strong>npt_azim</strong> (<em>int</em>) &#8211; number of points in the azimuthal direction</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; output image (as edf format)</li>
<li><strong>correctSolidAngle</strong> (<em>bool</em>) &#8211; correct for solid angle of each pixel if True</li>
<li><strong>variance</strong> (<em>ndarray</em>) &#8211; array containing the variance of the data. If not available, no error propagation is done</li>
<li><strong>error_model</strong> (<em>str</em>) &#8211; When the variance is unknown, an error model can be given: &#8220;poisson&#8221; (variance = I), &#8220;azimuthal&#8221; (variance = (I-&lt;I&gt;)^2)</li>
<li><strong>radial_range</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the radial unit. If not provided, range is simply (data.min(), data.max()). Values outside the range are ignored.</li>
<li><strong>azimuth_range</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the azimuthal angle in degree. If not provided, range is simply (data.min(), data.max()). Values outside the range are ignored.</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array (same size as image) with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; polarization factor between -1 (vertical) and +1 (horizontal). 0 for circular polarization or random, None for no correction</li>
<li><strong>dark</strong> (<em>ndarray</em>) &#8211; dark noise image</li>
<li><strong>flat</strong> (<em>ndarray</em>) &#8211; flat field image</li>
<li><strong>method</strong> (<em>str</em>) &#8211; can be &#8220;numpy&#8221;, &#8220;cython&#8221;, &#8220;BBox&#8221; or &#8220;splitpixel&#8221;, &#8220;lut&#8221;, &#8220;csr; &#8220;lut_ocl&#8221; and &#8220;csr_ocl&#8221; if you want to go on GPU. To Specify the device: &#8220;csr_ocl_1,2&#8221;</li>
<li><strong>unit</strong> (<em>pyFAI.units.Enum</em>) &#8211; Output units, can be &#8220;q_nm^-1&#8221;, &#8220;q_A^-1&#8221;, &#8220;2th_deg&#8221;, &#8220;2th_rad&#8221;, &#8220;r_mm&#8221; for now</li>
<li><strong>safe</strong> (<em>bool</em>) &#8211; Do some extra checks to ensure LUT is still valid. False is faster.</li>
<li><strong>normalization_factor</strong> (<em>float</em>) &#8211; Value of a normalization monitor</li>
<li><strong>all</strong> (<em>bool</em>) &#8211; if true, return many more intermediate results as a dict (deprecated, please refer to the documentation of Integrate2dResult).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">azimuthaly regrouped intensity, q/2theta/r pos. and chi pos.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Integrate2dResult, dict</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset azimuthal integrator in addition to other arrays.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.save1D">
<tt class="descname">save1D</tt><big>(</big><em>filename</em>, <em>dim1</em>, <em>I</em>, <em>error=None</em>, <em>dim1_unit=2th_deg</em>, <em>has_dark=False</em>, <em>has_flat=False</em>, <em>polarization_factor=None</em>, <em>normalization_factor=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.save1D" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; the filename used to save the 1D integration</li>
<li><strong>dim1</strong> (<em>numpy.ndarray</em>) &#8211; the x coordinates of the integrated curve</li>
<li><strong>I</strong> (<em>numpy.mdarray</em>) &#8211; The integrated intensity</li>
<li><strong>error</strong> (<em>numpy.ndarray or None</em>) &#8211; the error bar for each intensity</li>
<li><strong>dim1_unit</strong> (<a class="reference internal" href="#pyFAI.units.Unit" title="pyFAI.units.Unit"><em>pyFAI.units.Unit</em></a>) &#8211; the unit of the dim1 array</li>
<li><strong>has_dark</strong> (<em>bool</em>) &#8211; save the darks filenames (default: no)</li>
<li><strong>has_flat</strong> (<em>bool</em>) &#8211; save the flat filenames (default: no)</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; the polarization factor</li>
<li><strong>normalization_factor</strong> (<em>float</em>) &#8211; the monitor value</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This method save the result of a 1D integration.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.save2D">
<tt class="descname">save2D</tt><big>(</big><em>filename</em>, <em>I</em>, <em>dim1</em>, <em>dim2</em>, <em>error=None</em>, <em>dim1_unit=2th_deg</em>, <em>has_dark=False</em>, <em>has_flat=False</em>, <em>polarization_factor=None</em>, <em>normalization_factor=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.save2D" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; the filename used to save the 2D histogram</li>
<li><strong>dim1</strong> (<em>numpy.ndarray</em>) &#8211; the 1st coordinates of the histogram</li>
<li><strong>dim1</strong> &#8211; the 2nd coordinates of the histogram</li>
<li><strong>I</strong> (<em>numpy.mdarray</em>) &#8211; The integrated intensity</li>
<li><strong>error</strong> (<em>numpy.ndarray or None</em>) &#8211; the error bar for each intensity</li>
<li><strong>dim1_unit</strong> (<a class="reference internal" href="#pyFAI.units.Unit" title="pyFAI.units.Unit"><em>pyFAI.units.Unit</em></a>) &#8211; the unit of the dim1 array</li>
<li><strong>has_dark</strong> (<em>bool</em>) &#8211; save the darks filenames (default: no)</li>
<li><strong>has_flat</strong> (<em>bool</em>) &#8211; save the flat filenames (default: no)</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; the polarization factor</li>
<li><strong>normalization_factor</strong> (<em>float</em>) &#8211; the monitor value</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This method save the result of a 2D integration.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.saxs">
<tt class="descname">saxs</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.saxs" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.separate">
<tt class="descname">separate</tt><big>(</big><em>data</em>, <em>npt_rad=1024</em>, <em>npt_azim=512</em>, <em>unit='2th_deg'</em>, <em>method='splitpixel'</em>, <em>percentile=50</em>, <em>mask=None</em>, <em>restore_mask=True</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.separate" title="Permalink to this definition">¶</a></dt>
<dd><p>Separate bragg signal from powder/amorphous signal using azimuthal integration,
median filering and projected back before subtraction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> &#8211; input image as numpy array</li>
<li><strong>npt_rad</strong> &#8211; number of radial points</li>
<li><strong>npt_azim</strong> &#8211; number of azimuthal points</li>
<li><strong>unit</strong> &#8211; unit to be used for integration</li>
<li><strong>method</strong> &#8211; pathway for integration and sort</li>
<li><strong>percentile</strong> &#8211; which percentile use for cutting out</li>
<li><strong>mask</strong> &#8211; masked out pixels array</li>
<li><strong>restore_mask</strong> &#8211; masked pixels have the same value as input data provided</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">bragg, amorphous</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_darkcurrent">
<tt class="descname">set_darkcurrent</tt><big>(</big><em>dark</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_darkcurrent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_darkfiles">
<tt class="descname">set_darkfiles</tt><big>(</big><em>files=None</em>, <em>method='mean'</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_darkfiles" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>files</strong> (<em>str or list(str) or None</em>) &#8211; file(s) used to compute the dark.</li>
<li><strong>method</strong> (<em>str</em>) &#8211; method used to compute the dark, &#8220;mean&#8221; or &#8220;median&#8221;</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Set the dark current from one or mutliple files, avaraged
according to the method provided</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_empty">
<tt class="descname">set_empty</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_empty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_flatfield">
<tt class="descname">set_flatfield</tt><big>(</big><em>flat</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_flatfield" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_flatfiles">
<tt class="descname">set_flatfiles</tt><big>(</big><em>files</em>, <em>method='mean'</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_flatfiles" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>files</strong> (<em>str or list(str) or None</em>) &#8211; file(s) used to compute the dark.</li>
<li><strong>method</strong> (<em>str</em>) &#8211; method used to compute the dark, &#8220;mean&#8221; or &#8220;median&#8221;</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Set the flat field from one or mutliple files, averaged
according to the method provided</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.setup_CSR">
<tt class="descname">setup_CSR</tt><big>(</big><em>shape</em>, <em>npt</em>, <em>mask=None</em>, <em>pos0_range=None</em>, <em>pos1_range=None</em>, <em>mask_checksum=None</em>, <em>unit=2th_deg</em>, <em>split='bbox'</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.setup_CSR" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare a look-up-table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shape</strong> (<em>(int, int)</em>) &#8211; shape of the dataset</li>
<li><strong>npt</strong> (<em>int or (int, int)</em>) &#8211; number of points in the the output pattern</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array with masked pixel (1=masked)</li>
<li><strong>pos0_range</strong> (<em>(float, float)</em>) &#8211; range in radial dimension</li>
<li><strong>pos1_range</strong> (<em>(float, float)</em>) &#8211; range in azimuthal dimension</li>
<li><strong>mask_checksum</strong> (<em>int (or anything else ...)</em>) &#8211; checksum of the mask buffer</li>
<li><strong>unit</strong> (<em>pyFAI.units.Enum</em>) &#8211; use to propagate the LUT object for further checkings</li>
<li><strong>split</strong> &#8211; Splitting scheme: valid options are &#8220;no&#8221;, &#8220;bbox&#8221;, &#8220;full&#8221;</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This method is called when a look-up table needs to be set-up.
The <em>shape</em> parameter, correspond to the shape of the original
datatset. It is possible to customize the number of point of
the output histogram with the <em>npt</em> parameter which can be
either an integer for an 1D integration or a 2-tuple of
integer in case of a 2D integration. The LUT will have a
different shape: (npt, lut_max_size), the later parameter
being calculated during the instanciation of the splitBBoxLUT
class.</p>
<p>It is possible to prepare the LUT with a predefine
<em>mask</em>. This operation can speedup the computation of the
later integrations. Instead of applying the patch on the
dataset, it is taken into account during the histogram
computation. If provided the <em>mask_checksum</em> prevent the
re-calculation of the mask. When the mask changes, its
checksum is used to reset (or not) the LUT (which is a very
time consuming operation !)</p>
<p>It is also possible to restrain the range of the 1D or 2D
pattern with the <em>pos1_range</em> and <em>pos2_range</em>.</p>
<p>The <em>unit</em> parameter is just propagated to the LUT integrator
for further checkings: The aim is to prevent an integration to
be performed in 2th-space when the LUT was setup in q space.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.setup_LUT">
<tt class="descname">setup_LUT</tt><big>(</big><em>shape</em>, <em>npt</em>, <em>mask=None</em>, <em>pos0_range=None</em>, <em>pos1_range=None</em>, <em>mask_checksum=None</em>, <em>unit=2th_deg</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.setup_LUT" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare a look-up-table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shape</strong> (<em>(int, int)</em>) &#8211; shape of the dataset</li>
<li><strong>npt</strong> (<em>int or (int, int)</em>) &#8211; number of points in the the output pattern</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array with masked pixel (1=masked)</li>
<li><strong>pos0_range</strong> (<em>(float, float)</em>) &#8211; range in radial dimension</li>
<li><strong>pos1_range</strong> (<em>(float, float)</em>) &#8211; range in azimuthal dimension</li>
<li><strong>mask_checksum</strong> (<em>int (or anything else ...)</em>) &#8211; checksum of the mask buffer</li>
<li><strong>unit</strong> (<em>pyFAI.units.Enum</em>) &#8211; use to propagate the LUT object for further checkings</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This method is called when a look-up table needs to be set-up.
The <em>shape</em> parameter, correspond to the shape of the original
datatset. It is possible to customize the number of point of
the output histogram with the <em>npt</em> parameter which can be
either an integer for an 1D integration or a 2-tuple of
integer in case of a 2D integration. The LUT will have a
different shape: (npt, lut_max_size), the later parameter
being calculated during the instanciation of the splitBBoxLUT
class.</p>
<p>It is possible to prepare the LUT with a predefine
<em>mask</em>. This operation can speedup the computation of the
later integrations. Instead of applying the patch on the
dataset, it is taken into account during the histogram
computation. If provided the <em>mask_checksum</em> prevent the
re-calculation of the mask. When the mask changes, its
checksum is used to reset (or not) the LUT (which is a very
time consuming operation !)</p>
<p>It is also possible to restrain the range of the 1D or 2D
pattern with the <em>pos1_range</em> and <em>pos2_range</em>.</p>
<p>The <em>unit</em> parameter is just propagated to the LUT integrator
for further checkings: The aim is to prevent an integration to
be performed in 2th-space when the LUT was setup in q space.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd">
<tt class="descname">xrpd</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2">
<tt class="descname">xrpd2</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_histogram">
<tt class="descname">xrpd2_histogram</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_numpy">
<tt class="descname">xrpd2_numpy</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_splitBBox">
<tt class="descname">xrpd2_splitBBox</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_splitBBox" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_splitPixel">
<tt class="descname">xrpd2_splitPixel</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_splitPixel" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_CSR_OCL">
<tt class="descname">xrpd_CSR_OCL</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_CSR_OCL" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_LUT">
<tt class="descname">xrpd_LUT</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_LUT" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_LUT_OCL">
<tt class="descname">xrpd_LUT_OCL</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_LUT_OCL" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_OpenCL">
<tt class="descname">xrpd_OpenCL</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_OpenCL" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_cython">
<tt class="descname">xrpd_cython</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_cython" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_numpy">
<tt class="descname">xrpd_numpy</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_splitBBox">
<tt class="descname">xrpd_splitBBox</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_splitBBox" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_splitPixel">
<tt class="descname">xrpd_splitPixel</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_splitPixel" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.multi_geometry">
<span id="multi-geometry-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">multi_geometry</span></tt> Module<a class="headerlink" href="#module-pyFAI.multi_geometry" title="Permalink to this headline">¶</a></h1>
<p>Module for treating simultaneously multiple detector configuration
within a single integration</p>
<dl class="class">
<dt id="pyFAI.multi_geometry.MultiGeometry">
<em class="property">class </em><tt class="descclassname">pyFAI.multi_geometry.</tt><tt class="descname">MultiGeometry</tt><big>(</big><em>ais</em>, <em>unit='2th_deg'</em>, <em>radial_range=(0</em>, <em>180)</em>, <em>azimuth_range=(-180</em>, <em>180)</em>, <em>wavelength=None</em>, <em>empty=0.0</em>, <em>chi_disc=180</em><big>)</big><a class="headerlink" href="#pyFAI.multi_geometry.MultiGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This is an Azimuthal integrator containing multiple geometries (when
the detector is on a goniometer arm)</p>
<dl class="method">
<dt id="pyFAI.multi_geometry.MultiGeometry.__init__">
<tt class="descname">__init__</tt><big>(</big><em>ais</em>, <em>unit='2th_deg'</em>, <em>radial_range=(0</em>, <em>180)</em>, <em>azimuth_range=(-180</em>, <em>180)</em>, <em>wavelength=None</em>, <em>empty=0.0</em>, <em>chi_disc=180</em><big>)</big><a class="headerlink" href="#pyFAI.multi_geometry.MultiGeometry.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor of the multi-geometry integrator
:param ais: list of azimuthal integrators
:param radial_range: common range for integration
:param azimuthal_range: common range for integration
:param empty: value for empty pixels
:param chi_disc: if 0, set the chi_discontinuity at</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.multi_geometry.MultiGeometry.integrate1d">
<tt class="descname">integrate1d</tt><big>(</big><em>lst_data</em>, <em>npt=1800</em>, <em>correctSolidAngle=True</em>, <em>lst_variance=None</em>, <em>error_model=None</em>, <em>polarization_factor=None</em>, <em>monitors=None</em>, <em>all=False</em>, <em>lst_mask=None</em>, <em>lst_flat=None</em><big>)</big><a class="headerlink" href="#pyFAI.multi_geometry.MultiGeometry.integrate1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform 1D azimuthal integration</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lst_data</strong> &#8211; list of numpy array</li>
<li><strong>npt</strong> &#8211; number of points int the integration</li>
<li><strong>correctSolidAngle</strong> &#8211; correct for solid angle (all processing are then done in absolute solid angle !)</li>
<li><strong>lst_variance</strong> (<em>list of ndarray</em>) &#8211; list of array containing the variance of the data. If not available, no error propagation is done</li>
<li><strong>error_model</strong> (<em>str</em>) &#8211; When the variance is unknown, an error model can be given: &#8220;poisson&#8221; (variance = I), &#8220;azimuthal&#8221; (variance = (I-&lt;I&gt;)^2)</li>
<li><strong>polarization_factor</strong> &#8211; Apply polarization correction ? is None: not applies. Else provide a value from -1 to +1</li>
<li><strong>monitors</strong> &#8211; normalization monitors value (list of floats)</li>
<li><strong>all</strong> &#8211; return a dict with all information in it (deprecated, please refer to the documentation of Integrate1dResult).</li>
<li><strong>lst_mask</strong> &#8211; numpy.Array or list of numpy.array which mask the lst_data.</li>
<li><strong>lst_flat</strong> &#8211; numpy.Array or list of numpy.array which flat the lst_data.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">2th/I or a dict with everything depending on &#8220;all&#8221;</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Integrate1dResult, dict</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.multi_geometry.MultiGeometry.integrate2d">
<tt class="descname">integrate2d</tt><big>(</big><em>lst_data</em>, <em>npt_rad=1800</em>, <em>npt_azim=3600</em>, <em>correctSolidAngle=True</em>, <em>lst_variance=None</em>, <em>error_model=None</em>, <em>polarization_factor=None</em>, <em>monitors=None</em>, <em>all=False</em>, <em>lst_mask=None</em>, <em>lst_flat=None</em><big>)</big><a class="headerlink" href="#pyFAI.multi_geometry.MultiGeometry.integrate2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs 2D azimuthal integration of multiples frames, one for each geometry</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lst_data</strong> &#8211; list of numpy array</li>
<li><strong>npt</strong> &#8211; number of points int the integration</li>
<li><strong>correctSolidAngle</strong> &#8211; correct for solid angle (all processing are then done in absolute solid angle !)</li>
<li><strong>lst_variance</strong> (<em>list of ndarray</em>) &#8211; list of array containing the variance of the data. If not available, no error propagation is done</li>
<li><strong>error_model</strong> (<em>str</em>) &#8211; When the variance is unknown, an error model can be given: &#8220;poisson&#8221; (variance = I), &#8220;azimuthal&#8221; (variance = (I-&lt;I&gt;)^2)</li>
<li><strong>polarization_factor</strong> &#8211; Apply polarization correction ? is None: not applies. Else provide a value from -1 to +1</li>
<li><strong>monitors</strong> &#8211; normalization monitors value (list of floats)</li>
<li><strong>all</strong> &#8211; return a dict with all information in it (deprecated, please refer to the documentation of Integrate2dResult).</li>
<li><strong>lst_mask</strong> &#8211; numpy.Array or list of numpy.array which mask the lst_data.</li>
<li><strong>lst_flat</strong> &#8211; numpy.Array or list of numpy.array which flat the lst_data.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">I/2th/chi or a dict with everything depending on &#8220;all&#8221;</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Integrate2dResult, dict</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.multi_geometry.MultiGeometry.set_wavelength">
<tt class="descname">set_wavelength</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.multi_geometry.MultiGeometry.set_wavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the wavelength of a group of azimuthal integrators</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.integrate_widget">
<span id="integrate-widget-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">integrate_widget</span></tt> Module<a class="headerlink" href="#module-pyFAI.integrate_widget" title="Permalink to this headline">¶</a></h1>
<p>pyFAI-integrate</p>
<p>A graphical tool for performing azimuthal integration on series of files.</p>
<dl class="class">
<dt id="pyFAI.integrate_widget.AIWidget">
<em class="property">class </em><tt class="descclassname">pyFAI.integrate_widget.</tt><tt class="descname">AIWidget</tt><big>(</big><em>input_data=None</em>, <em>output_path=None</em>, <em>output_format=None</em>, <em>slow_dim=None</em>, <em>fast_dim=None</em>, <em>json_file='.azimint.json'</em><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">PyQt4.QtGui.QWidget</span></tt></p>
<dl class="attribute">
<dt id="pyFAI.integrate_widget.AIWidget.URL">
<tt class="descname">URL</tt><em class="property"> = 'http://pyfai.readthedocs.org/en/latest/man/pyFAI-integrate.html'</em><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.URL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.__init__">
<tt class="descname">__init__</tt><big>(</big><em>input_data=None</em>, <em>output_path=None</em>, <em>output_format=None</em>, <em>slow_dim=None</em>, <em>fast_dim=None</em>, <em>json_file='.azimint.json'</em><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.assign_unit">
<tt class="descname">assign_unit</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.assign_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>assign unit to the corresponding widget</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.detector_changed">
<tt class="descname">detector_changed</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.detector_changed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.die">
<tt class="descname">die</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.die" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.dump">
<tt class="descname">dump</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump the status of the current widget to a file in JSON</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; path where to save the config</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict with configuration</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.get_config">
<tt class="descname">get_config</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.get_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the configuration of the plugin and returns it as a dictionary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict with all information.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.get_method">
<tt class="descname">get_method</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.get_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the method name for azimuthal intgration</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.help">
<tt class="descname">help</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.help" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.openCL_changed">
<tt class="descname">openCL_changed</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.openCL_changed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.platform_changed">
<tt class="descname">platform_changed</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.platform_changed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.proceed">
<tt class="descname">proceed</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.proceed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.restore">
<tt class="descname">restore</tt><big>(</big><em>filename='.azimint.json'</em><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.restore" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore from JSON file the status of the current widget</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>str</em>) &#8211; path where the config was saved</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.save_config">
<tt class="descname">save_config</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.save_config" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.select_darkcurrent">
<tt class="descname">select_darkcurrent</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.select_darkcurrent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.select_flatfield">
<tt class="descname">select_flatfield</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.select_flatfield" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.select_maskfile">
<tt class="descname">select_maskfile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.select_maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.select_ponifile">
<tt class="descname">select_ponifile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.select_ponifile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.select_splinefile">
<tt class="descname">select_splinefile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.select_splinefile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.setStackDataObject">
<tt class="descname">setStackDataObject</tt><big>(</big><em>stack</em>, <em>stack_name=None</em><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.setStackDataObject" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.set_config">
<tt class="descname">set_config</tt><big>(</big><em>dico</em><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.set_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the widget from its description</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dico</strong> (<em>dict</em>) &#8211; dictionary with description of the widget</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.set_input_data">
<tt class="descname">set_input_data</tt><big>(</big><em>stack</em>, <em>stack_name=None</em><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.set_input_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.set_ponifile">
<tt class="descname">set_ponifile</tt><big>(</big><em>ponifile=None</em><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.set_ponifile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.set_validators">
<tt class="descname">set_validators</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.set_validators" title="Permalink to this definition">¶</a></dt>
<dd><p>Set all validators for text entries</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.geometry">
<span id="geometry-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">geometry</span></tt> Module<a class="headerlink" href="#module-pyFAI.geometry" title="Permalink to this headline">¶</a></h1>
<p>This modules contrains only one (large) class in charge of:</p>
<ul class="simple">
<li>calculating the geometry, i.e. the position in the detector space of each pixel of the detector</li>
<li>manages caches to store intermediate results</li>
</ul>
<dl class="class">
<dt id="pyFAI.geometry.Geometry">
<em class="property">class </em><tt class="descclassname">pyFAI.geometry.</tt><tt class="descname">Geometry</tt><big>(</big><em>dist=1</em>, <em>poni1=0</em>, <em>poni2=0</em>, <em>rot1=0</em>, <em>rot2=0</em>, <em>rot3=0</em>, <em>pixel1=None</em>, <em>pixel2=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class is an azimuthal integrator based on P. Boesecke&#8217;s geometry and
histogram algorithm by Manolo S. del Rio and V.A Sole</p>
<p>Detector is assumed to be corrected from &#8220;raster orientation&#8221; effect.
It is not addressed here but rather in the Detector object or at read time.
Considering there is no tilt:</p>
<ul class="simple">
<li>Detector fast dimension (dim2) is supposed to be horizontal
(dimension X of the image)</li>
<li>Detector slow dimension (dim1) is supposed to be vertical, upwards
(dimension Y of the image)</li>
<li>The third dimension is chose such as the referential is
orthonormal, so dim3 is along incoming X-ray beam</li>
</ul>
<p>Demonstration of the equation done using Mathematica:</p>
<div class="highlight-mathematica"><div class="highlight"><pre>Axis 1 is allong first dimension of detector (when not tilted), this is the slow dimension of the image array in C or Y
In[5]:= x1={1,0,0}
Out[5]= {1,0,0}
 Axis 2 is allong second dimension of detector (when not tilted), this is the fast dimension of the image in C or X
In[6]:= x2={0,1,0}
Out[6]= {0,1,0}
Axis 3 is along the incident X-Ray beam
In[7]:= x3={0,0,1}
Out[7]= {0,0,1}
In[9]:= id3={x1,x2,x3}
Out[9]= {{1,0,0},{0,1,0},{0,0,1}}
In[10]:= {{1,0,0},{0,1,0},{0,0,1}}
Out[10]= {{1,0,0},{0,1,0},{0,0,1}}
In[11]:= rotM1=RotationMatrix[rot1,x1]
Out[11]= {{1,0,0},{0,Cos[rot1],-Sin[rot1]},{0,Sin[rot1],Cos[rot1]}}
In[12]:= rotM2 =  RotationMatrix[rot2,x2]
Out[12]= {{Cos[rot2],0,Sin[rot2]},{0,1,0},{-Sin[rot2],0,Cos[rot2]}}
In[13]:= rotM3 =  RotationMatrix[rot3,x3]
Out[13]= {{Cos[rot3],-Sin[rot3],0},{Sin[rot3],Cos[rot3],0},{0,0,1}}
Rotations of the detector are applied first Rot around axis 1, then axis 2 and finally around axis 3
In[14]:= R=rotM3.rotM2.rotM1
Out[14]= {{Cos[rot2] Cos[rot3],Cos[rot3] Sin[rot1] Sin[rot2]-Cos[rot1] Sin[rot3],Cos[rot1] Cos[rot3] Sin[rot2]+Sin[rot1] Sin[rot3]},{Cos[rot2] Sin[rot3],Cos[rot1] Cos[rot3]+Sin[rot1] Sin[rot2] Sin[rot3],-Cos[rot3] Sin[rot1]+Cos[rot1] Sin[rot2] Sin[rot3]},{-Sin[rot2],Cos[rot2] Sin[rot1],Cos[rot1] Cos[rot2]}}
In[15]:= CForm[R.x1]

Out[15]//CForm=
List(Cos(rot2)*Cos(rot3),Cos(rot2)*Sin(rot3),-Sin(rot2))
In[16]:= CForm[R.x2]

Out[16]//CForm=
List(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3),Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3),Cos(rot2)*Sin(rot1))
In[17]:= CForm[R.x3]
Out[17]//CForm=
List(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3),-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3),Cos(rot1)*Cos(rot2))
In[18]:= CForm[Det[R]]
Out[18]//CForm=
Power(Cos(rot1),2)*Power(Cos(rot2),2)*Power(Cos(rot3),2) + Power(Cos(rot2),2)*Power(Cos(rot3),2)*Power(Sin(rot1),2) + Power(Cos(rot1),2)*Power(Cos(rot3),2)*Power(Sin(rot2),2) + 
   Power(Cos(rot3),2)*Power(Sin(rot1),2)*Power(Sin(rot2),2) + Power(Cos(rot1),2)*Power(Cos(rot2),2)*Power(Sin(rot3),2) + Power(Cos(rot2),2)*Power(Sin(rot1),2)*Power(Sin(rot3),2) + 
   Power(Cos(rot1),2)*Power(Sin(rot2),2)*Power(Sin(rot3),2) + Power(Sin(rot1),2)*Power(Sin(rot2),2)*Power(Sin(rot3),2)
In[13]:=
Any pixel on detector plan at coordianate (d1, d2) in meters. Detector is at z=L

In[22]:= P={d1,d2,L}
CForm[R.P]

Out[22]= {d1,d2,L}
Out[23]//CForm=
List(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),
   d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2))
In[24]:= t1 = R.P.x1
CForm[t1]
Out[24]= d1 Cos[rot2] Cos[rot3]+d2 (Cos[rot3] Sin[rot1] Sin[rot2]-Cos[rot1] Sin[rot3])+L (Cos[rot1] Cos[rot3] Sin[rot2]+Sin[rot1] Sin[rot3])
Out[25]//CForm=
d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3))
In[26]:= t2 = R.P.x2
CForm[t2]
Out[26]= d1 Cos[rot2] Sin[rot3]+L (-Cos[rot3] Sin[rot1]+Cos[rot1] Sin[rot2] Sin[rot3])+d2 (Cos[rot1] Cos[rot3]+Sin[rot1] Sin[rot2] Sin[rot3])
Out[27]//CForm=
d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3))
In[28]:= t3=R.P.x3
CForm[t3]
Out[28]= L Cos[rot1] Cos[rot2]+d2 Cos[rot2] Sin[rot1]-d1 Sin[rot2]
Out[29]//CForm=
L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2)
Distance sample to detector point (d1,d2)
(no Mathematica translations)
GraphicsBox[
TagBox[RasterBox[CompressedData[&quot;
1:eJxtUstqU1EUDY2iUdSOnBcERwGHDgQf+YNGOrAQSEBBBwlWQfsDcVKsI4sf
IAQnGSQtCQ4yyfvVvO69SW7J+9W8GtIkg8SwXfuQSpFu2Pdxzl5rr7XP2bDY
Nt+saTSaDzfx2DR/er6zY941XsPPi92Pry1afNxdJS9ejuFwqJNl+XMsFstE
o1HijEQio1Qq9bPZbD7SXBHtdnsjGAxK+Xyeut0uTadTms1mNBgMqFwuUyKR
+APOd5cxo9HoHjBqqVSis7Mzms/nlMlkyOfziX/GdzodSiaTpCjKqwscar6o
qkq9Xo/Oz89pb2+PjEYj2Ww22t7epn6/L/DcF/wdt9u9Di4tPAxarZbgZKzd
bmde4jCZTORyuUTPWq1G8Erwb0HdQ2gn+KZ6vU6np6eCm8PhcNDW1hZVKhWx
xvusH/P6jronwVCIcpJE2VxOvLvQ5Q8EyGAwkMfjERilUBCYCGrj8fiv8Xj8
IIAa1iVJMsnIIWZ4dHRE+1/3hW72pUgK5cALTzyfbzwX4Kt5WSb15IRU8M5w
BgcHB2S1WqkL3TxntVgU3CH0g7+XjGs0Gm/D4bDgZS/QQH6/n5xOp+iH/X8z
QY+0Xq9fZ9xyudRKknTIGpibZzOZTMQMcYeoWq1SNptlzMzr9T4G5PbFGS4W
C12hUHDwbNlHEbr4TMEn7hvW69DwDKV3kGv/3zfUPU2n0z+g6Rj+j/H+jXxv
Npvvr/por7qnq+C9G8hbq9Qhr18u+AttYAMa
&quot;], {{0, 14}, {14, 0}}, {0, 255},
ColorFunction-&gt;RGBColor],
BoxForm`ImageTag[&quot;Byte&quot;, ColorSpace -&gt; &quot;RGB&quot;, Interleaving -&gt; True],
Selectable-&gt;False],
BaseStyle-&gt;&quot;ImageGraphics&quot;,
ImageSize-&gt;Magnification[1],
ImageSizeRaw-&gt;{14, 14},
PlotRange-&gt;{{0, 14}, {0, 14}}]


In[30]:= dist = Norm[R.P]
CForm[dist]
Out[30]= √(Abs[L Cos[rot1] Cos[rot2]+d2 Cos[rot2] Sin[rot1]-d1 Sin[rot2]]^2+Abs[d1 Cos[rot2] Cos[rot3]+d2 (Cos[rot3] Sin[rot1] Sin[rot2]-Cos[rot1] Sin[rot3])+L (Cos[rot1] Cos[rot3] Sin[rot2]+Sin[rot1] Sin[rot3])]^2+Abs[d1 Cos[rot2] Sin[rot3]+L (-Cos[rot3] Sin[rot1]+Cos[rot1] Sin[rot2] Sin[rot3])+d2 (Cos[rot1] Cos[rot3]+Sin[rot1] Sin[rot2] Sin[rot3])]^2)
Out[31]//CForm=
Sqrt(Power(Abs(L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2)),2) + Power(Abs(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + 
       L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3))),2) + Power(Abs(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3))),
     2))
cos(2theta) can be defined as (R.P component along x3) over the distance |R.P|
In[32]:= tthc = ArcCos [-(R.P).x3/Norm[R.P]]
CForm[tthc]

Out[32]= ArcCos[(-L Cos[rot1] Cos[rot2]-d2 Cos[rot2] Sin[rot1]+d1 Sin[rot2])/(√(Abs[L Cos[rot1] Cos[rot2]+d2 Cos[rot2] Sin[rot1]-d1 Sin[rot2]]^2+Abs[d1 Cos[rot2] Cos[rot3]+d2 (Cos[rot3] Sin[rot1] Sin[rot2]-Cos[rot1] Sin[rot3])+L (Cos[rot1] Cos[rot3] Sin[rot2]+Sin[rot1] Sin[rot3])]^2+Abs[d1 Cos[rot2] Sin[rot3]+L (-Cos[rot3] Sin[rot1]+Cos[rot1] Sin[rot2] Sin[rot3])+d2 (Cos[rot1] Cos[rot3]+Sin[rot1] Sin[rot2] Sin[rot3])]^2))]
Out[33]//CForm=
ArcCos((-(L*Cos(rot1)*Cos(rot2)) - d2*Cos(rot2)*Sin(rot1) + d1*Sin(rot2))/
    Sqrt(Power(Abs(L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2)),2) + Power(Abs(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + 
         L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3))),2) + Power(Abs(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + 
         d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3))),2)))



In[41]:= ttht = ArcTan[t3,Sqrt[t1^2 + t2^2]]

CForm[ttht]


Out[41]= ArcTan[L Cos[rot1] Cos[rot2]+d2 Cos[rot2] Sin[rot1]-d1 Sin[rot2],√((d1 Cos[rot2] Cos[rot3]+d2 (Cos[rot3] Sin[rot1] Sin[rot2]-Cos[rot1] Sin[rot3])+L (Cos[rot1] Cos[rot3] Sin[rot2]+Sin[rot1] Sin[rot3]))^2+(d1 Cos[rot2] Sin[rot3]+L (-Cos[rot3] Sin[rot1]+Cos[rot1] Sin[rot2] Sin[rot3])+d2 (Cos[rot1] Cos[rot3]+Sin[rot1] Sin[rot2] Sin[rot3]))^2)]
Out[42]//CForm=
ArcTan(L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2),Sqrt(Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),
      2) + Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2)))
Tangeant of angle chi is defined as (R.P component along x1) over (R.P component along x2). Arctan2 should be used in actual calculation
In[36]:= chi =ArcTan[t1  , t2]
CForm[chi]
Out[36]= ArcTan[d1 Cos[rot2] Cos[rot3]+d2 (Cos[rot3] Sin[rot1] Sin[rot2]-Cos[rot1] Sin[rot3])+L (Cos[rot1] Cos[rot3] Sin[rot2]+Sin[rot1] Sin[rot3]),d1 Cos[rot2] Sin[rot3]+L (-Cos[rot3] Sin[rot1]+Cos[rot1] Sin[rot2] Sin[rot3])+d2 (Cos[rot1] Cos[rot3]+Sin[rot1] Sin[rot2] Sin[rot3])]
Out[37]//CForm=
ArcTan(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),
   d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)))
Coodinates of the Point of Normal Incidence

In[38]:= PONI = R.{0,0,L}
CForm[PONI]
Out[38]= {L (Cos[rot1] Cos[rot3] Sin[rot2]+Sin[rot1] Sin[rot3]),L (-Cos[rot3] Sin[rot1]+Cos[rot1] Sin[rot2] Sin[rot3]),L Cos[rot1] Cos[rot2]}
Out[39]//CForm=
List(L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)),L*Cos(rot1)*Cos(rot2))
Derivatives of 2Theta
In[43]:= CForm[D[ttht,d1]]
Out[43]//CForm=
((L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2))*(2*Cos(rot2)*Cos(rot3)*(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + 
           L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3))) + 2*Cos(rot2)*Sin(rot3)*
         (d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)))))/
    (2.*Sqrt(Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),2) + 
        Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2))*
      (Power(L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2),2) + Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + 
          L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),2) + Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2)))
     + (Sin(rot2)*Sqrt(Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),2) + 
        Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2)))/
    (Power(L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2),2) + Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),
       2) + Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2))
In[44]:= CForm[D[ttht,d2]]

Out[44]//CForm=
((L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2))*(2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3))*
         (d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3))) + 
        2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3))*(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)))))/
    (2.*Sqrt(Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),2) + 
        Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2))*
      (Power(L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2),2) + Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + 
          L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),2) + Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2)))
     - (Cos(rot2)*Sin(rot1)*Sqrt(Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),2) + 
        Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2)))/
    (Power(L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2),2) + Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),
       2) + Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2))
In[47]:= CForm[D[ttht,L]]
Out[47]//CForm=
((L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2))*(2*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3))*
         (d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3))) + 
        2*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3))*(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)))))/
    (2.*Sqrt(Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),2) + 
        Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2))*
      (Power(L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2),2) + Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + 
          L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),2) + Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2)))
     - (Cos(rot1)*Cos(rot2)*Sqrt(Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),2) + 
        Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2)))/
    (Power(L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2),2) + Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),
       2) + Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2))
In[48]:= CForm[D[ttht,rot1]]
Out[48]//CForm=
((L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2))*(2*(L*(-(Cos(rot3)*Sin(rot1)*Sin(rot2)) + Cos(rot1)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)))*
         (d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3))) + 
        2*(d2*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + L*(-(Cos(rot1)*Cos(rot3)) - Sin(rot1)*Sin(rot2)*Sin(rot3)))*
         (d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)))))/
    (2.*Sqrt(Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),2) + 
        Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2))*
      (Power(L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2),2) + Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + 
          L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),2) + Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2)))
     - ((d2*Cos(rot1)*Cos(rot2) - L*Cos(rot2)*Sin(rot1))*Sqrt(Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),2) + 
        Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2)))/
    (Power(L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2),2) + Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),
       2) + Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2))
In[49]:= CForm[D[ttht,rot2]]
Out[49]//CForm=
((L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2))*(2*(L*Cos(rot1)*Cos(rot2)*Cos(rot3) + d2*Cos(rot2)*Cos(rot3)*Sin(rot1) - d1*Cos(rot3)*Sin(rot2))*
         (d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3))) + 
        2*(L*Cos(rot1)*Cos(rot2)*Sin(rot3) + d2*Cos(rot2)*Sin(rot1)*Sin(rot3) - d1*Sin(rot2)*Sin(rot3))*
         (d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)))))/
    (2.*Sqrt(Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),2) + 
        Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2))*
      (Power(L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2),2) + Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + 
          L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),2) + Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2)))
     - ((-(d1*Cos(rot2)) - L*Cos(rot1)*Sin(rot2) - d2*Sin(rot1)*Sin(rot2))*Sqrt(Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + 
          L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),2) + Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2)))
     /(Power(L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2),2) + Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + 
        L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),2) + Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2))
In[50]:= CForm[D[ttht,rot3]]
Out[50]//CForm=
((L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2))*(2*(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)))*
        (-(d1*Cos(rot2)*Sin(rot3)) + L*(Cos(rot3)*Sin(rot1) - Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(-(Cos(rot1)*Cos(rot3)) - Sin(rot1)*Sin(rot2)*Sin(rot3))) + 
       2*(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)))*
        (d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)))))/
   (2.*Sqrt(Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),2) + 
       Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2))*
     (Power(L*Cos(rot1)*Cos(rot2) + d2*Cos(rot2)*Sin(rot1) - d1*Sin(rot2),2) + Power(d1*Cos(rot2)*Cos(rot3) + d2*(Cos(rot3)*Sin(rot1)*Sin(rot2) - Cos(rot1)*Sin(rot3)) + 
         L*(Cos(rot1)*Cos(rot3)*Sin(rot2) + Sin(rot1)*Sin(rot3)),2) + Power(d1*Cos(rot2)*Sin(rot3) + L*(-(Cos(rot3)*Sin(rot1)) + Cos(rot1)*Sin(rot2)*Sin(rot3)) + d2*(Cos(rot1)*Cos(rot3) + Sin(rot1)*Sin(rot2)*Sin(rot3)),2)))
</pre></div>
</div>
<dl class="method">
<dt id="pyFAI.geometry.Geometry.__init__">
<tt class="descname">__init__</tt><big>(</big><em>dist=1</em>, <em>poni1=0</em>, <em>poni2=0</em>, <em>rot1=0</em>, <em>rot2=0</em>, <em>rot3=0</em>, <em>pixel1=None</em>, <em>pixel2=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dist</strong> &#8211; distance sample - detector plan (orthogonal distance, not along the beam), in meter.</li>
<li><strong>poni1</strong> &#8211; coordinate of the point of normal incidence along the detector&#8217;s first dimension, in meter</li>
<li><strong>poni2</strong> &#8211; coordinate of the point of normal incidence along the detector&#8217;s second dimension, in meter</li>
<li><strong>rot1</strong> &#8211; first rotation from sample ref to detector&#8217;s ref, in radians</li>
<li><strong>rot2</strong> &#8211; second rotation from sample ref to detector&#8217;s ref, in radians</li>
<li><strong>rot3</strong> &#8211; third rotation from sample ref to detector&#8217;s ref, in radians</li>
<li><strong>pixel1</strong> (<em>float</em>) &#8211; Deprecated. Pixel size of the fist dimension of the detector,  in meter.
If both pixel1 and pixel2 are not None, detector pixel size is overwritten.
Prefer defining the detector pixel size on the provided detector object.
Prefer defining the detector pixel size on the provided detector
object (<tt class="docutils literal"><span class="pre">detector.pixel1</span> <span class="pre">=</span> <span class="pre">5e-6</span></tt>).</li>
<li><strong>pixel2</strong> (<em>float</em>) &#8211; Deprecated. Pixel size of the second dimension of the detector,  in meter.
If both pixel1 and pixel2 are not None, detector pixel size is overwritten.
Prefer defining the detector pixel size on the provided detector
object (<tt class="docutils literal"><span class="pre">detector.pixel2</span> <span class="pre">=</span> <span class="pre">5e-6</span></tt>).</li>
<li><strong>splineFile</strong> (<em>str</em>) &#8211; Deprecated. File containing the geometric distortion of the detector.
If not None, pixel1 and pixel2 are ignored and detector spline is overwritten.
Prefer defining the detector spline manually
(<tt class="docutils literal"><span class="pre">detector.splineFile</span> <span class="pre">=</span> <span class="pre">&quot;file.spline&quot;</span></tt>).</li>
<li><strong>detector</strong> (<em>str or pyFAI.Detector</em>) &#8211; name of the detector or Detector instance. String
description is deprecated. Prefer using the result of the detector
factory: <tt class="docutils literal"><span class="pre">pyFAI.detector_factory(&quot;eiger4m&quot;)</span></tt></li>
<li><strong>wavelength</strong> (<em>float</em>) &#8211; Wave length used in meter</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.array_from_unit">
<tt class="descname">array_from_unit</tt><big>(</big><em>shape=None</em>, <em>typ='center'</em>, <em>unit=2th_deg</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.array_from_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array of position in different dimentions (R, Q,
2Theta)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>shape</strong> (<em>ndarray.shape</em>) &#8211; shape of the expected array</li>
<li><strong>typ</strong> (<em>str</em>) &#8211; &#8220;center&#8221;, &#8220;corner&#8221; or &#8220;delta&#8221;</li>
<li><strong>unit</strong> (<em>pyFAI.units.Enum</em>) &#8211; can be Q, TTH, R for now</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">R, Q or 2Theta array depending on unit</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.calc_pos_zyx">
<tt class="descname">calc_pos_zyx</tt><big>(</big><em>d0=None</em>, <em>d1=None</em>, <em>d2=None</em>, <em>param=None</em>, <em>corners=False</em>, <em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.calc_pos_zyx" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of a set of points in space in the sample&#8217;s centers referential.</p>
<p>This is usually used for calculating the pixel position in space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d0</strong> &#8211; altitude on the point compared to the detector (i.e. z), may be None</li>
<li><strong>d1</strong> &#8211; position on the detector along the slow dimention (i.e. y)</li>
<li><strong>d2</strong> &#8211; position on the detector along the fastest dimention (i.e. x)</li>
<li><strong>corners</strong> &#8211; return positions on the corners (instead of center)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">3-tuple of nd-array, with dim0=along the beam,
dim1=along slowest dimension
dim2=along fastest dimension</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.calc_transmission">
<tt class="descname">calc_transmission</tt><big>(</big><em>t0</em>, <em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.calc_transmission" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the absorption correction for a phosphor screen or a scintillator
from t0, the normal transmission of the screen.</p>
<div class="math">
<p><img src="../_images/math/cce2c792ad404677352aee499edcf96e6c8ae429.png" alt="Icor = \frac{Iobs(1-t0)}{1-exp(ln(t0)/cos(incidence))}

let_t = \frac{1-exp(ln(t0)/cos(incidence))}{1 - t0}"/></p>
</div><p>See reference on:
J. Appl. Cryst. (2002). 35, 356–359 G. Wu et al.  CCD phosphor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>t0</strong> &#8211; value of the normal transmission (from 0 to 1)</li>
<li><strong>shape</strong> &#8211; shape of the array</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">actual</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.calcfrom1d">
<tt class="descname">calcfrom1d</tt><big>(</big><em>tth</em>, <em>I</em>, <em>shape=None</em>, <em>mask=None</em>, <em>dim1_unit=2th_deg</em>, <em>correctSolidAngle=True</em>, <em>dummy=0.0</em>, <em>polarization_factor=None</em>, <em>dark=None</em>, <em>flat=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.calcfrom1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a 2D image from a 1D integrated profile</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tth</strong> &#8211; 1D array with radial unit</li>
<li><strong>I</strong> &#8211; scattering intensity</li>
<li><strong>shape</strong> &#8211; shape of the image (if not defined by the detector)</li>
<li><strong>dim1_unit</strong> &#8211; unit for the &#8220;tth&#8221; array</li>
<li><strong>correctSolidAngle</strong> &#8211; </li>
<li><strong>dummy</strong> &#8211; value for masked pixels</li>
<li><strong>polarization_factor</strong> &#8211; set to true to use previously used value</li>
<li><strong>dark</strong> &#8211; dark current correction</li>
<li><strong>flat</strong> &#8211; flatfield corrction</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2D image reconstructed</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.center_array">
<tt class="descname">center_array</tt><big>(</big><em>shape=None</em>, <em>unit='2th'</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.center_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 2D array of the given shape with (i,j) (radial
angle ) for all elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> (<em>2-tuple of integer</em>) &#8211; expected shape</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">3d array with shape=(*shape,4,2) the two elements are:
- dim3[0]: radial angle 2th, q, r...
- dim3[1]: azimuthal angle chi</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.chi">
<tt class="descname">chi</tt><big>(</big><em>d1</em>, <em>d2</em>, <em>path='cython'</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.chi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the chi (azimuthal angle) for the centre of a pixel
at coordinate d1,d2 which in the lab ref has coordinate:</p>
<p>X1 = p1*cos(rot2)*cos(rot3) + p2*(cos(rot3)*sin(rot1)*sin(rot2) - cos(rot1)*sin(rot3)) -  L*(cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3))
X2 = p1*cos(rot2)*sin(rot3) - L*(-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3)) +  p2*(cos(rot1)*cos(rot3) + sin(rot1)*sin(rot2)*sin(rot3))
X3 = -(L*cos(rot1)*cos(rot2)) + p2*cos(rot2)*sin(rot1) - p1*sin(rot2)
hence tan(Chi) =  X2 / X1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>float or array of them</em>) &#8211; pixel coordinate along the 1st dimention (C convention)</li>
<li><strong>d2</strong> (<em>float or array of them</em>) &#8211; pixel coordinate along the 2nd dimention (C convention)</li>
<li><strong>path</strong> &#8211; can be &#8220;tan&#8221; (i.e via numpy) or &#8220;cython&#8221;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">chi, the azimuthal angle in rad</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.chiArray">
<tt class="descname">chiArray</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.chiArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array of azimuthal angle chi(i,j) for all elements in the detector.</p>
<p>Azimuthal angles are in radians</p>
<p>Nota: Refers to the pixel centers !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; the shape of the chi array</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the chi array as numpy.ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.chi_corner">
<tt class="descname">chi_corner</tt><big>(</big><em>d1</em>, <em>d2</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.chi_corner" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the chi (azimuthal angle) for the corner of a pixel
at coordinate d1,d2 which in the lab ref has coordinate:</p>
<p>X1 = p1*cos(rot2)*cos(rot3) + p2*(cos(rot3)*sin(rot1)*sin(rot2) - cos(rot1)*sin(rot3)) -  L*(cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3))
X2 = p1*cos(rot2)*sin(rot3) - L*(-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3)) +  p2*(cos(rot1)*cos(rot3) + sin(rot1)*sin(rot2)*sin(rot3))
X3 = -(L*cos(rot1)*cos(rot2)) + p2*cos(rot2)*sin(rot1) - p1*sin(rot2)
hence tan(Chi) =  X2 / X1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>float or array of them</em>) &#8211; pixel coordinate along the 1st dimention (C convention)</li>
<li><strong>d2</strong> (<em>float or array of them</em>) &#8211; pixel coordinate along the 2nd dimention (C convention)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">chi, the azimuthal angle in rad</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.chia">
<tt class="descname">chia</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.chia" title="Permalink to this definition">¶</a></dt>
<dd><p>chi array in cache</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.cornerArray">
<tt class="descname">cornerArray</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.cornerArray" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.cornerQArray">
<tt class="descname">cornerQArray</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.cornerQArray" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.cornerRArray">
<tt class="descname">cornerRArray</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.cornerRArray" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.cornerRd2Array">
<tt class="descname">cornerRd2Array</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.cornerRd2Array" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.corner_array">
<tt class="descname">corner_array</tt><big>(</big><em>shape=None</em>, <em>unit=None</em>, <em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.corner_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 3D array of the given shape with (i,j) (radial
angle 2th, azimuthal angle chi ) for all elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> (<em>2-tuple of integer</em>) &#8211; expected shape</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">3d array with shape=(*shape,4,2) the two elements are:
- dim3[0]: radial angle 2th, q, r...
- dim3[1]: azimuthal angle chi</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.correct_SA_spline">
<tt class="descname">correct_SA_spline</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.correct_SA_spline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.cosIncidance">
<tt class="descname">cosIncidance</tt><big>(</big><em>d1</em>, <em>d2</em>, <em>path='cython'</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.cosIncidance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the incidence angle (alpha) for current pixels (P).
The poni being the point of normal incidence,
it&#8217;s incidence angle is ${alpha} = 0$ hence $cos({alpha}) = 1$</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> &#8211; 1d or 2d set of points in pixel coord</li>
<li><strong>d2</strong> &#8211; 1d or 2d set of points in pixel coord</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">cosine of the incidence angle</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.del_chia">
<tt class="descname">del_chia</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.del_chia" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.del_dssa">
<tt class="descname">del_dssa</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.del_dssa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.del_qa">
<tt class="descname">del_qa</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.del_qa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.del_ra">
<tt class="descname">del_ra</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.del_ra" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.del_ttha">
<tt class="descname">del_ttha</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.del_ttha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.delta2Theta">
<tt class="descname">delta2Theta</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.delta2Theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 3D array of the given shape with (i,j) with the max
distance between the center and any corner in 2 theta</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; The shape of the detector array: 2-tuple of integer</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">2D-array containing the max delta angle between a pixel center and any corner in 2theta-angle (rad)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.deltaChi">
<tt class="descname">deltaChi</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.deltaChi" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 3D array of the given shape with (i,j) with the max
distance between the center and any corner in chi-angle (rad)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; The shape of the detector array: 2-tuple of integer</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">2D-array  containing the max delta angle between a pixel center and any corner in chi-angle (rad)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.deltaQ">
<tt class="descname">deltaQ</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.deltaQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 2D array of the given shape with (i,j) with the max
distance between the center and any corner in q_vector unit
(nm^-1)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; The shape of the detector array: 2-tuple of integer</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">array 2D containing the max delta Q between a pixel center and any corner in q_vector unit (nm^-1)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.deltaR">
<tt class="descname">deltaR</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.deltaR" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 2D array of the given shape with (i,j) with the max
distance between the center and any corner in radius unit (mm)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; The shape of the detector array: 2-tuple of integer</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">array 2D containing the max delta Q between a pixel center and any corner in q_vector unit (nm^-1)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.deltaRd2">
<tt class="descname">deltaRd2</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.deltaRd2" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 2D array of the given shape with (i,j) with the max
distance between the center and any corner in unit: reciprocal spacing squarred (1/nm^2)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; The shape of the detector array: 2-tuple of integer</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">array 2D containing the max delta (d*)^2 between a pixel center and any corner in reciprocal spacing squarred (1/nm^2)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.delta_array">
<tt class="descname">delta_array</tt><big>(</big><em>shape=None</em>, <em>unit='2th'</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.delta_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 2D array of the given shape with (i,j) (delta-radial
angle) for all elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> (<em>2-tuple of integer</em>) &#8211; expected shape</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">3d array with shape=(*shape,4,2) the two elements are:<ul class="simple">
<li>dim3[0]: radial angle 2th, q, r...</li>
<li>dim3[1]: azimuthal angle chi</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.diffSolidAngle">
<tt class="descname">diffSolidAngle</tt><big>(</big><em>d1</em>, <em>d2</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.diffSolidAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the solid angle of the current pixels (P) versus the PONI (C)</p>
<div class="math">
<p><img src="../_images/math/69b003fb93af8e6bb7ebd09f6756d09d6835757f.png" alt="dOmega = \frac{Omega(P)}{Omega(C)}
       = \frac{A \cdot cos(a)}{SP^2} \cdot \frac{SC^2}{A \cdot cos(0)}
       = \frac{3}{cos(a)}
       = \frac{SC^3}{SP^3}

cos(a) = \frac{SC}{SP}"/></p>
</div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> &#8211; 1d or 2d set of points</li>
<li><strong>d2</strong> &#8211; 1d or 2d set of points (same size&amp;shape as d1)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">solid angle correction array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.dist">
<tt class="descname">dist</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.dist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.dssa">
<tt class="descname">dssa</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.dssa" title="Permalink to this definition">¶</a></dt>
<dd><p>solid angle array in cache</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.getFit2D">
<tt class="descname">getFit2D</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.getFit2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Export geometry setup with the geometry of Fit2D</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict with parameters compatible with fit2D geometry</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.getPyFAI">
<tt class="descname">getPyFAI</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.getPyFAI" title="Permalink to this definition">¶</a></dt>
<dd><p>Export geometry setup with the geometry of PyFAI</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict with the parameter-set of the PyFAI geometry</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.getSPD">
<tt class="descname">getSPD</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.getSPD" title="Permalink to this definition">¶</a></dt>
<dd><p>get the SPD like parameter set: For geometry description see
Peter Boesecke J.Appl.Cryst.(2007).40, s423–s427</p>
<p>Basically the main difference with pyFAI is the order of the axis which are flipped</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dictionnary with those parameters:
SampleDistance: distance from sample to detector at the PONI (orthogonal projection)
Center_1, pixel position of the PONI along fastest axis
Center_2: pixel position of the PONI along slowest axis
Rot_1: rotation around the fastest axis (x)
Rot_2: rotation around the slowest axis (y)
Rot_3: rotation around the axis ORTHOGONAL to the detector plan
PSize_1: pixel size in meter along the fastest dimention
PSize_2: pixel size in meter along the slowst dimention
splineFile: name of the file containing the spline
BSize_1: pixel binning factor along the fastest dimention
BSize_2: pixel binning factor along the slowst dimention
WaveLength: wavelength used in meter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_chia">
<tt class="descname">get_chia</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_chia" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_correct_solid_angle_for_spline">
<tt class="descname">get_correct_solid_angle_for_spline</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_correct_solid_angle_for_spline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_dist">
<tt class="descname">get_dist</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_dist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_dssa">
<tt class="descname">get_dssa</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_dssa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_mask">
<tt class="descname">get_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_maskfile">
<tt class="descname">get_maskfile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_pixel1">
<tt class="descname">get_pixel1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_pixel1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_pixel2">
<tt class="descname">get_pixel2</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_pixel2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_poni1">
<tt class="descname">get_poni1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_poni1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_poni2">
<tt class="descname">get_poni2</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_poni2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_qa">
<tt class="descname">get_qa</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_qa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_ra">
<tt class="descname">get_ra</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_ra" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_rot1">
<tt class="descname">get_rot1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_rot1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_rot2">
<tt class="descname">get_rot2</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_rot2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_rot3">
<tt class="descname">get_rot3</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_rot3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_shape">
<tt class="descname">get_shape</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Guess what is the best shape ....</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; force this value (2-tuple of int)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">2-tuple of int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_spline">
<tt class="descname">get_spline</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_spline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_splineFile">
<tt class="descname">get_splineFile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_ttha">
<tt class="descname">get_ttha</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_ttha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_wavelength">
<tt class="descname">get_wavelength</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.load">
<tt class="descname">load</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the refined parameters from a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; name of the file to load</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.mask">
<tt class="descname">mask</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.maskfile">
<tt class="descname">maskfile</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.oversampleArray">
<tt class="descname">oversampleArray</tt><big>(</big><em>myarray</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.oversampleArray" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.pixel1">
<tt class="descname">pixel1</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.pixel1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.pixel2">
<tt class="descname">pixel2</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.pixel2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.polarization">
<tt class="descname">polarization</tt><big>(</big><em>shape=None</em>, <em>factor=None</em>, <em>axis_offset=0</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.polarization" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the polarization correction accoding to the
polarization factor:</p>
<ul class="simple">
<li>If the polarization factor is None, the correction is not applied (returns 1)</li>
<li>If the polarization factor is 0 (circular polarization), the correction correspond to (1+(cos2θ)^2)/2</li>
<li>If the polarization factor is 1 (linear horizontal polarization), there is no correction in the vertical plane  and a node at 2th=90, chi=0</li>
<li>If the polarization factor is -1 (linear vertical polarization), there is no correction in the horizontal plane and a node at 2th=90, chi=90</li>
<li>If the polarization is elliptical, the polarization factor varies between -1 and +1.</li>
</ul>
<p>The axis_offset parameter allows correction for the misalignement of the polarization plane (or ellipse main axis) and the the detector&#8217;s X axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>factor</strong> &#8211; (Ih-Iv)/(Ih+Iv): varies between 0 (no polarization) and 1 (where division by 0 could occure at 2th=90, chi=0)</li>
<li><strong>axis_offset</strong> &#8211; Angle between the polarization main axis and detector X direction (in radians !!!)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2D array with polarization correction array (intensity/polarisation)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.poni1">
<tt class="descname">poni1</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.poni1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.poni2">
<tt class="descname">poni2</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.poni2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.positionArray">
<tt class="descname">positionArray</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.positionArray" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.position_array">
<tt class="descname">position_array</tt><big>(</big><em>shape=None</em>, <em>corners=False</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.position_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array for the pixel position given the shape of the detector.</p>
<p>if corners is False, the coordinates of the center of the pixel
is returned in an array of shape: (shape[0], shape[1], 3)
where the 3 coordinates are:
* z: along incident beam,
* y: to the top/sky,
* x: towards the center of the ring</p>
<p>If is True, the corner of each pixels are then returned.
the output shape is then (shape[0], shape[1], 4, 3)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>shape</strong> &#8211; shape of the array expected</li>
<li><strong>corners</strong> &#8211; set to true to receive a (...,4,3) array of corner positions</li>
<li><strong>dtype</strong> &#8211; output format requested. Double precision is needed for fitting the geometry</li>
<li><strong>use_cython</strong> (<em>(bool)</em>) &#8211; set to false to test the Python path (slower)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">3D coodinates as nd-array of size (...,3) or (...,3) (default)</p>
</td>
</tr>
</tbody>
</table>
<p>Nota: this value is not cached and actually generated on demand (costly)</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.qArray">
<tt class="descname">qArray</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.qArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array of the given shape with q(i,j) for all
elements.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.qCornerFunct">
<tt class="descname">qCornerFunct</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.qCornerFunct" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.qFunction">
<tt class="descname">qFunction</tt><big>(</big><em>d1</em>, <em>d2</em>, <em>param=None</em>, <em>path='cython'</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.qFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the q value for the center of a given pixel (or set
of pixels) in nm-1</p>
<p>q = 4pi/lambda sin( 2theta / 2 )</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in first dimension (c order)</li>
<li><strong>d2</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in second dimension (c order)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">q in in nm^(-1)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float or array of floats.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.qa">
<tt class="descname">qa</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.qa" title="Permalink to this definition">¶</a></dt>
<dd><p>Q array in cache</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.rArray">
<tt class="descname">rArray</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.rArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array of the given shape with r(i,j) for all elements;
The radius r being  in meters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; expected shape of the detector</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">2d array of the given shape with radius in m from beam center on detector.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.rCornerFunct">
<tt class="descname">rCornerFunct</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.rCornerFunct" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.rFunction">
<tt class="descname">rFunction</tt><big>(</big><em>d1</em>, <em>d2</em>, <em>param=None</em>, <em>path='cython'</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.rFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the radius value for the center of a given pixel
(or set of pixels) in m</p>
<blockquote>
<div>r = distance to the incident beam</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in first dimension (c order)</li>
<li><strong>d2</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in second dimension (c order)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">r in in m</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float or array of floats.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.ra">
<tt class="descname">ra</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.ra" title="Permalink to this definition">¶</a></dt>
<dd><p>R array in cache</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.rd2Array">
<tt class="descname">rd2Array</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.rd2Array" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array of the given shape with (d*(i,j))^2 for all pixels.</p>
<p>d*^2 is the reciprocal spacing squared in inverse nm squared</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; expected shape of the detector</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">2d array of the given shape with reciprocal spacing squared</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.read">
<tt class="descname">read</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the refined parameters from a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; name of the file to load</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset most arrays that are cached: used when a parameter
changes.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.rot1">
<tt class="descname">rot1</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.rot1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.rot2">
<tt class="descname">rot2</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.rot2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.rot3">
<tt class="descname">rot3</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.rot3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.save">
<tt class="descname">save</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the geometry parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; name of the file where to save the parameters</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.setChiDiscAtPi">
<tt class="descname">setChiDiscAtPi</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.setChiDiscAtPi" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the position of the discontinuity of the chi axis between
-pi and +pi.  This is the default behavour</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.setChiDiscAtZero">
<tt class="descname">setChiDiscAtZero</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.setChiDiscAtZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the position of the discontinuity of the chi axis between
0 and 2pi.  By default it is between pi and -pi</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.setFit2D">
<tt class="descname">setFit2D</tt><big>(</big><em>directDist</em>, <em>centerX</em>, <em>centerY</em>, <em>tilt=0.0</em>, <em>tiltPlanRotation=0.0</em>, <em>pixelX=None</em>, <em>pixelY=None</em>, <em>splineFile=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.setFit2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the Fit2D-like parameter set: For geometry description see
HPR 1996 (14) pp-240</p>
<p>Warning: Fit2D flips automatically images depending on their file-format.
By reverse engineering we noticed this behavour for Tiff and Mar345 images (at least).
To obtaine correct result you will have to flip images using numpy.flipud.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>direct</strong> &#8211; direct distance from sample to detector along the incident beam (in millimeter as in fit2d)</li>
<li><strong>tilt</strong> &#8211; tilt in degrees</li>
<li><strong>tiltPlanRotation</strong> &#8211; Rotation (in degrees) of the tilt plan arround the Z-detector axis
* 0deg -&gt; Y does not move, +X goes to Z&lt;0
* 90deg -&gt; X does not move, +Y goes to Z&lt;0
* 180deg -&gt; Y does not move, +X goes to Z&gt;0
* 270deg -&gt; X does not move, +Y goes to Z&gt;0</li>
<li><strong>pixelX,pixelY</strong> &#8211; as in fit2d they ar given in micron, not in meter</li>
<li><strong>centerY</strong> (<em>centerX,</em>) &#8211; pixel position of the beam center</li>
<li><strong>splineFile</strong> &#8211; name of the file containing the spline</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.setOversampling">
<tt class="descname">setOversampling</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.setOversampling" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.setPyFAI">
<tt class="descname">setPyFAI</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.setPyFAI" title="Permalink to this definition">¶</a></dt>
<dd><p>set the geometry from a pyFAI-like dict</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.setSPD">
<tt class="descname">setSPD</tt><big>(</big><em>SampleDistance</em>, <em>Center_1</em>, <em>Center_2</em>, <em>Rot_1=0</em>, <em>Rot_2=0</em>, <em>Rot_3=0</em>, <em>PSize_1=None</em>, <em>PSize_2=None</em>, <em>splineFile=None</em>, <em>BSize_1=1</em>, <em>BSize_2=1</em>, <em>WaveLength=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.setSPD" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the SPD like parameter set: For geometry description see
Peter Boesecke J.Appl.Cryst.(2007).40, s423–s427</p>
<p>Basically the main difference with pyFAI is the order of the axis which are flipped</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>SampleDistance</strong> &#8211; distance from sample to detector at the PONI (orthogonal projection)</li>
<li><strong>Center_1</strong> &#8211; pixel position of the PONI along fastest axis</li>
<li><strong>Center_2</strong> &#8211; pixel position of the PONI along slowest axis</li>
<li><strong>Rot_1</strong> &#8211; rotation around the fastest axis (x)</li>
<li><strong>Rot_2</strong> &#8211; rotation around the slowest axis (y)</li>
<li><strong>Rot_3</strong> &#8211; rotation around the axis ORTHOGONAL to the detector plan</li>
<li><strong>PSize_1</strong> &#8211; pixel size in meter along the fastest dimention</li>
<li><strong>PSize_2</strong> &#8211; pixel size in meter along the slowst dimention</li>
<li><strong>splineFile</strong> &#8211; name of the file containing the spline</li>
<li><strong>BSize_1</strong> &#8211; pixel binning factor along the fastest dimention</li>
<li><strong>BSize_2</strong> &#8211; pixel binning factor along the slowst dimention</li>
<li><strong>WaveLength</strong> &#8211; wavelength used</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_chia">
<tt class="descname">set_chia</tt><big>(</big><em>_</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_chia" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_correct_solid_angle_for_spline">
<tt class="descname">set_correct_solid_angle_for_spline</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_correct_solid_angle_for_spline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_dist">
<tt class="descname">set_dist</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_dist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_dssa">
<tt class="descname">set_dssa</tt><big>(</big><em>_</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_dssa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_mask">
<tt class="descname">set_mask</tt><big>(</big><em>mask</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_maskfile">
<tt class="descname">set_maskfile</tt><big>(</big><em>maskfile</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_pixel1">
<tt class="descname">set_pixel1</tt><big>(</big><em>pixel1</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_pixel1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_pixel2">
<tt class="descname">set_pixel2</tt><big>(</big><em>pixel2</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_pixel2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_poni1">
<tt class="descname">set_poni1</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_poni1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_poni2">
<tt class="descname">set_poni2</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_poni2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_qa">
<tt class="descname">set_qa</tt><big>(</big><em>_</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_qa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_ra">
<tt class="descname">set_ra</tt><big>(</big><em>_</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_ra" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_rot1">
<tt class="descname">set_rot1</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_rot1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_rot2">
<tt class="descname">set_rot2</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_rot2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_rot3">
<tt class="descname">set_rot3</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_rot3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_spline">
<tt class="descname">set_spline</tt><big>(</big><em>spline</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_spline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_splineFile">
<tt class="descname">set_splineFile</tt><big>(</big><em>splineFile</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_ttha">
<tt class="descname">set_ttha</tt><big>(</big><em>_</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_ttha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_wavelength">
<tt class="descname">set_wavelength</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pyFAI.geometry.Geometry.sload">
<em class="property">classmethod </em><tt class="descname">sload</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.sload" title="Permalink to this definition">¶</a></dt>
<dd><p>A static method combining the constructor and the loader from
a file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; name of the file to load</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">instance of Gerometry of AzimuthalIntegrator set-up with the parameter from the file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.solidAngleArray">
<tt class="descname">solidAngleArray</tt><big>(</big><em>shape=None</em>, <em>order=3</em>, <em>absolute=False</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.solidAngleArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array for the solid angle correction
given the shape of the detector.</p>
<p>solid_angle = cos(incidence)^3</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shape</strong> &#8211; shape of the array expected</li>
<li><strong>order</strong> &#8211; should be 3, power of the formula just obove</li>
<li><strong>absolute</strong> &#8211; the absolute solid angle is calculated as:</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>SA = pix1*pix2/dist^2 * cos(incidence)^3</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.spline">
<tt class="descname">spline</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.spline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.splineFile">
<tt class="descname">splineFile</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.tth">
<tt class="descname">tth</tt><big>(</big><em>d1</em>, <em>d2</em>, <em>param=None</em>, <em>path='cython'</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.tth" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the 2theta value for the center of a given pixel
(or set of pixels)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in first dimension (c order)</li>
<li><strong>d2</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in second dimension (c order)</li>
<li><strong>path</strong> &#8211; can be &#8220;cos&#8221;, &#8220;tan&#8221; or &#8220;cython&#8221;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">2theta in radians</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float or array of floats.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.tth_corner">
<tt class="descname">tth_corner</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.tth_corner" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.ttha">
<tt class="descname">ttha</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.ttha" title="Permalink to this definition">¶</a></dt>
<dd><p>2theta array in cache</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.twoThetaArray">
<tt class="descname">twoThetaArray</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.twoThetaArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array of two-theta(i,j) in radians for each pixel in detector</p>
<p>the 2theta array values are in radians</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; shape of the detector</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">array of 2theta position in radians</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.wavelength">
<tt class="descname">wavelength</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.write">
<tt class="descname">write</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the geometry parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; name of the file where to save the parameters</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.geometryRefinement">
<span id="geometryrefinement-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">geometryRefinement</span></tt> Module<a class="headerlink" href="#module-pyFAI.geometryRefinement" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.geometryRefinement.GeometryRefinement">
<em class="property">class </em><tt class="descclassname">pyFAI.geometryRefinement.</tt><tt class="descname">GeometryRefinement</tt><big>(</big><em>data</em>, <em>dist=1</em>, <em>poni1=None</em>, <em>poni2=None</em>, <em>rot1=0</em>, <em>rot2=0</em>, <em>rot3=0</em>, <em>pixel1=None</em>, <em>pixel2=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>wavelength=None</em>, <em>calibrant=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator" title="pyFAI.azimuthalIntegrator.AzimuthalIntegrator"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.azimuthalIntegrator.AzimuthalIntegrator</span></tt></a></p>
<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.__init__">
<tt class="descname">__init__</tt><big>(</big><em>data</em>, <em>dist=1</em>, <em>poni1=None</em>, <em>poni2=None</em>, <em>rot1=0</em>, <em>rot2=0</em>, <em>rot3=0</em>, <em>pixel1=None</em>, <em>pixel2=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>wavelength=None</em>, <em>calibrant=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; ndarray float64 shape = n, 3
col0: pos in dim0 (in pixels)
col1: pos in dim1 (in pixels)
col2: ring index in calibrant object</li>
<li><strong>dist</strong> &#8211; guessed sample-detector distance (optional, in m)</li>
<li><strong>poni1</strong> &#8211; guessed PONI coordinate along the Y axis (optional, in m)</li>
<li><strong>poni2</strong> &#8211; guessed PONI coordinate along the X axis (optional, in m)</li>
<li><strong>rot1</strong> &#8211; guessed tilt of the detector around the Y axis (optional, in rad)</li>
<li><strong>rot2</strong> &#8211; guessed tilt of the detector around the X axis (optional, in rad)</li>
<li><strong>rot3</strong> &#8211; guessed tilt of the detector around the incoming beam axis (optional, in rad)</li>
<li><strong>pixel1</strong> &#8211; Pixel size along the vertical direction of the detector (in m), almost mandatory</li>
<li><strong>pixel2</strong> &#8211; Pixel size along the horizontal direction of the detector (in m), almost mandatory</li>
<li><strong>splineFile</strong> &#8211; file describing the detector as 2 cubic splines. Replaces pixel1 &amp; pixel2</li>
<li><strong>detector</strong> &#8211; name of the detector or Detector instance. Replaces splineFile, pixel1 &amp; pixel2</li>
<li><strong>wavelength</strong> &#8211; wavelength in m (1.54e-10)</li>
<li><strong>calibrant</strong> &#8211; instance of pyFAI.calibrant.Calibrant containing the d-Spacing</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.anneal">
<tt class="descname">anneal</tt><big>(</big><em>maxiter=1000000</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.anneal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.calc_2th">
<tt class="descname">calc_2th</tt><big>(</big><em>rings</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.calc_2th" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rings</strong> &#8211; indices of the rings. starts at 0 and self.dSpacing should be long enough !!!</li>
<li><strong>wavelength</strong> &#8211; wavelength in meter</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.chi2">
<tt class="descname">chi2</tt><big>(</big><em>param=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.chi2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.chi2_wavelength">
<tt class="descname">chi2_wavelength</tt><big>(</big><em>param=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.chi2_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.confidence">
<tt class="descname">confidence</tt><big>(</big><em>with_rot=True</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.confidence" title="Permalink to this definition">¶</a></dt>
<dd><p>Confidence interval obtained from the second derivative of the error function
next to its minimum value.</p>
<p>Note the confidence interval increases with the number of points which is &#8220;surprizing&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>with_rot</strong> &#8211; if true include rot1 &amp; rot2 in the parameter set.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">std_dev, confidence</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.curve_fit">
<tt class="descname">curve_fit</tt><big>(</big><em>with_rot=True</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.curve_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Refine the geometry and provide confidence interval
Use curve_fit from scipy.optimize to not only refine the geometry (unconstrained fit)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>with_rot</strong> &#8211; include rotation intro error measurment</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">std_dev, confidence</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.dist_max">
<tt class="descname">dist_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.dist_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.dist_min">
<tt class="descname">dist_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.dist_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_dist_max">
<tt class="descname">get_dist_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_dist_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_dist_min">
<tt class="descname">get_dist_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_dist_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_poni1_max">
<tt class="descname">get_poni1_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_poni1_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_poni1_min">
<tt class="descname">get_poni1_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_poni1_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_poni2_max">
<tt class="descname">get_poni2_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_poni2_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_poni2_min">
<tt class="descname">get_poni2_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_poni2_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_rot1_max">
<tt class="descname">get_rot1_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_rot1_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_rot1_min">
<tt class="descname">get_rot1_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_rot1_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_rot2_max">
<tt class="descname">get_rot2_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_rot2_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_rot2_min">
<tt class="descname">get_rot2_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_rot2_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_rot3_max">
<tt class="descname">get_rot3_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_rot3_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_rot3_min">
<tt class="descname">get_rot3_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_rot3_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_wavelength_max">
<tt class="descname">get_wavelength_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_wavelength_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_wavelength_min">
<tt class="descname">get_wavelength_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_wavelength_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.guess_poni">
<tt class="descname">guess_poni</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.guess_poni" title="Permalink to this definition">¶</a></dt>
<dd><p>Poni can be guessed by the centroid of the ring with lowest 2Theta</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.poni1_max">
<tt class="descname">poni1_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.poni1_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.poni1_min">
<tt class="descname">poni1_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.poni1_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.poni2_max">
<tt class="descname">poni2_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.poni2_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.poni2_min">
<tt class="descname">poni2_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.poni2_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.refine1">
<tt class="descname">refine1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.refine1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.refine2">
<tt class="descname">refine2</tt><big>(</big><em>maxiter=1000000</em>, <em>fix=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.refine2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.refine2_wavelength">
<tt class="descname">refine2_wavelength</tt><big>(</big><em>maxiter=1000000</em>, <em>fix=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.refine2_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.residu1">
<tt class="descname">residu1</tt><big>(</big><em>param</em>, <em>d1</em>, <em>d2</em>, <em>rings</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.residu1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.residu1_wavelength">
<tt class="descname">residu1_wavelength</tt><big>(</big><em>param</em>, <em>d1</em>, <em>d2</em>, <em>rings</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.residu1_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.residu2">
<tt class="descname">residu2</tt><big>(</big><em>param</em>, <em>d1</em>, <em>d2</em>, <em>rings</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.residu2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.residu2_wavelength">
<tt class="descname">residu2_wavelength</tt><big>(</big><em>param</em>, <em>d1</em>, <em>d2</em>, <em>rings</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.residu2_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.residu2_wavelength_weighted">
<tt class="descname">residu2_wavelength_weighted</tt><big>(</big><em>param</em>, <em>d1</em>, <em>d2</em>, <em>rings</em>, <em>weight</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.residu2_wavelength_weighted" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.residu2_weighted">
<tt class="descname">residu2_weighted</tt><big>(</big><em>param</em>, <em>d1</em>, <em>d2</em>, <em>rings</em>, <em>weight</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.residu2_weighted" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.roca">
<tt class="descname">roca</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.roca" title="Permalink to this definition">¶</a></dt>
<dd><p>run roca to optimise the parameter set</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.rot1_max">
<tt class="descname">rot1_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.rot1_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.rot1_min">
<tt class="descname">rot1_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.rot1_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.rot2_max">
<tt class="descname">rot2_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.rot2_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.rot2_min">
<tt class="descname">rot2_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.rot2_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.rot3_max">
<tt class="descname">rot3_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.rot3_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.rot3_min">
<tt class="descname">rot3_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.rot3_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_dist_max">
<tt class="descname">set_dist_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_dist_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_dist_min">
<tt class="descname">set_dist_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_dist_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_poni1_max">
<tt class="descname">set_poni1_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_poni1_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_poni1_min">
<tt class="descname">set_poni1_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_poni1_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_poni2_max">
<tt class="descname">set_poni2_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_poni2_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_poni2_min">
<tt class="descname">set_poni2_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_poni2_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_rot1_max">
<tt class="descname">set_rot1_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_rot1_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_rot1_min">
<tt class="descname">set_rot1_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_rot1_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_rot2_max">
<tt class="descname">set_rot2_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_rot2_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_rot2_min">
<tt class="descname">set_rot2_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_rot2_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_rot3_max">
<tt class="descname">set_rot3_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_rot3_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_rot3_min">
<tt class="descname">set_rot3_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_rot3_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_tolerance">
<tt class="descname">set_tolerance</tt><big>(</big><em>value=10</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_tolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the tolerance for a refinement of the geometry; in percent of the original value</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>value</strong> &#8211; Tolerance as a percentage</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_wavelength_max">
<tt class="descname">set_wavelength_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_wavelength_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_wavelength_min">
<tt class="descname">set_wavelength_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_wavelength_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.simplex">
<tt class="descname">simplex</tt><big>(</big><em>maxiter=1000000</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.simplex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.wavelength_max">
<tt class="descname">wavelength_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.wavelength_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.wavelength_min">
<tt class="descname">wavelength_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.wavelength_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.detectors">
<span id="detectors-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">detectors</span></tt> Module<a class="headerlink" href="#module-pyFAI.detectors" title="Permalink to this headline">¶</a></h1>
<p>Description of all detectors with a factory to instantiate them</p>
<dl class="class">
<dt id="pyFAI.detectors.ADSC_Q210">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">ADSC_Q210</tt><big>(</big><em>pixel1=5.1e-05</em>, <em>pixel2=5.1e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ADSC_Q210" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC Quantum 210r detector, 2x2 chips</p>
<p>Informations from
<a class="reference external" href="http://www.adsc-xray.com/products/ccd-detectors/q210r-ccd-detector/">http://www.adsc-xray.com/products/ccd-detectors/q210r-ccd-detector/</a></p>
<p>Question: how are the gaps handled ?</p>
<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q210.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (4096, 4096)</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q210.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.ADSC_Q210.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=5.1e-05</em>, <em>pixel2=5.1e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ADSC_Q210.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q210.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Quantum 210']</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q210.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q210.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q210.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.ADSC_Q270">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">ADSC_Q270</tt><big>(</big><em>pixel1=6.48e-05</em>, <em>pixel2=6.48e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ADSC_Q270" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC Quantum 270r detector, 2x2 chips</p>
<p>Informations from
<a class="reference external" href="http://www.adsc-xray.com/products/ccd-detectors/q270-ccd-detector/">http://www.adsc-xray.com/products/ccd-detectors/q270-ccd-detector/</a></p>
<p>Question: how are the gaps handled ?</p>
<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q270.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (4168, 4168)</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q270.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.ADSC_Q270.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=6.48e-05</em>, <em>pixel2=6.48e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ADSC_Q270.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q270.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Quantum 270']</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q270.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q270.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q270.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.ADSC_Q315">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">ADSC_Q315</tt><big>(</big><em>pixel1=5.1e-05</em>, <em>pixel2=5.1e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ADSC_Q315" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC Quantum 315r detector, 3x3 chips</p>
<p>Informations from
<a class="reference external" href="http://www.adsc-xray.com/products/ccd-detectors/q315r-ccd-detector/">http://www.adsc-xray.com/products/ccd-detectors/q315r-ccd-detector/</a></p>
<p>Question: how are the gaps handled ?</p>
<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q315.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (6144, 6144)</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q315.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.ADSC_Q315.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=5.1e-05</em>, <em>pixel2=5.1e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ADSC_Q315.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q315.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Quantum 315']</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q315.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q315.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q315.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.ADSC_Q4">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">ADSC_Q4</tt><big>(</big><em>pixel1=8.2e-05</em>, <em>pixel2=8.2e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ADSC_Q4" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC Quantum 4r detector, 2x2 chips</p>
<p>Informations from
<a class="reference external" href="http://proteincrystallography.org/detectors/adsc.php">http://proteincrystallography.org/detectors/adsc.php</a></p>
<p>Question: how are the gaps handled ?</p>
<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q4.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (2304, 2304)</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q4.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.ADSC_Q4.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=8.2e-05</em>, <em>pixel2=8.2e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ADSC_Q4.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q4.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Quantum 4']</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q4.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q4.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q4.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Aarhus">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Aarhus</tt><big>(</big><em>pixel1=2.5e-05</em>, <em>pixel2=2.5e-05</em>, <em>radius=0.3</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Aarhus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Cylindrical detector made of a bent imaging-plate.
Developped at the Danish university of Aarhus
r = 1.2m or 0.3m</p>
<p>The image has to be laid-out horizontally</p>
<p>Nota: the detector is bending towards the sample, hence reducing the sample-detector distance.
This is why z&lt;0 (or p3&lt;0)</p>
<p>TODO: update cython code for 3d detectors
use expand2d instead of outer product with ones</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Aarhus.IS_FLAT">
<tt class="descname">IS_FLAT</tt><em class="property"> = False</em><a class="headerlink" href="#pyFAI.detectors.Aarhus.IS_FLAT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Aarhus.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1000, 16000)</em><a class="headerlink" href="#pyFAI.detectors.Aarhus.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Aarhus.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=2.5e-05</em>, <em>pixel2=2.5e-05</em>, <em>radius=0.3</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Aarhus.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Aarhus.calc_cartesian_positions">
<tt class="descname">calc_cartesian_positions</tt><big>(</big><em>d1=None</em>, <em>d2=None</em>, <em>center=True</em>, <em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Aarhus.calc_cartesian_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of each pixel center in cartesian coordinate
and in meter of a couple of coordinates.
The half pixel offset is taken into account here !!!
Adapted to Nexus detector definition</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the Y pixel positions (slow dimension)</li>
<li><strong>d2</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the X pixel positions (fast dimension)</li>
<li><strong>center</strong> &#8211; retrieve the coordinate of the center of the pixel</li>
<li><strong>use_cython</strong> &#8211; set to False to test Python implementeation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">position in meter of the center of each pixels.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
<p>d1 and d2 must have the same shape, returned array will have
the same shape.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Aarhus.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Aarhus.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Aarhus.get_pixel_corners">
<tt class="descname">get_pixel_corners</tt><big>(</big><em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Aarhus.get_pixel_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of the corner of the pixels</p>
<p>This should be overwritten by class representing non-contiguous detector (Xpad, ...)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">4D array containing:
pixel index (slow dimension)
pixel index (fast dimension)
corner index (A, B, C or D), triangles or hexagons can be handled the same way
vertex position (z,y,x)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Apex2">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Apex2</tt><big>(</big><em>pixel1=0.00012</em>, <em>pixel2=0.00012</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Apex2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>BrukerApex2 detector</p>
<p>Actually a derivative from the Fairchild detector with higher binning</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Apex2.DEFAULT_PIXEL1">
<tt class="descname">DEFAULT_PIXEL1</tt><em class="property"> = 6e-05</em><a class="headerlink" href="#pyFAI.detectors.Apex2.DEFAULT_PIXEL1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Apex2.DEFAULT_PIXEL2">
<tt class="descname">DEFAULT_PIXEL2</tt><em class="property"> = 6e-05</em><a class="headerlink" href="#pyFAI.detectors.Apex2.DEFAULT_PIXEL2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Apex2.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1024, 1024)</em><a class="headerlink" href="#pyFAI.detectors.Apex2.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Apex2.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=0.00012</em>, <em>pixel2=0.00012</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Apex2.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Defaults to 2x2 binning</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Apex2.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['ApexII', 'Bruker']</em><a class="headerlink" href="#pyFAI.detectors.Apex2.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Apex2.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Apex2.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Basler">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Basler</tt><big>(</big><em>pixel=3.75e-06</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Basler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Basler camera are simple CCD camara over GigaE</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Basler.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (966, 1296)</em><a class="headerlink" href="#pyFAI.detectors.Basler.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Basler.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel=3.75e-06</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Basler.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Basler.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['aca1300']</em><a class="headerlink" href="#pyFAI.detectors.Basler.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Basler.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Basler.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Detector">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Detector</tt><big>(</big><em>pixel1=None</em>, <em>pixel2=None</em>, <em>splineFile=None</em>, <em>max_shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Generic class representing a 2D detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Detector.API_VERSION">
<tt class="descname">API_VERSION</tt><em class="property"> = '1.0'</em><a class="headerlink" href="#pyFAI.detectors.Detector.API_VERSION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.IS_CONTIGUOUS">
<tt class="descname">IS_CONTIGUOUS</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Detector.IS_CONTIGUOUS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.IS_FLAT">
<tt class="descname">IS_FLAT</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Detector.IS_FLAT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=None</em>, <em>pixel2=None</em>, <em>splineFile=None</em>, <em>max_shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pixel1</strong> (<em>float</em>) &#8211; size of the pixel in meter along the slow dimension (often Y)</li>
<li><strong>pixel2</strong> (<em>float</em>) &#8211; size of the pixel in meter along the fast dimension (often X)</li>
<li><strong>splineFile</strong> (<em>str</em>) &#8211; path to file containing the geometric correction.</li>
<li><strong>max_shape</strong> (<em>2-tuple of integrers</em>) &#8211; maximum size of the detector</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.aliases">
<tt class="descname">aliases</tt><em class="property"> = []</em><a class="headerlink" href="#pyFAI.detectors.Detector.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.binning">
<tt class="descname">binning</tt><a class="headerlink" href="#pyFAI.detectors.Detector.binning" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.calc_cartesian_positions">
<tt class="descname">calc_cartesian_positions</tt><big>(</big><em>d1=None</em>, <em>d2=None</em>, <em>center=True</em>, <em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.calc_cartesian_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of each pixel center in cartesian coordinate
and in meter of a couple of coordinates.
The half pixel offset is taken into account here !!!
Adapted to Nexus detector definition</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the Y pixel positions (slow dimension)</li>
<li><strong>d2</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the X pixel positions (fast dimension)</li>
<li><strong>center</strong> &#8211; retrieve the coordinate of the center of the pixel, unless gives one corner</li>
<li><strong>use_cython</strong> &#8211; set to False to test Python implementation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">position in meter of the center of each pixels.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">3xndarray, the later being None if IS_FLAT</p>
</td>
</tr>
</tbody>
</table>
<p>d1 and d2 must have the same shape, returned array will have
the same shape.</p>
<p>pos_z is None for flat detectors</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Method calculating the mask for a given detector</p>
<p>Detectors with gaps should overwrite this method with
something actually calculating the mask!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the mask with valid pixel to 0</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">numpy ndarray of int8 or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pyFAI.detectors.Detector.factory">
<em class="property">classmethod </em><tt class="descname">factory</tt><big>(</big><em>name</em>, <em>config=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A kind of factory...</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of a detector</li>
<li><strong>config</strong> (<em>dict or JSON representation of it.</em>) &#8211; configuration of the detector</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">an instance of the right detector, set-up if possible</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">pyFAI.detectors.Detector</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = False</em><a class="headerlink" href="#pyFAI.detectors.Detector.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.getFit2D">
<tt class="descname">getFit2D</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.getFit2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to serialize the description of a detector using the Fit2d units</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">representation of the detector easy to serialize</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.getPyFAI">
<tt class="descname">getPyFAI</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.getPyFAI" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to serialize the description of a detector using the pyFAI way
with everything in S.I units.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">representation of the detector easy to serialize</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_binning">
<tt class="descname">get_binning</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_binning" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_mask">
<tt class="descname">get_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_maskfile">
<tt class="descname">get_maskfile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_name">
<tt class="descname">get_name</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a meaningful name for detector</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_pixel1">
<tt class="descname">get_pixel1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_pixel1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_pixel2">
<tt class="descname">get_pixel2</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_pixel2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_pixel_corners">
<tt class="descname">get_pixel_corners</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_pixel_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of the corner of the pixels</p>
<p>This should be overwritten by class representing non-contiguous detector (Xpad, ...)</p>
<p>Precision float32 is ok: precision of 1µm for a detector size of 1m</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">4D array containing:
pixel index (slow dimension)
pixel index (fast dimension)
corner index (A, B, C or D), triangles or hexagons can be handled the same way
vertex position (z,y,x)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_splineFile">
<tt class="descname">get_splineFile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.guess_binning">
<tt class="descname">guess_binning</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.guess_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Guess the binning/mode depending on the image shape
:param data: 2-tuple with the shape of the image or the image with a .shape attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.mask">
<tt class="descname">mask</tt><a class="headerlink" href="#pyFAI.detectors.Detector.mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.maskfile">
<tt class="descname">maskfile</tt><a class="headerlink" href="#pyFAI.detectors.Detector.maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyFAI.detectors.Detector.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a meaningful name for detector</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.pixel1">
<tt class="descname">pixel1</tt><a class="headerlink" href="#pyFAI.detectors.Detector.pixel1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.pixel2">
<tt class="descname">pixel2</tt><a class="headerlink" href="#pyFAI.detectors.Detector.pixel2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.registry">
<tt class="descname">registry</tt><em class="property"> = {'pilatus1m_cdte': &lt;class 'pyFAI.detectors.PilatusCdTe1M'&gt;, 'imxpads10': &lt;class 'pyFAI.detectors.ImXPadS10'&gt;, 'pilatus1mcdte': &lt;class 'pyFAI.detectors.PilatusCdTe1M'&gt;, 'rayonix_mx225hs': &lt;class 'pyFAI.detectors.RayonixMx225hs'&gt;, 'pilatus_cdte_2m': &lt;class 'pyFAI.detectors.PilatusCdTe2M'&gt;, 'd5': &lt;class 'pyFAI.detectors.Xpad_flat'&gt;, 'eiger_500k': &lt;class 'pyFAI.detectors.Eiger500k'&gt;, 'rayonix_mx170-hs': &lt;class 'pyFAI.detectors.RayonixMx170'&gt;, 'imxpad_s10': &lt;class 'pyFAI.detectors.ImXPadS10'&gt;, 'rayonix_mx340hs': &lt;class 'pyFAI.detectors.RayonixMx340hs'&gt;, 'condor': &lt;class 'pyFAI.detectors.Fairchild'&gt;, 'eiger16m': &lt;class 'pyFAI.detectors.Eiger16M'&gt;, 'pilatus_1m': &lt;class 'pyFAI.detectors.Pilatus1M'&gt;, 'oxd_titan': &lt;class 'pyFAI.detectors.Titan'&gt;, 'perkin_detector': &lt;class 'pyFAI.detectors.Perkin'&gt;, 'pilatus6m': &lt;class 'pyFAI.detectors.Pilatus6M'&gt;, 'titan_2k_x_2k': &lt;class 'pyFAI.detectors.Titan'&gt;, 'hf_262k': &lt;class 'pyFAI.detectors.HF_262k'&gt;, 'thales_electronics': &lt;class 'pyFAI.detectors.Pixium'&gt;, 'rayonixlx255': &lt;class 'pyFAI.detectors.RayonixLx255'&gt;, 'rayonixsx200': &lt;class 'pyFAI.detectors.RayonixSx200'&gt;, 'eiger4m': &lt;class 'pyFAI.detectors.Eiger4M'&gt;, 'rayonix_lx170': &lt;class 'pyFAI.detectors.RayonixLx170'&gt;, 'pilatuscdte300kw': &lt;class 'pyFAI.detectors.PilatusCdTe300kw'&gt;, 'pilatus300k': &lt;class 'pyFAI.detectors.Pilatus300k'&gt;, 'picamv2': &lt;class 'pyFAI.detectors.RaspberryPi8M'&gt;, 'picamv1': &lt;class 'pyFAI.detectors.RaspberryPi5M'&gt;, 'quantum_270': &lt;class 'pyFAI.detectors.ADSC_Q270'&gt;, 'rayonixmx300': &lt;class 'pyFAI.detectors.RayonixMx300'&gt;, 'pilatus300kw_cdte': &lt;class 'pyFAI.detectors.PilatusCdTe300kw'&gt;, 'rayonixlx225hs': &lt;class 'pyFAI.detectors.RayonixLx255'&gt;, 'pilatuscdte1m': &lt;class 'pyFAI.detectors.PilatusCdTe1M'&gt;, 'raspberrypi5m': &lt;class 'pyFAI.detectors.RaspberryPi5M'&gt;, 'pilatus_cdte_300kw': &lt;class 'pyFAI.detectors.PilatusCdTe300kw'&gt;, 'perkin': &lt;class 'pyFAI.detectors.Perkin'&gt;, 'rayonixmx340hs': &lt;class 'pyFAI.detectors.RayonixMx340hs'&gt;, 'rayonix_mx325': &lt;class 'pyFAI.detectors.RayonixMx325'&gt;, 'picam_v2': &lt;class 'pyFAI.detectors.RaspberryPi8M'&gt;, 'adsc_q270': &lt;class 'pyFAI.detectors.ADSC_Q270'&gt;, 'rayonixmx170hs': &lt;class 'pyFAI.detectors.RayonixMx170'&gt;, 'pilatus_6m': &lt;class 'pyFAI.detectors.Pilatus6M'&gt;, 'oxdtitan': &lt;class 'pyFAI.detectors.Titan'&gt;, 'dexela2923': &lt;class 'pyFAI.detectors.Dexela2923'&gt;, 'xpads540flat': &lt;class 'pyFAI.detectors.Xpad_flat'&gt;, 'titan': &lt;class 'pyFAI.detectors.Titan'&gt;, 'aarhus': &lt;class 'pyFAI.detectors.Aarhus'&gt;, 'rayonix_mx425hs': &lt;class 'pyFAI.detectors.RayonixMx425hs'&gt;, 'hf_4m': &lt;class 'pyFAI.detectors.HF_4M'&gt;, 'pilatuscdte2m': &lt;class 'pyFAI.detectors.PilatusCdTe2M'&gt;, 'pilatuscdte300k': &lt;class 'pyFAI.detectors.PilatusCdTe300k'&gt;, 'pilatus_1m_cdte': &lt;class 'pyFAI.detectors.PilatusCdTe1M'&gt;, 'pilatus_300kw': &lt;class 'pyFAI.detectors.Pilatus300kw'&gt;, 'rayonixmx170-hs': &lt;class 'pyFAI.detectors.RayonixMx170'&gt;, 'rayonixmx300hs': &lt;class 'pyFAI.detectors.RayonixMx300hs'&gt;, 'pixium4700detector': &lt;class 'pyFAI.detectors.Pixium'&gt;, 'thaleselectronics': &lt;class 'pyFAI.detectors.Pixium'&gt;, 'agilenttitan': &lt;class 'pyFAI.detectors.Titan'&gt;, 'eiger500k': &lt;class 'pyFAI.detectors.Eiger500k'&gt;, 'rayonixsx165': &lt;class 'pyFAI.detectors.RayonixSx165'&gt;, 'pilatus100k': &lt;class 'pyFAI.detectors.Pilatus100k'&gt;, 'rayonix_lx170-hs': &lt;class 'pyFAI.detectors.RayonixLx170'&gt;, 'perkin_elmer': &lt;class 'pyFAI.detectors.Perkin'&gt;, 'aca1300': &lt;class 'pyFAI.detectors.Basler'&gt;, 'quantum315': &lt;class 'pyFAI.detectors.ADSC_Q315'&gt;, 'quantum4': &lt;class 'pyFAI.detectors.ADSC_Q4'&gt;, 'rayonixsx85hs': &lt;class 'pyFAI.detectors.RayonixSx85hs'&gt;, 'eiger_4m': &lt;class 'pyFAI.detectors.Eiger4M'&gt;, 'imxpads140': &lt;class 'pyFAI.detectors.ImXPadS140'&gt;, 'rayonix_mx170': &lt;class 'pyFAI.detectors.RayonixMx170'&gt;, 'pilatus300kw': &lt;class 'pyFAI.detectors.Pilatus300kw'&gt;, 'hf-130k': &lt;class 'pyFAI.detectors.HF_130K'&gt;, 'pilatus_100k': &lt;class 'pyFAI.detectors.Pilatus100k'&gt;, 'rayonixsx30hs': &lt;class 'pyFAI.detectors.RayonixSx30hs'&gt;, 'mar345': &lt;class 'pyFAI.detectors.Mar345'&gt;, 'perkindetector': &lt;class 'pyFAI.detectors.Perkin'&gt;, 'rayonix_mx425_hs': &lt;class 'pyFAI.detectors.RayonixMx425hs'&gt;, 'rayonix_mx225': &lt;class 'pyFAI.detectors.RayonixMx225'&gt;, 'eiger1m': &lt;class 'pyFAI.detectors.Eiger1M'&gt;, 'mar_345': &lt;class 'pyFAI.detectors.Mar345'&gt;, 'pilatus2m': &lt;class 'pyFAI.detectors.Pilatus2M'&gt;, 'hf_9m': &lt;class 'pyFAI.detectors.HF_9M'&gt;, 'rayonixlx170hs': &lt;class 'pyFAI.detectors.RayonixLx170'&gt;, 'hf-1m': &lt;class 'pyFAI.detectors.HF_1M'&gt;, 'eiger_1m': &lt;class 'pyFAI.detectors.Eiger1M'&gt;, 'rayonix_lx170_hs': &lt;class 'pyFAI.detectors.RayonixLx170'&gt;, 'rayonixmx170': &lt;class 'pyFAI.detectors.RayonixMx170'&gt;, 'pilatus2mcdte': &lt;class 'pyFAI.detectors.PilatusCdTe2M'&gt;, 'mar165': &lt;class 'pyFAI.detectors.RayonixSx165'&gt;, 'rayonixlx255-hs': &lt;class 'pyFAI.detectors.RayonixLx255'&gt;, 'pilatus_200k': &lt;class 'pyFAI.detectors.Pilatus200k'&gt;, 'hf_2m': &lt;class 'pyFAI.detectors.HF_2M'&gt;, 'titan2kx2k': &lt;class 'pyFAI.detectors.Titan'&gt;, 'pilatus_cdte_1m': &lt;class 'pyFAI.detectors.PilatusCdTe1M'&gt;, 'hf-9.4m': &lt;class 'pyFAI.detectors.HF_9M'&gt;, 'fairchild_condor_486:90': &lt;class 'pyFAI.detectors.Fairchild'&gt;, 'hf-262k': &lt;class 'pyFAI.detectors.HF_262k'&gt;, 'xpad_flat': &lt;class 'pyFAI.detectors.Xpad_flat'&gt;, 'quantum_315': &lt;class 'pyFAI.detectors.ADSC_Q315'&gt;, 'eiger_16m': &lt;class 'pyFAI.detectors.Eiger16M'&gt;, 'pilatus_300k': &lt;class 'pyFAI.detectors.Pilatus300k'&gt;, 'raspberrypi8m': &lt;class 'pyFAI.detectors.RaspberryPi8M'&gt;, 'pilatus1m': &lt;class 'pyFAI.detectors.Pilatus1M'&gt;, 'xpad_s540_flat': &lt;class 'pyFAI.detectors.Xpad_flat'&gt;, 'pixium_4700_detector': &lt;class 'pyFAI.detectors.Pixium'&gt;, 'basler': &lt;class 'pyFAI.detectors.Basler'&gt;, 'pilatus2m_cdte': &lt;class 'pyFAI.detectors.PilatusCdTe2M'&gt;, 'rayonix_sx200': &lt;class 'pyFAI.detectors.RayonixSx200'&gt;, 'quantum270': &lt;class 'pyFAI.detectors.ADSC_Q270'&gt;, 'dexela_2923': &lt;class 'pyFAI.detectors.Dexela2923'&gt;, 'mar3450': &lt;class 'pyFAI.detectors.Mar345'&gt;, 'pixium': &lt;class 'pyFAI.detectors.Pixium'&gt;, 'fairchild': &lt;class 'pyFAI.detectors.Fairchild'&gt;, 'rayonixmx225hs': &lt;class 'pyFAI.detectors.RayonixMx225hs'&gt;, 'apexii': &lt;class 'pyFAI.detectors.Apex2'&gt;, 'quantum_210': &lt;class 'pyFAI.detectors.ADSC_Q210'&gt;, 'bruker': &lt;class 'pyFAI.detectors.Apex2'&gt;, 'pilatus300kwcdte': &lt;class 'pyFAI.detectors.PilatusCdTe300kw'&gt;, 'pilatus_2m': &lt;class 'pyFAI.detectors.Pilatus2M'&gt;, 'rayonixmx425hs': &lt;class 'pyFAI.detectors.RayonixMx425hs'&gt;, 'imxpads70': &lt;class 'pyFAI.detectors.ImXPadS70'&gt;, 'pilatus_300k_cdte': &lt;class 'pyFAI.detectors.PilatusCdTe300k'&gt;, 'rayonix_sx30hs': &lt;class 'pyFAI.detectors.RayonixSx30hs'&gt;, 'eiger9m': &lt;class 'pyFAI.detectors.Eiger9M'&gt;, 'agilent_titan': &lt;class 'pyFAI.detectors.Titan'&gt;, 'rayonixlx255hs': &lt;class 'pyFAI.detectors.RayonixLx255'&gt;, 'rayonix133': &lt;class 'pyFAI.detectors.Rayonix133'&gt;, 'rayonix_lx255': &lt;class 'pyFAI.detectors.RayonixLx255'&gt;, 'rayonixlx170-hs': &lt;class 'pyFAI.detectors.RayonixLx170'&gt;, 'perkinelmer': &lt;class 'pyFAI.detectors.Perkin'&gt;, 'rayonix': &lt;class 'pyFAI.detectors.Rayonix'&gt;, 'rayonix_sx165': &lt;class 'pyFAI.detectors.RayonixSx165'&gt;, 'rayonix_mx300hs': &lt;class 'pyFAI.detectors.RayonixMx300hs'&gt;, 'rayonix_lx255-hs': &lt;class 'pyFAI.detectors.RayonixLx255'&gt;, 'adsc_q4': &lt;class 'pyFAI.detectors.ADSC_Q4'&gt;, 'rayonixmx225': &lt;class 'pyFAI.detectors.RayonixMx225'&gt;, 'rayonix_sx30_hs': &lt;class 'pyFAI.detectors.RayonixSx30hs'&gt;, 'apex2': &lt;class 'pyFAI.detectors.Apex2'&gt;, 'hf-2.4m': &lt;class 'pyFAI.detectors.HF_2M'&gt;, 'pilatus_cdte_300k': &lt;class 'pyFAI.detectors.PilatusCdTe300k'&gt;, 'detector': &lt;class 'pyFAI.detectors.Detector'&gt;, 'pilatus_2m_cdte': &lt;class 'pyFAI.detectors.PilatusCdTe2M'&gt;, 'picam_v1': &lt;class 'pyFAI.detectors.RaspberryPi5M'&gt;, 'imxpad_s140': &lt;class 'pyFAI.detectors.ImXPadS140'&gt;, 'fairchildcondor486:90': &lt;class 'pyFAI.detectors.Fairchild'&gt;, 'adsc_q210': &lt;class 'pyFAI.detectors.ADSC_Q210'&gt;, 'pilatus300kcdte': &lt;class 'pyFAI.detectors.PilatusCdTe300k'&gt;, 'rayonixlx170': &lt;class 'pyFAI.detectors.RayonixLx170'&gt;, 'pilatus300k_cdte': &lt;class 'pyFAI.detectors.PilatusCdTe300k'&gt;, 'rayonix_sx85_hs': &lt;class 'pyFAI.detectors.RayonixSx85hs'&gt;, 'rayonix_mx170_hs': &lt;class 'pyFAI.detectors.RayonixMx170'&gt;, 'rayonix_lx_255hs': &lt;class 'pyFAI.detectors.RayonixLx255'&gt;, 'quantum210': &lt;class 'pyFAI.detectors.ADSC_Q210'&gt;, 'hf_1m': &lt;class 'pyFAI.detectors.HF_1M'&gt;, 'rayonix_mx225_hs': &lt;class 'pyFAI.detectors.RayonixMx225hs'&gt;, 'mar133': &lt;class 'pyFAI.detectors.Rayonix133'&gt;, 'pilatus200k': &lt;class 'pyFAI.detectors.Pilatus200k'&gt;, 'hf_130k': &lt;class 'pyFAI.detectors.HF_130K'&gt;, 'pilatus_300kw_cdte': &lt;class 'pyFAI.detectors.PilatusCdTe300kw'&gt;, 'imxpad_s70': &lt;class 'pyFAI.detectors.ImXPadS70'&gt;, 'adsc_q315': &lt;class 'pyFAI.detectors.ADSC_Q315'&gt;, 'rayonixmx325': &lt;class 'pyFAI.detectors.RayonixMx325'&gt;, 'rayonix_sx85hs': &lt;class 'pyFAI.detectors.RayonixSx85hs'&gt;, 'eiger_9m': &lt;class 'pyFAI.detectors.Eiger9M'&gt;, 'rayonix_mx300_hs': &lt;class 'pyFAI.detectors.RayonixMx300hs'&gt;, 'hf-4m': &lt;class 'pyFAI.detectors.HF_4M'&gt;, 'rayonix_mx300': &lt;class 'pyFAI.detectors.RayonixMx300'&gt;, 'quantum_4': &lt;class 'pyFAI.detectors.ADSC_Q4'&gt;}</em><a class="headerlink" href="#pyFAI.detectors.Detector.registry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.save">
<tt class="descname">save</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves the detector description into a NeXus file, adapted from:
<a class="reference external" href="http://download.nexusformat.org/sphinx/classes/base_classes/NXdetector.html">http://download.nexusformat.org/sphinx/classes/base_classes/NXdetector.html</a>
Main differences:</p>
<blockquote>
<div><ul class="simple">
<li>differentiate pixel center from pixel corner offsets</li>
<li>store all offsets are ndarray according to slow/fast dimension (not x, y)</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; name of the file on the disc</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.setFit2D">
<tt class="descname">setFit2D</tt><big>(</big><em>**kwarg</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.setFit2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Twin method of getFit2D: setup a detector instance according to a description</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kwarg</strong> &#8211; dictionary containing pixel1, pixel2 and splineFile</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.setPyFAI">
<tt class="descname">setPyFAI</tt><big>(</big><em>**kwarg</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.setPyFAI" title="Permalink to this definition">¶</a></dt>
<dd><p>Twin method of getPyFAI: setup a detector instance according to a description</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kwarg</strong> &#8211; dictionary containing detector, pixel1, pixel2 and splineFile</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_binning">
<tt class="descname">set_binning</tt><big>(</big><em>bin_size=(1</em>, <em>1)</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the &#8220;binning&#8221; of the detector,</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bin_size</strong> (<em>(int, int)</em>) &#8211; binning as integer or tuple of integers.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_config">
<tt class="descname">set_config</tt><big>(</big><em>config</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the configuration of the detector. This implies:
- Orientation: integers
- Binning
- ROI</p>
<p>The configuration is either a python dictionary or a JSON string or a file containing this JSON configuration</p>
<p>keys in that dictionary are :
&#8220;orientation&#8221;: integers from 0 to 7
&#8220;binning&#8221;: integer or 2-tuple of integers. If only one integer is provided,
&#8220;offset&#8221;: coordinate (in pixels) of the start of the detector</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_dx">
<tt class="descname">set_dx</tt><big>(</big><em>dx=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_dx" title="Permalink to this definition">¶</a></dt>
<dd><p>set the pixel-wise displacement along X (dim2):</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_dy">
<tt class="descname">set_dy</tt><big>(</big><em>dy=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_dy" title="Permalink to this definition">¶</a></dt>
<dd><p>set the pixel-wise displacement along Y (dim1):</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_mask">
<tt class="descname">set_mask</tt><big>(</big><em>mask</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_maskfile">
<tt class="descname">set_maskfile</tt><big>(</big><em>maskfile</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_pixel1">
<tt class="descname">set_pixel1</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_pixel1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_pixel2">
<tt class="descname">set_pixel2</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_pixel2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_splineFile">
<tt class="descname">set_splineFile</tt><big>(</big><em>splineFile</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.splineFile">
<tt class="descname">splineFile</tt><a class="headerlink" href="#pyFAI.detectors.Detector.splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.uniform_pixel">
<tt class="descname">uniform_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Detector.uniform_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.DetectorMeta">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">DetectorMeta</tt><big>(</big><em>name</em>, <em>bases</em>, <em>dct</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.DetectorMeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">type</span></tt></p>
<p>Metaclass used to register all detector classes inheriting from Detector</p>
<dl class="method">
<dt id="pyFAI.detectors.DetectorMeta.__init__">
<tt class="descname">__init__</tt><big>(</big><em>name</em>, <em>bases</em>, <em>dct</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.DetectorMeta.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Dexela2923">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Dexela2923</tt><big>(</big><em>pixel1=7.5e-05</em>, <em>pixel2=7.5e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Dexela2923" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Dexela CMOS family detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Dexela2923.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (3888, 3072)</em><a class="headerlink" href="#pyFAI.detectors.Dexela2923.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Dexela2923.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=7.5e-05</em>, <em>pixel2=7.5e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Dexela2923.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Dexela2923.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Dexela 2923']</em><a class="headerlink" href="#pyFAI.detectors.Dexela2923.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Dexela2923.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Dexela2923.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Eiger">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Eiger</tt><big>(</big><em>pixel1=7.5e-05</em>, <em>pixel2=7.5e-05</em>, <em>max_shape=None</em>, <em>module_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Eiger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Eiger detector: generic description containing mask algorithm</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Eiger.MODULE_GAP">
<tt class="descname">MODULE_GAP</tt><em class="property"> = (37, 10)</em><a class="headerlink" href="#pyFAI.detectors.Eiger.MODULE_GAP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Eiger.MODULE_SIZE">
<tt class="descname">MODULE_SIZE</tt><em class="property"> = (514, 1030)</em><a class="headerlink" href="#pyFAI.detectors.Eiger.MODULE_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Eiger.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=7.5e-05</em>, <em>pixel2=7.5e-05</em>, <em>max_shape=None</em>, <em>module_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Eiger.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Eiger.calc_cartesian_positions">
<tt class="descname">calc_cartesian_positions</tt><big>(</big><em>d1=None</em>, <em>d2=None</em>, <em>center=True</em>, <em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Eiger.calc_cartesian_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of each pixel center in cartesian coordinate
and in meter of a couple of coordinates.
The half pixel offset is taken into account here !!!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the Y pixel positions (slow dimension)</li>
<li><strong>d2</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the X pixel positions (fast dimension)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">p1, p2 position in meter of the center of each pixels.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2-tuple of numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
<p>d1 and d2 must have the same shape, returned array will have
the same shape.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Eiger.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Eiger.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a generic mask for Pilatus detectors...</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Eiger.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Eiger.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Eiger16M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Eiger16M</tt><big>(</big><em>pixel1=7.5e-05</em>, <em>pixel2=7.5e-05</em>, <em>max_shape=None</em>, <em>module_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Eiger16M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Eiger" title="pyFAI.detectors.Eiger"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Eiger</span></tt></a></p>
<p>Eiger 16M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Eiger16M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (4371, 4150)</em><a class="headerlink" href="#pyFAI.detectors.Eiger16M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Eiger16M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Eiger 16M']</em><a class="headerlink" href="#pyFAI.detectors.Eiger16M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Eiger1M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Eiger1M</tt><big>(</big><em>pixel1=7.5e-05</em>, <em>pixel2=7.5e-05</em>, <em>max_shape=None</em>, <em>module_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Eiger1M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Eiger" title="pyFAI.detectors.Eiger"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Eiger</span></tt></a></p>
<p>Eiger 1M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Eiger1M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1065, 1030)</em><a class="headerlink" href="#pyFAI.detectors.Eiger1M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Eiger1M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Eiger 1M']</em><a class="headerlink" href="#pyFAI.detectors.Eiger1M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Eiger4M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Eiger4M</tt><big>(</big><em>pixel1=7.5e-05</em>, <em>pixel2=7.5e-05</em>, <em>max_shape=None</em>, <em>module_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Eiger4M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Eiger" title="pyFAI.detectors.Eiger"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Eiger</span></tt></a></p>
<p>Eiger 4M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Eiger4M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (2167, 2070)</em><a class="headerlink" href="#pyFAI.detectors.Eiger4M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Eiger4M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Eiger 4M']</em><a class="headerlink" href="#pyFAI.detectors.Eiger4M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Eiger500k">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Eiger500k</tt><big>(</big><em>pixel1=7.5e-05</em>, <em>pixel2=7.5e-05</em>, <em>max_shape=None</em>, <em>module_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Eiger500k" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Eiger" title="pyFAI.detectors.Eiger"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Eiger</span></tt></a></p>
<p>Eiger 1M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Eiger500k.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (512, 1030)</em><a class="headerlink" href="#pyFAI.detectors.Eiger500k.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Eiger500k.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Eiger 500k']</em><a class="headerlink" href="#pyFAI.detectors.Eiger500k.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Eiger9M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Eiger9M</tt><big>(</big><em>pixel1=7.5e-05</em>, <em>pixel2=7.5e-05</em>, <em>max_shape=None</em>, <em>module_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Eiger9M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Eiger" title="pyFAI.detectors.Eiger"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Eiger</span></tt></a></p>
<p>Eiger 9M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Eiger9M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (3269, 3110)</em><a class="headerlink" href="#pyFAI.detectors.Eiger9M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Eiger9M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Eiger 9M']</em><a class="headerlink" href="#pyFAI.detectors.Eiger9M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.FReLoN">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">FReLoN</tt><big>(</big><em>splineFile=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.FReLoN" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>FReLoN detector:
The spline is mandatory to correct for geometric distortion of the taper</p>
<p>TODO: create automatically a mask that removes pixels out of the &#8220;valid reagion&#8221;</p>
<dl class="method">
<dt id="pyFAI.detectors.FReLoN.__init__">
<tt class="descname">__init__</tt><big>(</big><em>splineFile=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.FReLoN.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.FReLoN.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.FReLoN.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a generic mask for Frelon detectors...
All pixels which (center) turns to be out of the valid region are by default discarded</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Fairchild">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Fairchild</tt><big>(</big><em>pixel1=1.5e-05</em>, <em>pixel2=1.5e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Fairchild" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Fairchild Condor 486:90 detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Fairchild.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (4096, 4096)</em><a class="headerlink" href="#pyFAI.detectors.Fairchild.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Fairchild.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=1.5e-05</em>, <em>pixel2=1.5e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Fairchild.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Fairchild.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Fairchild', 'Condor', 'Fairchild Condor 486:90']</em><a class="headerlink" href="#pyFAI.detectors.Fairchild.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Fairchild.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Fairchild.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Fairchild.uniform_pixel">
<tt class="descname">uniform_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Fairchild.uniform_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.HF_130K">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">HF_130K</tt><big>(</big><em>pixel1=0.00015</em>, <em>pixel2=0.00015</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.HF_130K" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC HF-130K 1 module</p>
<p>Informations from
<a class="reference external" href="http://www.adsc-xray.com/products/pixel-array-detectors/hf-130k/">http://www.adsc-xray.com/products/pixel-array-detectors/hf-130k/</a></p>
<dl class="attribute">
<dt id="pyFAI.detectors.HF_130K.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (256, 512)</em><a class="headerlink" href="#pyFAI.detectors.HF_130K.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.HF_130K.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=0.00015</em>, <em>pixel2=0.00015</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.HF_130K.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_130K.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['HF-130k']</em><a class="headerlink" href="#pyFAI.detectors.HF_130K.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_130K.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.HF_130K.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.HF_1M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">HF_1M</tt><big>(</big><em>pixel1=0.00015</em>, <em>pixel2=0.00015</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.HF_1M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC HF-1M 2x4 modules</p>
<p>Informations from
<a class="reference external" href="http://www.adsc-xray.com/products/pixel-array-detectors/hf-1m/">http://www.adsc-xray.com/products/pixel-array-detectors/hf-1m/</a></p>
<p>Nota: gaps between modules is not known/described</p>
<dl class="attribute">
<dt id="pyFAI.detectors.HF_1M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1024, 1024)</em><a class="headerlink" href="#pyFAI.detectors.HF_1M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.HF_1M.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=0.00015</em>, <em>pixel2=0.00015</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.HF_1M.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_1M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['HF-1M']</em><a class="headerlink" href="#pyFAI.detectors.HF_1M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_1M.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.HF_1M.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.HF_262k">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">HF_262k</tt><big>(</big><em>pixel1=0.00015</em>, <em>pixel2=0.00015</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.HF_262k" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC HF-262k 2 module</p>
<p>Informations from
<a class="reference external" href="http://www.adsc-xray.com/products/pixel-array-detectors/hf-262k/">http://www.adsc-xray.com/products/pixel-array-detectors/hf-262k/</a></p>
<p>Nota: gaps between modules is not known/described</p>
<dl class="attribute">
<dt id="pyFAI.detectors.HF_262k.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (512, 512)</em><a class="headerlink" href="#pyFAI.detectors.HF_262k.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.HF_262k.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=0.00015</em>, <em>pixel2=0.00015</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.HF_262k.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_262k.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['HF-262k']</em><a class="headerlink" href="#pyFAI.detectors.HF_262k.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_262k.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.HF_262k.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.HF_2M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">HF_2M</tt><big>(</big><em>pixel1=0.00015</em>, <em>pixel2=0.00015</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.HF_2M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC HF-1M 3x6 modules</p>
<p>Informations from
<a class="reference external" href="http://www.adsc-xray.com/products/pixel-array-detectors/hf-2.4m/">http://www.adsc-xray.com/products/pixel-array-detectors/hf-2.4m/</a></p>
<p>Nota: gaps between modules is not known/described</p>
<dl class="attribute">
<dt id="pyFAI.detectors.HF_2M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1536, 1536)</em><a class="headerlink" href="#pyFAI.detectors.HF_2M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.HF_2M.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=0.00015</em>, <em>pixel2=0.00015</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.HF_2M.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_2M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['HF-2.4M']</em><a class="headerlink" href="#pyFAI.detectors.HF_2M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_2M.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.HF_2M.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.HF_4M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">HF_4M</tt><big>(</big><em>pixel1=0.00015</em>, <em>pixel2=0.00015</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.HF_4M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC HF-4M 4x8 modules</p>
<p>Informations from
<a class="reference external" href="http://www.adsc-xray.com/products/pixel-array-detectors/hf-4m/">http://www.adsc-xray.com/products/pixel-array-detectors/hf-4m/</a></p>
<dl class="attribute">
<dt id="pyFAI.detectors.HF_4M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (2048, 2048)</em><a class="headerlink" href="#pyFAI.detectors.HF_4M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.HF_4M.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=0.00015</em>, <em>pixel2=0.00015</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.HF_4M.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_4M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['HF-4M']</em><a class="headerlink" href="#pyFAI.detectors.HF_4M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_4M.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.HF_4M.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.HF_9M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">HF_9M</tt><big>(</big><em>pixel1=0.00015</em>, <em>pixel2=0.00015</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.HF_9M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC HF-130K 1 module</p>
<p>Informations from
<a class="reference external" href="http://www.adsc-xray.com/products/pixel-array-detectors/hf-9-4m/">http://www.adsc-xray.com/products/pixel-array-detectors/hf-9-4m/</a></p>
<dl class="attribute">
<dt id="pyFAI.detectors.HF_9M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (3072, 3072)</em><a class="headerlink" href="#pyFAI.detectors.HF_9M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.HF_9M.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=0.00015</em>, <em>pixel2=0.00015</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.HF_9M.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_9M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['HF-9.4M']</em><a class="headerlink" href="#pyFAI.detectors.HF_9M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_9M.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.HF_9M.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.ImXPadS10">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">ImXPadS10</tt><big>(</big><em>pixel1=0.00013</em>, <em>pixel2=0.00013</em>, <em>max_shape=None</em>, <em>module_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ImXPadS10" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ImXPad detector: ImXPad s10 detector with 1x1modules</p>
<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS10.BORDER_SIZE_RELATIVE">
<tt class="descname">BORDER_SIZE_RELATIVE</tt><em class="property"> = 2.5</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.BORDER_SIZE_RELATIVE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS10.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (120, 80)</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS10.MODULE_SIZE">
<tt class="descname">MODULE_SIZE</tt><em class="property"> = (120, 80)</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.MODULE_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS10.PIXEL_SIZE">
<tt class="descname">PIXEL_SIZE</tt><em class="property"> = (0.00013, 0.00013)</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.ImXPadS10.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=0.00013</em>, <em>pixel2=0.00013</em>, <em>max_shape=None</em>, <em>module_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS10.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Imxpad S10']</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.ImXPadS10.calc_cartesian_positions">
<tt class="descname">calc_cartesian_positions</tt><big>(</big><em>d1=None</em>, <em>d2=None</em>, <em>center=True</em>, <em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.calc_cartesian_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of each pixel center in cartesian coordinate
and in meter of a couple of coordinates.
The half pixel offset is taken into account here !!!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the Y pixel positions (slow dimension)</li>
<li><strong>d2</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the X pixel positions (fast dimension)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">position in meter of the center of each pixels.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
<p>d1 and d2 must have the same shape, returned array will have
the same shape.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.ImXPadS10.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the mask</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.ImXPadS10.calc_pixels_edges">
<tt class="descname">calc_pixels_edges</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.calc_pixels_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of the pixel edges</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS10.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.ImXPadS10.get_pixel_corners">
<tt class="descname">get_pixel_corners</tt><big>(</big><em>d1=None</em>, <em>d2=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.get_pixel_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of the corner of the pixels</p>
<p>This should be overwritten by class representing non-contiguous detector (Xpad, ...)</p>
<p>Precision float32 is ok: precision of 1µm for a detector size of 1m</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">4D array containing:
pixel index (slow dimension)
pixel index (fast dimension)
corner index (A, B, C or D), triangles or hexagons can be handled the same way
vertex position (z,y,x)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS10.uniform_pixel">
<tt class="descname">uniform_pixel</tt><em class="property"> = False</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.uniform_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.ImXPadS140">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">ImXPadS140</tt><big>(</big><em>pixel1=0.00013</em>, <em>pixel2=0.00013</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ImXPadS140" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.ImXPadS10" title="pyFAI.detectors.ImXPadS10"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.ImXPadS10</span></tt></a></p>
<p>ImXPad detector: ImXPad s140 detector with 2x7modules</p>
<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS140.BORDER_PIXEL_SIZE_RELATIVE">
<tt class="descname">BORDER_PIXEL_SIZE_RELATIVE</tt><em class="property"> = 2.5</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS140.BORDER_PIXEL_SIZE_RELATIVE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS140.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (240, 560)</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS140.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS140.MODULE_SIZE">
<tt class="descname">MODULE_SIZE</tt><em class="property"> = (120, 80)</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS140.MODULE_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS140.PIXEL_SIZE">
<tt class="descname">PIXEL_SIZE</tt><em class="property"> = (0.00013, 0.00013)</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS140.PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.ImXPadS140.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=0.00013</em>, <em>pixel2=0.00013</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ImXPadS140.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS140.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Imxpad S140']</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS140.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS140.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS140.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.ImXPadS70">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">ImXPadS70</tt><big>(</big><em>pixel1=0.00013</em>, <em>pixel2=0.00013</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ImXPadS70" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.ImXPadS10" title="pyFAI.detectors.ImXPadS10"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.ImXPadS10</span></tt></a></p>
<p>ImXPad detector: ImXPad s70 detector with 1x7modules</p>
<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS70.BORDER_SIZE_RELATIVE">
<tt class="descname">BORDER_SIZE_RELATIVE</tt><em class="property"> = 2.5</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS70.BORDER_SIZE_RELATIVE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS70.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (120, 560)</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS70.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS70.MODULE_SIZE">
<tt class="descname">MODULE_SIZE</tt><em class="property"> = (120, 80)</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS70.MODULE_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS70.PIXEL_EDGES">
<tt class="descname">PIXEL_EDGES</tt><em class="property"> = None</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS70.PIXEL_EDGES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS70.PIXEL_SIZE">
<tt class="descname">PIXEL_SIZE</tt><em class="property"> = (0.00013, 0.00013)</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS70.PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.ImXPadS70.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=0.00013</em>, <em>pixel2=0.00013</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ImXPadS70.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS70.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Imxpad S70']</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS70.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS70.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS70.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Mar345">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Mar345</tt><big>(</big><em>pixel1=0.0001</em>, <em>pixel2=0.0001</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Mar345" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Mar345 Imaging plate detector</p>
<p>In this detector, pixels are always square
The valid image size are 2300, 2000, 1600, 1200, 3450, 3000, 2400, 1800</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Mar345.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (3450, 3450)</em><a class="headerlink" href="#pyFAI.detectors.Mar345.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Mar345.VALID_SIZE">
<tt class="descname">VALID_SIZE</tt><em class="property"> = {2000: 0.00015, 1600: 0.00015, 3000: 0.0001, 2400: 0.0001, 3450: 0.0001, 1200: 0.00015, 2300: 0.00015, 1800: 0.0001}</em><a class="headerlink" href="#pyFAI.detectors.Mar345.VALID_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Mar345.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=0.0001</em>, <em>pixel2=0.0001</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Mar345.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Mar345.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['MAR 345', 'Mar3450']</em><a class="headerlink" href="#pyFAI.detectors.Mar345.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Mar345.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Mar345.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Mar345.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Mar345.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Mar345.guess_binning">
<tt class="descname">guess_binning</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Mar345.guess_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Guess the binning/mode depending on the image shape
:param data: 2-tuple with the shape of the image or the image with a .shape attribute.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.NexusDetector">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">NexusDetector</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.NexusDetector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Class representing a 2D detector loaded from a NeXus file</p>
<dl class="method">
<dt id="pyFAI.detectors.NexusDetector.__init__">
<tt class="descname">__init__</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.NexusDetector.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.NexusDetector.getFit2D">
<tt class="descname">getFit2D</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.NexusDetector.getFit2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to serialize the description of a detector using the Fit2d units</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">representation of the detector easy to serialize</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.NexusDetector.getPyFAI">
<tt class="descname">getPyFAI</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.NexusDetector.getPyFAI" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to serialize the description of a detector using the pyFAI way
with everything in S.I units.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">representation of the detector easy to serialize</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.NexusDetector.load">
<tt class="descname">load</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.NexusDetector.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the detector description from a NeXus file, adapted from:
<a class="reference external" href="http://download.nexusformat.org/sphinx/classes/base_classes/NXdetector.html">http://download.nexusformat.org/sphinx/classes/base_classes/NXdetector.html</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; name of the file on the disk</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pyFAI.detectors.NexusDetector.sload">
<em class="property">classmethod </em><tt class="descname">sload</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.NexusDetector.sload" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate the detector description from a NeXus file, adapted from:
<a class="reference external" href="http://download.nexusformat.org/sphinx/classes/base_classes/NXdetector.html">http://download.nexusformat.org/sphinx/classes/base_classes/NXdetector.html</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; name of the file on the disk</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Detector instance</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Perkin">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Perkin</tt><big>(</big><em>pixel1=0.0002</em>, <em>pixel2=0.0002</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Perkin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Perkin detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Perkin.DEFAULT_PIXEL1">
<tt class="descname">DEFAULT_PIXEL1</tt><em class="property"> = 0.0002</em><a class="headerlink" href="#pyFAI.detectors.Perkin.DEFAULT_PIXEL1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Perkin.DEFAULT_PIXEL2">
<tt class="descname">DEFAULT_PIXEL2</tt><em class="property"> = 0.0002</em><a class="headerlink" href="#pyFAI.detectors.Perkin.DEFAULT_PIXEL2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Perkin.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (4096, 4096)</em><a class="headerlink" href="#pyFAI.detectors.Perkin.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Perkin.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=0.0002</em>, <em>pixel2=0.0002</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Perkin.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Perkin.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Perkin detector', 'Perkin Elmer']</em><a class="headerlink" href="#pyFAI.detectors.Perkin.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Perkin.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Perkin.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Pilatus detector: generic description containing mask algorithm</p>
<p>Sub-classed by Pilatus1M, Pilatus2M and Pilatus6M</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus.MODULE_GAP">
<tt class="descname">MODULE_GAP</tt><em class="property"> = (17, 7)</em><a class="headerlink" href="#pyFAI.detectors.Pilatus.MODULE_GAP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus.MODULE_SIZE">
<tt class="descname">MODULE_SIZE</tt><em class="property"> = (195, 487)</em><a class="headerlink" href="#pyFAI.detectors.Pilatus.MODULE_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Pilatus.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Pilatus.calc_cartesian_positions">
<tt class="descname">calc_cartesian_positions</tt><big>(</big><em>d1=None</em>, <em>d2=None</em>, <em>center=True</em>, <em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus.calc_cartesian_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of each pixel center in cartesian coordinate
and in meter of a couple of coordinates.
The half pixel offset is taken into account here !!!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the Y pixel positions (slow dimension)</li>
<li><strong>d2</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the X pixel positions (fast dimension)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">position in meter of the center of each pixels.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
<p>d1 and d2 must have the same shape, returned array will have
the same shape.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Pilatus.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a generic mask for Pilatus detectors...</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Pilatus.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Pilatus.get_splineFile">
<tt class="descname">get_splineFile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus.get_splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Pilatus.set_splineFile">
<tt class="descname">set_splineFile</tt><big>(</big><em>splineFile=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus.set_splineFile" title="Permalink to this definition">¶</a></dt>
<dd><p>In this case splinefile is a couple filenames</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus.splineFile">
<tt class="descname">splineFile</tt><a class="headerlink" href="#pyFAI.detectors.Pilatus.splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus100k">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus100k</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus100k" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus 100k detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus100k.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (195, 487)</em><a class="headerlink" href="#pyFAI.detectors.Pilatus100k.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus100k.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Pilatus 100k']</em><a class="headerlink" href="#pyFAI.detectors.Pilatus100k.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus1M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus1M</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus1M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus 1M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus1M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1043, 981)</em><a class="headerlink" href="#pyFAI.detectors.Pilatus1M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus1M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Pilatus 1M']</em><a class="headerlink" href="#pyFAI.detectors.Pilatus1M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus200k">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus200k</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus200k" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus 200k detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus200k.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (407, 487)</em><a class="headerlink" href="#pyFAI.detectors.Pilatus200k.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus200k.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Pilatus 200k']</em><a class="headerlink" href="#pyFAI.detectors.Pilatus200k.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus2M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus2M</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus2M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus 2M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus2M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1679, 1475)</em><a class="headerlink" href="#pyFAI.detectors.Pilatus2M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus2M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Pilatus 2M']</em><a class="headerlink" href="#pyFAI.detectors.Pilatus2M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus300k">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus300k</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus300k" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus 300k detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus300k.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (619, 487)</em><a class="headerlink" href="#pyFAI.detectors.Pilatus300k.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus300k.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Pilatus 300k']</em><a class="headerlink" href="#pyFAI.detectors.Pilatus300k.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus300kw">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus300kw</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus300kw" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus 300k-wide detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus300kw.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (195, 1475)</em><a class="headerlink" href="#pyFAI.detectors.Pilatus300kw.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus300kw.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Pilatus 300kw']</em><a class="headerlink" href="#pyFAI.detectors.Pilatus300kw.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus6M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus6M</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus6M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus 6M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus6M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (2527, 2463)</em><a class="headerlink" href="#pyFAI.detectors.Pilatus6M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus6M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Pilatus 6M']</em><a class="headerlink" href="#pyFAI.detectors.Pilatus6M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.PilatusCdTe">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">PilatusCdTe</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus CdTe detector: Like the Pilatus with an extra 3 pixel in the middle
of every module (vertically)</p>
<dl class="method">
<dt id="pyFAI.detectors.PilatusCdTe.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a generic mask for Pilatus detectors...</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.PilatusCdTe1M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">PilatusCdTe1M</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe1M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.PilatusCdTe" title="pyFAI.detectors.PilatusCdTe"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.PilatusCdTe</span></tt></a></p>
<p>Pilatus CdTe 1M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.PilatusCdTe1M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1043, 981)</em><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe1M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.PilatusCdTe1M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Pilatus CdTe 1M', 'Pilatus 1M CdTe', 'Pilatus1M CdTe', 'Pilatus1MCdTe']</em><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe1M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.PilatusCdTe2M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">PilatusCdTe2M</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe2M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.PilatusCdTe" title="pyFAI.detectors.PilatusCdTe"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.PilatusCdTe</span></tt></a></p>
<p>Pilatus CdTe 2M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.PilatusCdTe2M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1679, 1475)</em><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe2M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.PilatusCdTe2M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Pilatus CdTe 2M', 'Pilatus 2M CdTe', 'Pilatus2M CdTe', 'Pilatus2MCdTe']</em><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe2M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.PilatusCdTe300k">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">PilatusCdTe300k</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe300k" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.PilatusCdTe" title="pyFAI.detectors.PilatusCdTe"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.PilatusCdTe</span></tt></a></p>
<p>Pilatus CdTe 300k detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.PilatusCdTe300k.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (619, 487)</em><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe300k.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.PilatusCdTe300k.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Pilatus CdTe 300k', 'Pilatus 300k CdTe', 'Pilatus300k CdTe', 'Pilatus300kCdTe']</em><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe300k.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.PilatusCdTe300kw">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">PilatusCdTe300kw</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe300kw" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.PilatusCdTe" title="pyFAI.detectors.PilatusCdTe"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.PilatusCdTe</span></tt></a></p>
<p>Pilatus CdTe 300k-wide detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.PilatusCdTe300kw.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (195, 1475)</em><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe300kw.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.PilatusCdTe300kw.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Pilatus CdTe 300kw', 'Pilatus 300kw CdTe', 'Pilatus300kw CdTe', 'Pilatus300kwCdTe']</em><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe300kw.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pixium">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pixium</tt><big>(</big><em>pixel1=0.000308</em>, <em>pixel2=0.000308</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pixium" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>PIXIUM 4700 detector</p>
<p>High energy X ray diffraction using the Pixium 4700 flat panel detector
J E Daniels, M Drakopoulos, et al.; Journal of Synchrotron Radiation 16(Pt 4):463-8 · August 2009</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Pixium.DEFAULT_PIXEL1">
<tt class="descname">DEFAULT_PIXEL1</tt><em class="property"> = 0.000154</em><a class="headerlink" href="#pyFAI.detectors.Pixium.DEFAULT_PIXEL1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pixium.DEFAULT_PIXEL2">
<tt class="descname">DEFAULT_PIXEL2</tt><em class="property"> = 0.000154</em><a class="headerlink" href="#pyFAI.detectors.Pixium.DEFAULT_PIXEL2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pixium.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1910, 2480)</em><a class="headerlink" href="#pyFAI.detectors.Pixium.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Pixium.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=0.000308</em>, <em>pixel2=0.000308</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pixium.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Defaults to 2x2 binning</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pixium.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Pixium 4700 detector', 'Thales Electronics']</em><a class="headerlink" href="#pyFAI.detectors.Pixium.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pixium.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Pixium.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RaspberryPi5M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RaspberryPi5M</tt><big>(</big><em>pixel1=1.4e-06</em>, <em>pixel2=1.4e-06</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RaspberryPi5M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>5 Mpix detector from Raspberry Pi</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RaspberryPi5M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1944, 2592)</em><a class="headerlink" href="#pyFAI.detectors.RaspberryPi5M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.RaspberryPi5M.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=1.4e-06</em>, <em>pixel2=1.4e-06</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RaspberryPi5M.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RaspberryPi5M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Picam v1']</em><a class="headerlink" href="#pyFAI.detectors.RaspberryPi5M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RaspberryPi5M.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.RaspberryPi5M.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RaspberryPi8M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RaspberryPi8M</tt><big>(</big><em>pixel1=1.12e-06</em>, <em>pixel2=1.12e-06</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RaspberryPi8M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>8 Mpix detector from Raspberry Pi</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RaspberryPi8M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (2464, 3280)</em><a class="headerlink" href="#pyFAI.detectors.RaspberryPi8M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.RaspberryPi8M.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=1.12e-06</em>, <em>pixel2=1.12e-06</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RaspberryPi8M.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RaspberryPi8M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Picam v2']</em><a class="headerlink" href="#pyFAI.detectors.RaspberryPi8M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RaspberryPi8M.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.RaspberryPi8M.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Rayonix">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Rayonix</tt><big>(</big><em>pixel1=3.2e-05</em>, <em>pixel2=3.2e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Rayonix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<dl class="attribute">
<dt id="pyFAI.detectors.Rayonix.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 3.2e-05}</em><a class="headerlink" href="#pyFAI.detectors.Rayonix.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Rayonix.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (4096, 4096)</em><a class="headerlink" href="#pyFAI.detectors.Rayonix.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Rayonix.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=3.2e-05</em>, <em>pixel2=3.2e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Rayonix.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Rayonix.binning">
<tt class="descname">binning</tt><a class="headerlink" href="#pyFAI.detectors.Rayonix.binning" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Rayonix.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Rayonix.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Rayonix.get_binning">
<tt class="descname">get_binning</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Rayonix.get_binning" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Rayonix.guess_binning">
<tt class="descname">guess_binning</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Rayonix.guess_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Guess the binning/mode depending on the image shape
:param data: 2-tuple with the shape of the image or the image with a .shape attribute.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Rayonix.set_binning">
<tt class="descname">set_binning</tt><big>(</big><em>bin_size=(1</em>, <em>1)</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Rayonix.set_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the &#8220;binning&#8221; of the detector,</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bin_size</strong> (<em>int or (int, int)</em>) &#8211; set the binning of the detector</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Rayonix133">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Rayonix133</tt><big>(</big><em>pixel1=6.4e-05</em>, <em>pixel2=6.4e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Rayonix133" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix 133 2D CCD detector detector also known as mar133</p>
<p>Personnal communication from M. Blum</p>
<p>What should be the default binning factor for those cameras ?</p>
<p>Circular detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Rayonix133.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {8: 0.000256, 1: 3.2e-05, 2: 6.4e-05, 4: 0.000128}</em><a class="headerlink" href="#pyFAI.detectors.Rayonix133.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Rayonix133.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (4096, 4096)</em><a class="headerlink" href="#pyFAI.detectors.Rayonix133.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Rayonix133.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=6.4e-05</em>, <em>pixel2=6.4e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Rayonix133.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Rayonix133.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['MAR133']</em><a class="headerlink" href="#pyFAI.detectors.Rayonix133.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Rayonix133.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Rayonix133.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Circular mask</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Rayonix133.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Rayonix133.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixLx170">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixLx170</tt><big>(</big><em>pixel1=4.42708e-05</em>, <em>pixel2=4.42708e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixLx170" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix lx170 2d CCD Detector (2x1 CCDs).</p>
<p>Nota: this is the same for lx170hs</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixLx170.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 4.42708e-05, 2: 8.85417e-05, 3: 0.0001328125, 4: 0.0001770833, 5: 0.0002213542, 6: 0.000265625, 8: 0.0003541667, 10: 0.0004427083}</em><a class="headerlink" href="#pyFAI.detectors.RayonixLx170.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixLx170.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1920, 3840)</em><a class="headerlink" href="#pyFAI.detectors.RayonixLx170.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.RayonixLx170.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=4.42708e-05</em>, <em>pixel2=4.42708e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixLx170.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixLx170.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix LX170', 'Rayonix LX170-HS', 'Rayonix LX170 HS', 'RayonixLX170HS']</em><a class="headerlink" href="#pyFAI.detectors.RayonixLx170.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixLx170.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.RayonixLx170.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixLx255">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixLx255</tt><big>(</big><em>pixel1=4.42708e-05</em>, <em>pixel2=4.42708e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixLx255" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix lx255 2d Detector (3x1 CCDs)</p>
<p>Nota: this detector is also called lx255hs</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixLx255.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 4.42708e-05, 2: 8.85417e-05, 3: 0.0001328125, 4: 0.0001770833, 5: 0.0002213542, 6: 0.000265625, 8: 0.0003541667, 10: 0.0004427083}</em><a class="headerlink" href="#pyFAI.detectors.RayonixLx255.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixLx255.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1920, 5760)</em><a class="headerlink" href="#pyFAI.detectors.RayonixLx255.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.RayonixLx255.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=4.42708e-05</em>, <em>pixel2=4.42708e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixLx255.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixLx255.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix LX255', 'Rayonix LX255-HS', 'Rayonix LX 255HS', 'RayonixLX225HS']</em><a class="headerlink" href="#pyFAI.detectors.RayonixLx255.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixMx170">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixMx170</tt><big>(</big><em>pixel1=4.42708e-05</em>, <em>pixel2=4.42708e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx170" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix mx170 2d CCD Detector (2x2 CCDs).</p>
<p>Nota: this is the same for mx170hs</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx170.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 4.42708e-05, 2: 8.85417e-05, 3: 0.0001328125, 4: 0.0001770833, 5: 0.0002213542, 6: 0.000265625, 8: 0.0003541667, 10: 0.0004427083}</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx170.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx170.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (3840, 3840)</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx170.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.RayonixMx170.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=4.42708e-05</em>, <em>pixel2=4.42708e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx170.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx170.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix MX170', 'Rayonix MX170-HS', 'RayonixMX170HS', 'Rayonix MX170 HS']</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx170.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixMx225">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixMx225</tt><big>(</big><em>pixel1=7.3242e-05</em>, <em>pixel2=7.3242e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx225" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix mx225 2D CCD detector detector</p>
<p>Nota: this is the same definition for mx225he
Personnal communication from M. Blum</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx225.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {8: 0.000292969, 1: 3.6621e-05, 2: 7.3242e-05, 3: 0.000109971, 4: 0.000146484}</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx225.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx225.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (6144, 6144)</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx225.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.RayonixMx225.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=7.3242e-05</em>, <em>pixel2=7.3242e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx225.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx225.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix MX225']</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx225.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx225.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx225.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixMx225hs">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixMx225hs</tt><big>(</big><em>pixel1=7.8125e-05</em>, <em>pixel2=7.8125e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx225hs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix mx225hs 2D CCD detector detector</p>
<p>Pixel size from a personnal communication from M. Blum</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx225hs.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 3.90625e-05, 2: 7.8125e-05, 3: 0.0001171875, 4: 0.00015625, 5: 0.0001953125, 6: 0.000234375, 8: 0.0003125, 10: 0.000390625}</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx225hs.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx225hs.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (5760, 5760)</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx225hs.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.RayonixMx225hs.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=7.8125e-05</em>, <em>pixel2=7.8125e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx225hs.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx225hs.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix MX225HS', 'Rayonix MX225 HS']</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx225hs.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx225hs.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx225hs.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixMx300">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixMx300</tt><big>(</big><em>pixel1=7.3242e-05</em>, <em>pixel2=7.3242e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx300" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix mx300 2D detector (4x4 CCDs)</p>
<p>Pixel size from a personnal communication from M. Blum</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx300.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {8: 0.000292969, 1: 3.6621e-05, 2: 7.3242e-05, 3: 0.000109971, 4: 0.000146484}</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx300.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx300.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (8192, 8192)</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx300.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.RayonixMx300.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=7.3242e-05</em>, <em>pixel2=7.3242e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx300.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx300.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix mx300']</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx300.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx300.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx300.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixMx300hs">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixMx300hs</tt><big>(</big><em>pixel1=7.8125e-05</em>, <em>pixel2=7.8125e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx300hs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix mx300hs 2D detector (4x4 CCDs)</p>
<p>Pixel size from a personnal communication from M. Blum</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx300hs.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 3.90625e-05, 2: 7.8125e-05, 3: 0.0001171875, 4: 0.00015625, 5: 0.0001953125, 6: 0.000234375, 8: 0.0003125, 10: 0.000390625}</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx300hs.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx300hs.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (7680, 7680)</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx300hs.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.RayonixMx300hs.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=7.8125e-05</em>, <em>pixel2=7.8125e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx300hs.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx300hs.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix MX300HS', 'Rayonix MX300 HS']</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx300hs.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx300hs.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx300hs.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixMx325">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixMx325</tt><big>(</big><em>pixel1=7.9346e-05</em>, <em>pixel2=7.9346e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx325" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix mx325 and mx325he 2D detector (4x4 CCD chips)</p>
<p>Pixel size from a personnal communication from M. Blum</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx325.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {8: 0.000317383, 1: 3.9673e-05, 2: 7.9346e-05, 3: 0.000119135, 4: 0.000158691}</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx325.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx325.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (8192, 8192)</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx325.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.RayonixMx325.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=7.9346e-05</em>, <em>pixel2=7.9346e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx325.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx325.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix MX325']</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx325.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixMx340hs">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixMx340hs</tt><big>(</big><em>pixel1=8.85417e-05</em>, <em>pixel2=8.85417e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx340hs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix mx340hs 2D detector (4x4 CCDs)</p>
<p>Pixel size from a personnal communication from M. Blum</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx340hs.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 4.42708e-05, 2: 8.85417e-05, 3: 0.0001328125, 4: 0.0001770833, 5: 0.0002213542, 6: 0.000265625, 8: 0.0003541667, 10: 0.0004427083}</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx340hs.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx340hs.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (7680, 7680)</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx340hs.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.RayonixMx340hs.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=8.85417e-05</em>, <em>pixel2=8.85417e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx340hs.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx340hs.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix MX340HS', 'Rayonix MX340HS']</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx340hs.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx340hs.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx340hs.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixMx425hs">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixMx425hs</tt><big>(</big><em>pixel1=4.42708e-05</em>, <em>pixel2=4.42708e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx425hs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix mx425hs 2D CCD camera (5x5 CCD chip)</p>
<p>Pixel size from a personnal communication from M. Blum</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx425hs.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 4.42708e-05, 2: 8.85417e-05, 3: 0.0001328125, 4: 0.0001770833, 5: 0.0002213542, 6: 0.000265625, 8: 0.0003541667, 10: 0.0004427083}</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx425hs.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx425hs.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (9600, 9600)</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx425hs.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.RayonixMx425hs.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=4.42708e-05</em>, <em>pixel2=4.42708e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx425hs.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx425hs.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix MX425HS', 'Rayonix MX425 HS']</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx425hs.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixSx165">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixSx165</tt><big>(</big><em>pixel1=3.95e-05</em>, <em>pixel2=3.95e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixSx165" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix sx165 2d Detector also known as MAR165.</p>
<p>Circular detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx165.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {8: 0.000316, 1: 3.95e-05, 2: 7.9e-05, 3: 0.000118616, 4: 0.000158}</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx165.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx165.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (4096, 4096)</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx165.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.RayonixSx165.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=3.95e-05</em>, <em>pixel2=3.95e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixSx165.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx165.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['MAR165', 'Rayonix Sx165']</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx165.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.RayonixSx165.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixSx165.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Circular mask</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx165.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx165.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixSx200">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixSx200</tt><big>(</big><em>pixel1=4.8e-05</em>, <em>pixel2=4.8e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixSx200" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix sx200 2d CCD Detector.</p>
<p>Pixel size are personnal communication from M. Blum.</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx200.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {8: 0.000384, 1: 4.8e-05, 2: 9.6e-05, 3: 0.000144, 4: 0.000192}</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx200.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx200.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (4096, 4096)</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx200.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.RayonixSx200.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=4.8e-05</em>, <em>pixel2=4.8e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixSx200.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx200.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix sx200']</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx200.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixSx30hs">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixSx30hs</tt><big>(</big><em>pixel1=1.5625e-05</em>, <em>pixel2=1.5625e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixSx30hs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix sx30hs 2D CCD camera (1 CCD chip)</p>
<p>Pixel size from a personnal communication from M. Blum</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx30hs.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 1.5625e-05, 2: 3.125e-05, 3: 4.6875e-05, 4: 6.25e-05, 5: 7.8125e-05, 6: 9.375e-05, 8: 0.000125, 10: 0.00015625}</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx30hs.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx30hs.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1920, 1920)</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx30hs.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.RayonixSx30hs.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=1.5625e-05</em>, <em>pixel2=1.5625e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixSx30hs.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx30hs.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix SX30HS', 'Rayonix SX30 HS']</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx30hs.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixSx85hs">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixSx85hs</tt><big>(</big><em>pixel1=4.42708e-05</em>, <em>pixel2=4.42708e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixSx85hs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix sx85hs 2D CCD camera (1 CCD chip)</p>
<p>Pixel size from a personnal communication from M. Blum</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx85hs.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 4.42708e-05, 2: 8.85417e-05, 3: 0.0001328125, 4: 0.0001770833, 5: 0.0002213542, 6: 0.000265625, 8: 0.0003541667, 10: 0.0004427083}</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx85hs.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx85hs.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1920, 1920)</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx85hs.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.RayonixSx85hs.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=4.42708e-05</em>, <em>pixel2=4.42708e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixSx85hs.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx85hs.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix SX85HS', 'Rayonix SX85 HS']</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx85hs.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Titan">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Titan</tt><big>(</big><em>pixel1=6e-05</em>, <em>pixel2=6e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Titan" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Titan CCD detector from Agilent. Mask not handled</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Titan.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (2048, 2048)</em><a class="headerlink" href="#pyFAI.detectors.Titan.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Titan.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=6e-05</em>, <em>pixel2=6e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Titan.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Titan.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Titan 2k x 2k', 'OXD Titan', 'Agilent Titan']</em><a class="headerlink" href="#pyFAI.detectors.Titan.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Titan.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Titan.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Titan.uniform_pixel">
<tt class="descname">uniform_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Titan.uniform_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Xpad_flat">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Xpad_flat</tt><big>(</big><em>pixel1=0.00013</em>, <em>pixel2=0.00013</em>, <em>max_shape=None</em>, <em>module_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Xpad_flat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.ImXPadS10" title="pyFAI.detectors.ImXPadS10"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.ImXPadS10</span></tt></a></p>
<p>Xpad detector: generic description for
ImXPad detector with 8x7modules</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Xpad_flat.BORDER_PIXEL_SIZE_RELATIVE">
<tt class="descname">BORDER_PIXEL_SIZE_RELATIVE</tt><em class="property"> = 2.5</em><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.BORDER_PIXEL_SIZE_RELATIVE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Xpad_flat.IS_CONTIGUOUS">
<tt class="descname">IS_CONTIGUOUS</tt><em class="property"> = False</em><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.IS_CONTIGUOUS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Xpad_flat.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (960, 560)</em><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Xpad_flat.MODULE_GAP">
<tt class="descname">MODULE_GAP</tt><em class="property"> = (0.00357, 0)</em><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.MODULE_GAP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Xpad_flat.MODULE_SIZE">
<tt class="descname">MODULE_SIZE</tt><em class="property"> = (120, 80)</em><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.MODULE_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Xpad_flat.PIXEL_SIZE">
<tt class="descname">PIXEL_SIZE</tt><em class="property"> = (0.00013, 0.00013)</em><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Xpad_flat.__init__">
<tt class="descname">__init__</tt><big>(</big><em>pixel1=0.00013</em>, <em>pixel2=0.00013</em>, <em>max_shape=None</em>, <em>module_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Xpad_flat.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Xpad S540 flat', 'd5']</em><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Xpad_flat.calc_cartesian_positions">
<tt class="descname">calc_cartesian_positions</tt><big>(</big><em>d1=None</em>, <em>d2=None</em>, <em>center=True</em>, <em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.calc_cartesian_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of each pixel center in cartesian coordinate
and in meter of a couple of coordinates.
The half pixel offset is taken into account here !!!
Adapted to Nexus detector definition</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the Y pixel positions (slow dimension)</li>
<li><strong>d2</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the X pixel positions (fast dimension)</li>
<li><strong>center</strong> &#8211; retrieve the coordinate of the center of the pixel</li>
<li><strong>use_cython</strong> &#8211; set to False to test Numpy implementation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">position in meter of the center of each pixels.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
<p>d1 and d2 must have the same shape, returned array will have
the same shape.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Xpad_flat.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a generic mask for Xpad detectors...
discards the first line and raw form all modules:
those are 2.5x bigger and often mis - behaving</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Xpad_flat.calc_pixels_edges">
<tt class="descname">calc_pixels_edges</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.calc_pixels_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of the pixel edges, specific to the S540, d5 detector</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Xpad_flat.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Xpad_flat.get_pixel_corners">
<tt class="descname">get_pixel_corners</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.get_pixel_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of the corner of the pixels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">4D array containing:
pixel index (slow dimension)
pixel index (fast dimension)
corner index (A, B, C or D), triangles or hexagons can be handled the same way
vertex position (z,y,x)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Xpad_flat.uniform_pixel">
<tt class="descname">uniform_pixel</tt><em class="property"> = False</em><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.uniform_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.spline">
<span id="spline-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">spline</span></tt> Module<a class="headerlink" href="#module-pyFAI.spline" title="Permalink to this headline">¶</a></h1>
<p>This is piece of software aims at manipulating spline files
describing for geometric corrections of the 2D detectors using cubic-spline.</p>
<p>Mainly used at ESRF with FReLoN CCD camera.</p>
<dl class="class">
<dt id="pyFAI.spline.Spline">
<em class="property">class </em><tt class="descclassname">pyFAI.spline.</tt><tt class="descname">Spline</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class is a python representation of the spline file</p>
<p>Those file represent cubic splines for 2D detector distortions and
makes heavy use of fitpack (dierckx in netlib) &#8212; A Python-C
wrapper to FITPACK (by P. Dierckx). FITPACK is a collection of
FORTRAN programs for curve and surface fitting with splines and
tensor product splines.  See
_http://www.cs.kuleuven.ac.be/cwis/research/nalag/research/topics/fitpack.html
or _http://www.netlib.org/dierckx/index.html</p>
<dl class="method">
<dt id="pyFAI.spline.Spline.__init__">
<tt class="descname">__init__</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the constructor of the Spline class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>str</em>) &#8211; name of the ascii file containing the spline</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.array2spline">
<tt class="descname">array2spline</tt><big>(</big><em>smoothing=1000</em>, <em>timing=False</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.array2spline" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the spline coefficients from the displacements
matrix using fitpack.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>smoothing</strong> (<em>float</em>) &#8211; the greater the smoothing, the fewer the number of knots remaining</li>
<li><strong>timing</strong> (<em>bool</em>) &#8211; print the profiling of the calculation</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.bin">
<tt class="descname">bin</tt><big>(</big><em>binning=None</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the binning of a spline (same camera with different binning)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>binning</strong> &#8211; binning factor as integer or 2-tuple of integers</td>
</tr>
<tr class="field-even field"><th class="field-name">Type:</th><td class="field-body">int or (int, int)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.comparison">
<tt class="descname">comparison</tt><big>(</big><em>ref</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.comparison" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares the current spline distortion with a reference</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ref</strong> (<em>Spline instance</em>) &#8211; another spline file</li>
<li><strong>verbose</strong> (<em>bool</em>) &#8211; print or not pylab plots</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">True or False depending if the splines are the same or not</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.correct">
<tt class="descname">correct</tt><big>(</big><em>pos</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.correct" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.fliplr">
<tt class="descname">fliplr</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.fliplr" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip the spline
:return: new spline object</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.fliplrud">
<tt class="descname">fliplrud</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.fliplrud" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip the spline left-right and up-down
:return: new spline object</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.flipud">
<tt class="descname">flipud</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.flipud" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip the spline up-down
:return: new spline object</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.getPixelSize">
<tt class="descname">getPixelSize</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.getPixelSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of the pixel from as a 2-tuple of floats expressed
in meters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the size of the pixel from a 2D detector</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">2-tuple of floats expressed in meter.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.read">
<tt class="descname">read</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.read" title="Permalink to this definition">¶</a></dt>
<dd><p>read an ascii spline file from file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>str</em>) &#8211; file containing the cubic spline distortion file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.setPixelSize">
<tt class="descname">setPixelSize</tt><big>(</big><em>pixelSize</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.setPixelSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the size of the pixel from a 2-tuple of floats expressed
in meters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param:</th><td class="field-body">pixel size in meter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.spline2array">
<tt class="descname">spline2array</tt><big>(</big><em>timing=False</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.spline2array" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the displacement matrix using fitpack
bisplev(x, y, tck, dx = 0, dy = 0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>timing</strong> (<em>bool</em>) &#8211; profile the calculation or not</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Nothing !</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float or ndarray</td>
</tr>
</tbody>
</table>
<p>Evaluate a bivariate B-spline and its derivatives. Return a
rank-2 array of spline function values (or spline derivative
values) at points given by the cross-product of the rank-1
arrays x and y. In special cases, return an array or just a
float if either x or y or both are floats.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.splineFuncX">
<tt class="descname">splineFuncX</tt><big>(</big><em>x</em>, <em>y</em>, <em>list_of_points=False</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.splineFuncX" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the displacement matrix using fitpack for the X
direction on the given grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>ndarray</em>) &#8211; points of the grid in the x direction</li>
<li><strong>y</strong> (<em>ndarray</em>) &#8211; points of the grid  in the y direction</li>
<li><strong>list_of_points</strong> &#8211; if true, consider the zip(x,y) instead of the of the square array</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">displacement matrix for the X direction</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.splineFuncY">
<tt class="descname">splineFuncY</tt><big>(</big><em>x</em>, <em>y</em>, <em>list_of_points=False</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.splineFuncY" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the displacement matrix using fitpack for the Y
direction</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>ndarray</em>) &#8211; points in the x direction</li>
<li><strong>y</strong> (<em>ndarray</em>) &#8211; points in the y direction</li>
<li><strong>list_of_points</strong> &#8211; if true, consider the zip(x,y) instead of the of the square array</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">displacement matrix for the Y direction</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.tilt">
<tt class="descname">tilt</tt><big>(</big><em>center=(0.0</em>, <em>0.0)</em>, <em>tiltAngle=0.0</em>, <em>tiltPlanRot=0.0</em>, <em>distanceSampleDetector=1.0</em>, <em>timing=False</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.tilt" title="Permalink to this definition">¶</a></dt>
<dd><p>The tilt method apply a virtual tilt on the detector, the
point of tilt is given by the center</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>center</strong> (<em>2-tuple of floats</em>) &#8211; position of the point of tilt, this point will not be moved.</li>
<li><strong>tiltAngle</strong> (<em>float in the range [-90:+90] degrees</em>) &#8211; the value of the tilt in degrees</li>
<li><strong>tiltPlanRot</strong> (<em>Float in the range [-180:180]</em>) &#8211; the rotation of the tilt plan with the Ox axis (0 deg for y axis invariant, 90 deg for x axis invariant)</li>
<li><strong>distanceSampleDetector</strong> (<em>float</em>) &#8211; the distance from sample to detector in meter (along the beam, so distance from sample to center)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">tilted Spline instance</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Spline</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.write">
<tt class="descname">write</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.write" title="Permalink to this definition">¶</a></dt>
<dd><p>save the cubic spline in an ascii file usable with Fit2D or
SPD</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>str</em>) &#8211; name of the file containing the cubic spline distortion file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.writeEDF">
<tt class="descname">writeEDF</tt><big>(</big><em>basename</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.writeEDF" title="Permalink to this definition">¶</a></dt>
<dd><p>save the distortion matrices into a couple of files called
basename-x.edf and basename-y.edf</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>basename</strong> (<em>str</em>) &#8211; base of the name used to save the data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.zeros">
<tt class="descname">zeros</tt><big>(</big><em>xmin=0.0</em>, <em>ymin=0.0</em>, <em>xmax=2048.0</em>, <em>ymax=2048.0</em>, <em>pixSize=None</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a spline file with no ( zero ) displacement.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>xmin</strong> (<em>float</em>) &#8211; minimum coordinate in x, usually zero</li>
<li><strong>xmax</strong> (<em>float</em>) &#8211; maximum coordinate in x (+1) usually 2048</li>
<li><strong>ymin</strong> (<em>float</em>) &#8211; minimum coordinate in y, usually zero</li>
<li><strong>ymax</strong> (<em>float</em>) &#8211; maximum coordinate y (+1) usually 2048</li>
<li><strong>pixSize</strong> (<em>float</em>) &#8211; size of the pixel</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.zeros_like">
<tt class="descname">zeros_like</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.zeros_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a spline file with no ( zero ) displacement with the
same shape as the other one given.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<em>Spline instance</em>) &#8211; another Spline instance</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.spline.main">
<tt class="descclassname">pyFAI.spline.</tt><tt class="descname">main</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.spline.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Some tests ....</p>
</dd></dl>

</div>
<div class="section" id="module-pyFAI.opencl">
<span id="opencl-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">opencl</span></tt> Module<a class="headerlink" href="#module-pyFAI.opencl" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.opencl.Device">
<em class="property">class </em><tt class="descclassname">pyFAI.opencl.</tt><tt class="descname">Device</tt><big>(</big><em>name='None'</em>, <em>dtype=None</em>, <em>version=None</em>, <em>driver_version=None</em>, <em>extensions=''</em>, <em>memory=None</em>, <em>available=None</em>, <em>cores=None</em>, <em>frequency=None</em>, <em>flop_core=None</em>, <em>idx=0</em>, <em>workgroup=1</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.Device" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple class that contains the structure of an OpenCL device</p>
<dl class="method">
<dt id="pyFAI.opencl.Device.__init__">
<tt class="descname">__init__</tt><big>(</big><em>name='None'</em>, <em>dtype=None</em>, <em>version=None</em>, <em>driver_version=None</em>, <em>extensions=''</em>, <em>memory=None</em>, <em>available=None</em>, <em>cores=None</em>, <em>frequency=None</em>, <em>flop_core=None</em>, <em>idx=0</em>, <em>workgroup=1</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.Device.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple container with some important data for the OpenCL device description:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; name of the device</li>
<li><strong>dtype</strong> &#8211; device type: CPU/GPU/ACC...</li>
<li><strong>version</strong> &#8211; driver version</li>
<li><strong>driver_version</strong> &#8211; </li>
<li><strong>extensions</strong> &#8211; List of opencl extensions</li>
<li><strong>memory</strong> &#8211; maximum memory available on the device</li>
<li><strong>available</strong> &#8211; is the device desactivated or not</li>
<li><strong>cores</strong> &#8211; number of SM/cores</li>
<li><strong>frequency</strong> &#8211; frequency of the device</li>
<li><strong>flop_cores</strong> &#8211; Flopating Point operation per core per cycle</li>
<li><strong>idx</strong> &#8211; index of the device within the platform</li>
<li><strong>workgroup</strong> &#8211; max workgroup size</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.opencl.Device.pretty_print">
<tt class="descname">pretty_print</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.opencl.Device.pretty_print" title="Permalink to this definition">¶</a></dt>
<dd><p>Complete device description</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">string</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.opencl.OpenCL">
<em class="property">class </em><tt class="descclassname">pyFAI.opencl.</tt><tt class="descname">OpenCL</tt><a class="headerlink" href="#pyFAI.opencl.OpenCL" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple class that wraps the structure ocl_tools_extended.h</p>
<p>This is a static class.
ocl should be the only instance and shared among all python modules.</p>
<dl class="attribute">
<dt id="pyFAI.opencl.OpenCL.comput_cap">
<tt class="descname">comput_cap</tt><em class="property"> = (5, 0)</em><a class="headerlink" href="#pyFAI.opencl.OpenCL.comput_cap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.opencl.OpenCL.context_cache">
<tt class="descname">context_cache</tt><em class="property"> = {}</em><a class="headerlink" href="#pyFAI.opencl.OpenCL.context_cache" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.opencl.OpenCL.create_context">
<tt class="descname">create_context</tt><big>(</big><em>devicetype='ALL'</em>, <em>useFp64=False</em>, <em>platformid=None</em>, <em>deviceid=None</em>, <em>cached=True</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.OpenCL.create_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose a device and initiate a context.</p>
<p>Devicetypes can be GPU,gpu,CPU,cpu,DEF,ACC,ALL.
Suggested are GPU,CPU.
For each setting to work there must be such an OpenCL device and properly installed.
E.g.: If Nvidia driver is installed, GPU will succeed but CPU will fail. The AMD SDK kit is required for CPU via OpenCL.
:param devicetype: string in [&#8220;cpu&#8221;,&#8221;gpu&#8221;, &#8220;all&#8221;, &#8220;acc&#8221;]
:param useFp64: boolean specifying if double precision will be used
:param platformid: integer
:param devid: integer
:return: OpenCL context on the selected device</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.opencl.OpenCL.device_from_context">
<tt class="descname">device_from_context</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.OpenCL.device_from_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the Device from the context</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>context</strong> &#8211; OpenCL context</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">instance of Device</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.opencl.OpenCL.flop_core">
<tt class="descname">flop_core</tt><em class="property"> = 4</em><a class="headerlink" href="#pyFAI.opencl.OpenCL.flop_core" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.opencl.OpenCL.get_platform">
<tt class="descname">get_platform</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.OpenCL.get_platform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a platform according</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>int or str</em>) &#8211; identifier for a platform, either an Id (int) or it&#8217;s name</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.opencl.OpenCL.idd">
<tt class="descname">idd</tt><em class="property"> = 0</em><a class="headerlink" href="#pyFAI.opencl.OpenCL.idd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.opencl.OpenCL.idx">
<tt class="descname">idx</tt><em class="property"> = 2</em><a class="headerlink" href="#pyFAI.opencl.OpenCL.idx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.opencl.OpenCL.nb_devices">
<tt class="descname">nb_devices</tt><em class="property"> = 4</em><a class="headerlink" href="#pyFAI.opencl.OpenCL.nb_devices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.opencl.OpenCL.platforms">
<tt class="descname">platforms</tt><em class="property"> = [Portable Computing Language, NVIDIA CUDA, Intel(R) OpenCL]</em><a class="headerlink" href="#pyFAI.opencl.OpenCL.platforms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.opencl.OpenCL.select_device">
<tt class="descname">select_device</tt><big>(</big><em>dtype='ALL'</em>, <em>memory=None</em>, <em>extensions=None</em>, <em>best=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.OpenCL.select_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Select a device based on few parameters (at the end, keep the one with most memory)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>type</strong> &#8211; &#8220;gpu&#8221; or &#8220;cpu&#8221; or &#8220;all&#8221; ....</li>
<li><strong>memory</strong> &#8211; minimum amount of memory (int)</li>
<li><strong>extensions</strong> &#8211; list of extensions to be present</li>
<li><strong>best</strong> &#8211; shall we look for the</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.opencl.OpenCL.workgroup">
<tt class="descname">workgroup</tt><em class="property"> = 8192</em><a class="headerlink" href="#pyFAI.opencl.OpenCL.workgroup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.opencl.Platform">
<em class="property">class </em><tt class="descclassname">pyFAI.opencl.</tt><tt class="descname">Platform</tt><big>(</big><em>name='None'</em>, <em>vendor='None'</em>, <em>version=None</em>, <em>extensions=None</em>, <em>idx=0</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.Platform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple class that contains the structure of an OpenCL platform</p>
<dl class="method">
<dt id="pyFAI.opencl.Platform.__init__">
<tt class="descname">__init__</tt><big>(</big><em>name='None'</em>, <em>vendor='None'</em>, <em>version=None</em>, <em>extensions=None</em>, <em>idx=0</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.Platform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Class containing all descriptions of a platform and all devices description within that platform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; platform name</li>
<li><strong>vendor</strong> &#8211; name of the brand/vendor</li>
<li><strong>version</strong> &#8211; </li>
<li><strong>extension</strong> &#8211; list of the extension provided by the platform to all of its devices</li>
<li><strong>idx</strong> &#8211; index of the platform</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.opencl.Platform.add_device">
<tt class="descname">add_device</tt><big>(</big><em>device</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.Platform.add_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Add new device to the platform</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>device</strong> &#8211; Device instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.opencl.Platform.get_device">
<tt class="descname">get_device</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.Platform.get_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a device according to key</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>int or str</em>) &#8211; identifier for a device, either it&#8217;s id (int) or it&#8217;s name</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.opencl.allocate_cl_buffers">
<tt class="descclassname">pyFAI.opencl.</tt><tt class="descname">allocate_cl_buffers</tt><big>(</big><em>buffers</em>, <em>device=None</em>, <em>context=None</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.allocate_cl_buffers" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>buffers</strong> &#8211; the buffers info use to create the pyopencl.Buffer</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a dict containing the instanciated pyopencl.Buffer</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">dict(str, pyopencl.Buffer)</td>
</tr>
</tbody>
</table>
<p>This method instanciate the pyopencl.Buffer from the buffers
description.</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.opencl.release_cl_buffers">
<tt class="descclassname">pyFAI.opencl.</tt><tt class="descname">release_cl_buffers</tt><big>(</big><em>cl_buffers</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.release_cl_buffers" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cl_buffer</strong> (<em>dict(str, pyopencl.Buffer)</em>) &#8211; the buffer you want to release</td>
</tr>
</tbody>
</table>
<p>This method release the memory of the buffers store in the dict</p>
</dd></dl>

</div>
<div class="section" id="module-pyFAI.ocl_azim">
<span id="ocl-azim-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">ocl_azim</span></tt> Module<a class="headerlink" href="#module-pyFAI.ocl_azim" title="Permalink to this headline">¶</a></h1>
<p>C++ less implementation of Dimitris&#8217; code based on PyOpenCL</p>
<dl class="docutils">
<dt>TODO and trick from dimitris still missing:</dt>
<dd><ul class="first last simple">
<li>dark-current subtraction is still missing</li>
<li>In fact you might want to consider doing the conversion on the GPU when
possible. Think about it, you have a uint16 to float which for large arrays
was slow.. You load on the graphic card a uint16 (2x transfer speed) and
you convert to float inside so it should be blazing fast.</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="pyFAI.ocl_azim.Integrator1d">
<em class="property">class </em><tt class="descclassname">pyFAI.ocl_azim.</tt><tt class="descname">Integrator1d</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Attempt to implements ocl_azim using pyopencl</p>
<dl class="attribute">
<dt id="pyFAI.ocl_azim.Integrator1d.BLOCK_SIZE">
<tt class="descname">BLOCK_SIZE</tt><em class="property"> = 128</em><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.BLOCK_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.__init__">
<tt class="descname">__init__</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; file in which profiling information are saved</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.clean">
<tt class="descname">clean</tt><big>(</big><em>preserve_context=False</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>Free OpenCL related resources allocated by the library.</p>
<p>clean() is used to reinitiate the library back in a vanilla
state.  It may be asked to preserve the context created by
init or completely clean up OpenCL. Guard/Status flags that
are set will be reset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>preserve_context</strong> (<em>bool</em>) &#8211; preserves or destroys all OpenCL resources</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.configure">
<tt class="descname">configure</tt><big>(</big><em>kernel=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.configure" title="Permalink to this definition">¶</a></dt>
<dd><p>The method configure() allocates the OpenCL resources required
and compiled the OpenCL kernels.  An active context must exist
before a call to configure() and getConfiguration() must have
been called at least once. Since the compiled OpenCL kernels
carry some information on the integration parameters, a change
to any of the parameters of getConfiguration() requires a
subsequent call to configure() for them to take effect.</p>
<p>If a configuration exists and configure() is called, the
configuration is cleaned up first to avoid OpenCL memory leaks</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kernel_path</strong> &#8211; is the path to the actual kernel</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.execute">
<tt class="descname">execute</tt><big>(</big><em>image</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a 1D azimuthal integration</p>
<p>execute() may be called only after an OpenCL device is
configured and a Tth array has been loaded (at least once) It
takes the input image and based on the configuration provided
earlier it performs the 1D integration.  Notice that if the
provided image is bigger than N then only N points will be
taked into account, while if the image is smaller than N the
result may be catastrophic.  set/unset and loadTth methods
have a direct impact on the execute() method.  All the rest of
the methods will require at least a new configuration via
configure().</p>
<p>Takes an image, integrate and return the histogram and weights</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image</strong> &#8211; image to be processed as a numpy array</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">tth_out, histogram, bins</td>
</tr>
</tbody>
</table>
<p>TODO: to improve performances, the image should be casted to
float32 in an optimal way: currently using numpy machinery but
would be better if done in OpenCL</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.getConfiguration">
<tt class="descname">getConfiguration</tt><big>(</big><em>Nimage</em>, <em>Nbins</em>, <em>useFp64=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.getConfiguration" title="Permalink to this definition">¶</a></dt>
<dd><p>getConfiguration gets the description of the integrations
to be performed and keeps an internal copy</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>Nimage</strong> &#8211; number of pixel in image</li>
<li><strong>Nbins</strong> &#8211; number of bins in regrouped histogram</li>
<li><strong>useFp64</strong> &#8211; use double precision. By default the same as init!</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.get_status">
<tt class="descname">get_status</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.get_status" title="Permalink to this definition">¶</a></dt>
<dd><p>return a dictionnary with the status of the integrator: for
compatibilty with former implementation</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.init">
<tt class="descname">init</tt><big>(</big><em>devicetype='GPU'</em>, <em>useFp64=True</em>, <em>platformid=None</em>, <em>deviceid=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial configuration: Choose a device and initiate a
context.  Devicetypes can be GPU, gpu, CPU, cpu, DEF, ACC,
ALL. Suggested are GPU,CPU. For each setting to work there
must be such an OpenCL device and properly installed. E.g.: If
Nvidia driver is installed, GPU will succeed but CPU will
fail. The AMD SDK kit (AMD APP) is required for CPU via
OpenCL.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>devicetype</strong> &#8211; string in [&#8220;cpu&#8221;,&#8221;gpu&#8221;, &#8220;all&#8221;, &#8220;acc&#8221;]</li>
<li><strong>useFp64</strong> &#8211; boolean specifying if double precision will be used</li>
<li><strong>platformid</strong> &#8211; integer</li>
<li><strong>devid</strong> &#8211; integer</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.loadTth">
<tt class="descname">loadTth</tt><big>(</big><em>tth</em>, <em>dtth</em>, <em>tth_min=None</em>, <em>tth_max=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.loadTth" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the 2th arrays along with the min and max value.</p>
<p>loadTth maybe be recalled at any time of the execution in
order to update the 2th arrays.</p>
<p>loadTth is required and must be called at least once after a
configure()</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.log">
<tt class="descname">log</tt><big>(</big><em>**kwarg</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.log" title="Permalink to this definition">¶</a></dt>
<dd><p>log in a file all opencl events</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.setDummyValue">
<tt class="descname">setDummyValue</tt><big>(</big><em>dummy</em>, <em>delta_dummy</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.setDummyValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Enables dummy value functionality and uploads the value to the
OpenCL device.</p>
<p>Image values that are similar to the dummy value are set to 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dummy</strong> &#8211; value in image of missing values (masked pixels?)</li>
<li><strong>delta_dummy</strong> &#8211; precision for dummy values</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.setMask">
<tt class="descname">setMask</tt><big>(</big><em>mask</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.setMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Enables the use of a Mask during integration. The Mask can be
updated by recalling setMask at any point.</p>
<p>The Mask must be a PyFAI Mask. Pixels with 0 are masked
out. TODO: check and invert!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mask</strong> &#8211; numpy.ndarray of integer.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.setRange">
<tt class="descname">setRange</tt><big>(</big><em>lowerBound</em>, <em>upperBound</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.setRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Instructs the program to use a user - defined range for 2th
values</p>
<p>setRange is optional. By default the integration will use the
tth_min and tth_max given by loadTth() as integration
range. When setRange is called it sets a new integration range
without affecting the 2th array. All values outside that range
will then be discarded when interpolating.  Currently, if the
interval of 2th (2th + -d2th) is not all inside the range
specified, it is discarded. The bins of the histogram are
RESCALED to the defined range and not the original tth_max -
tth_min range.</p>
<p>setRange can be called at any point and as many times required
after a valid configuration is created.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lowerBound</strong> (<em>float</em>) &#8211; lower bound of the integration range</li>
<li><strong>upperBound</strong> (<em>float</em>) &#8211; upper bound of the integration range</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.setSolidAngle">
<tt class="descname">setSolidAngle</tt><big>(</big><em>solidAngle</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.setSolidAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Enables SolidAngle correction and uploads the suitable array
to the OpenCL device.</p>
<p>By default the program will assume no solidangle correction
unless setSolidAngle() is called.  From then on, all
integrations will be corrected via the SolidAngle array.</p>
<p>If the SolidAngle array needs to be changes, one may just call
setSolidAngle() again with that array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>solidAngle</strong> (<em>ndarray</em>) &#8211; the solid angle of the given pixel</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.unsetDummyValue">
<tt class="descname">unsetDummyValue</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.unsetDummyValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable a dummy value.
May be re-enabled at any time by setDummyValue</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.unsetMask">
<tt class="descname">unsetMask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.unsetMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Disables the use of a Mask from that point.
It may be re-enabled at any point via setMask</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.unsetRange">
<tt class="descname">unsetRange</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.unsetRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable the use of a user-defined 2th range and revert to
tth_min,tth_max range</p>
<p>unsetRange instructs the program to revert to its default
integration range. If the method is called when no
user-defined range had been previously specified, no action
will be performed</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.unsetSolidAngle">
<tt class="descname">unsetSolidAngle</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.unsetSolidAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Instructs the program to not perform solidangle correction from now on.</p>
<p>SolidAngle correction may be turned back on at any point</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.ocl_azim_lut">
<span id="ocl-azim-lut-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">ocl_azim_lut</span></tt> Module<a class="headerlink" href="#module-pyFAI.ocl_azim_lut" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.ocl_azim_lut.OCL_LUT_Integrator">
<em class="property">class </em><tt class="descclassname">pyFAI.ocl_azim_lut.</tt><tt class="descname">OCL_LUT_Integrator</tt><big>(</big><em>lut</em>, <em>image_size</em>, <em>devicetype='all'</em>, <em>platformid=None</em>, <em>deviceid=None</em>, <em>checksum=None</em>, <em>profile=False</em>, <em>empty=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_lut.OCL_LUT_Integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="attribute">
<dt id="pyFAI.ocl_azim_lut.OCL_LUT_Integrator.BLOCK_SIZE">
<tt class="descname">BLOCK_SIZE</tt><em class="property"> = 16</em><a class="headerlink" href="#pyFAI.ocl_azim_lut.OCL_LUT_Integrator.BLOCK_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim_lut.OCL_LUT_Integrator.__init__">
<tt class="descname">__init__</tt><big>(</big><em>lut</em>, <em>image_size</em>, <em>devicetype='all'</em>, <em>platformid=None</em>, <em>deviceid=None</em>, <em>checksum=None</em>, <em>profile=False</em>, <em>empty=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_lut.OCL_LUT_Integrator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lut</strong> &#8211; array of int32 - float32 with shape (nbins, lut_size) with indexes and coefficients</li>
<li><strong>image_size</strong> &#8211; Expected image size: image.shape.prod()</li>
<li><strong>devicetype</strong> &#8211; can be &#8220;cpu&#8221;,&#8221;gpu&#8221;,&#8221;acc&#8221; or &#8220;all&#8221;</li>
<li><strong>platformid</strong> (<em>int</em>) &#8211; number of the platform as given by clinfo</li>
<li><strong>deviceid</strong> (<em>int</em>) &#8211; number of the device as given by clinfo</li>
<li><strong>checksum</strong> &#8211; pre - calculated checksum to prevent re - calculating it :)</li>
<li><strong>profile</strong> &#8211; store profiling elements</li>
<li><strong>empty</strong> &#8211; value to be assigned to bins without contribution from any pixel</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim_lut.OCL_LUT_Integrator.integrate">
<tt class="descname">integrate</tt><big>(</big><em>data</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>solidAngle=None</em>, <em>polarization=None</em>, <em>dark_checksum=None</em>, <em>flat_checksum=None</em>, <em>solidAngle_checksum=None</em>, <em>polarization_checksum=None</em>, <em>preprocess_only=False</em>, <em>safe=True</em>, <em>normalization_factor=1.0</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_lut.OCL_LUT_Integrator.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Before performing azimuthal integration, the preprocessing is:</p>
<div class="math">
<p><img src="../_images/math/8ba6a38f3c030b35637cd9e0ff6339d754c6baee.png" alt="data = (data - dark) / (flat * solidAngle * polarization)"/></p>
</div><p>Integration is performed using the CSR representation of the look-up table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dark</strong> &#8211; array of same shape as data for pre-processing</li>
<li><strong>flat</strong> &#8211; array of same shape as data for pre-processing</li>
<li><strong>solidAngle</strong> &#8211; array of same shape as data for pre-processing</li>
<li><strong>polarization</strong> &#8211; array of same shape as data for pre-processing</li>
<li><strong>dark_checksum</strong> &#8211; CRC32 checksum of the given array</li>
<li><strong>flat_checksum</strong> &#8211; CRC32 checksum of the given array</li>
<li><strong>solidAngle_checksum</strong> &#8211; CRC32 checksum of the given array</li>
<li><strong>polarization_checksum</strong> &#8211; CRC32 checksum of the given array</li>
<li><strong>safe</strong> &#8211; if True (default) compares arrays on GPU according to their checksum, unless, use the buffer location is used</li>
<li><strong>normalization_factor</strong> &#8211; divide raw signal by this value</li>
<li><strong>preprocess_only</strong> &#8211; return the dark subtracted; flat field &amp; solidAngle &amp; polarization corrected image, else</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">averaged data, weighted histogram, unweighted histogram</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim_lut.OCL_LUT_Integrator.log_profile">
<tt class="descname">log_profile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_lut.OCL_LUT_Integrator.log_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>If we are in profiling mode, prints out all timing for every single OpenCL call</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.ocl_azim_csr">
<span id="ocl-azim-csr-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">ocl_azim_csr</span></tt> Module<a class="headerlink" href="#module-pyFAI.ocl_azim_csr" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.ocl_azim_csr.OCL_CSR_Integrator">
<em class="property">class </em><tt class="descclassname">pyFAI.ocl_azim_csr.</tt><tt class="descname">OCL_CSR_Integrator</tt><big>(</big><em>lut</em>, <em>image_size</em>, <em>devicetype='all'</em>, <em>block_size=32</em>, <em>platformid=None</em>, <em>deviceid=None</em>, <em>checksum=None</em>, <em>profile=False</em>, <em>empty=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_csr.OCL_CSR_Integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="pyFAI.ocl_azim_csr.OCL_CSR_Integrator.__init__">
<tt class="descname">__init__</tt><big>(</big><em>lut</em>, <em>image_size</em>, <em>devicetype='all'</em>, <em>block_size=32</em>, <em>platformid=None</em>, <em>deviceid=None</em>, <em>checksum=None</em>, <em>profile=False</em>, <em>empty=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_csr.OCL_CSR_Integrator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lut</strong> &#8211; 3-tuple of arrays
data: coefficient of the matrix in a 1D vector of float32 - size of nnz
indices: Column index position for the data (same size as data)
indptr: row pointer indicates the start of a given row. len nbin+1</li>
<li><strong>image_size</strong> &#8211; size of the image (for pre-processing)</li>
<li><strong>devicetype</strong> &#8211; can be &#8220;cpu&#8221;,&#8221;gpu&#8221;,&#8221;acc&#8221; or &#8220;all&#8221;</li>
<li><strong>block_size</strong> &#8211; the chosen size for WORKGROUP_SIZE</li>
<li><strong>platformid</strong> (<em>int</em>) &#8211; number of the platform as given by clinfo</li>
<li><strong>deviceid</strong> (<em>int</em>) &#8211; number of the device as given by clinfo</li>
<li><strong>checksum</strong> &#8211; pre - calculated checksum to prevent re - calculating it :)</li>
<li><strong>profile</strong> &#8211; store profiling elements</li>
<li><strong>empty</strong> &#8211; value to be assigned to bins without contribution from any pixel</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim_csr.OCL_CSR_Integrator.integrate">
<tt class="descname">integrate</tt><big>(</big><em>data</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>solidAngle=None</em>, <em>polarization=None</em>, <em>dark_checksum=None</em>, <em>flat_checksum=None</em>, <em>solidAngle_checksum=None</em>, <em>polarization_checksum=None</em>, <em>preprocess_only=False</em>, <em>safe=True</em>, <em>normalization_factor=1.0</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_csr.OCL_CSR_Integrator.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Before performing azimuthal integration, the preprocessing is:</p>
<div class="math">
<p><img src="../_images/math/8ba6a38f3c030b35637cd9e0ff6339d754c6baee.png" alt="data = (data - dark) / (flat * solidAngle * polarization)"/></p>
</div><p>Integration is performed using the CSR representation of the look-up table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dark</strong> &#8211; array of same shape as data for pre-processing</li>
<li><strong>flat</strong> &#8211; array of same shape as data for pre-processing</li>
<li><strong>solidAngle</strong> &#8211; array of same shape as data for pre-processing</li>
<li><strong>polarization</strong> &#8211; array of same shape as data for pre-processing</li>
<li><strong>dark_checksum</strong> &#8211; CRC32 checksum of the given array</li>
<li><strong>flat_checksum</strong> &#8211; CRC32 checksum of the given array</li>
<li><strong>solidAngle_checksum</strong> &#8211; CRC32 checksum of the given array</li>
<li><strong>polarization_checksum</strong> &#8211; CRC32 checksum of the given array</li>
<li><strong>safe</strong> &#8211; if True (default) compares arrays on GPU according to their checksum, unless, use the buffer location is used</li>
<li><strong>preprocess_only</strong> &#8211; return the dark subtracted; flat field &amp; solidAngle &amp; polarization corrected image, else</li>
<li><strong>normalization_factor</strong> &#8211; divide result by this value</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">averaged data, weighted histogram, unweighted histogram</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim_csr.OCL_CSR_Integrator.log_profile">
<tt class="descname">log_profile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_csr.OCL_CSR_Integrator.log_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>If we are in profiling mode, prints out all timing for every single OpenCL call</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.ocl_azim_csr_dis">
<span id="ocl-azim-csr-dis-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">ocl_azim_csr_dis</span></tt> Module<a class="headerlink" href="#module-pyFAI.ocl_azim_csr_dis" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.ocl_azim_csr_dis.OCL_CSR_Integrator">
<em class="property">class </em><tt class="descclassname">pyFAI.ocl_azim_csr_dis.</tt><tt class="descname">OCL_CSR_Integrator</tt><big>(</big><em>lut</em>, <em>image_size</em>, <em>devicetype='all'</em>, <em>block_size=32</em>, <em>platformid=None</em>, <em>deviceid=None</em>, <em>checksum=None</em>, <em>profile=False</em>, <em>empty=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_csr_dis.OCL_CSR_Integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="pyFAI.ocl_azim_csr_dis.OCL_CSR_Integrator.__init__">
<tt class="descname">__init__</tt><big>(</big><em>lut</em>, <em>image_size</em>, <em>devicetype='all'</em>, <em>block_size=32</em>, <em>platformid=None</em>, <em>deviceid=None</em>, <em>checksum=None</em>, <em>profile=False</em>, <em>empty=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_csr_dis.OCL_CSR_Integrator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lut</strong> &#8211; 3-tuple of arrays
data: coefficient of the matrix in a 1D vector of float32 - size of nnz
indices: Column index position for the data (same size as data)
indptr: row pointer indicates the start of a given row. len nbin+1</li>
<li><strong>image_size</strong> &#8211; </li>
<li><strong>devicetype</strong> &#8211; can be &#8220;cpu&#8221;,&#8221;gpu&#8221;,&#8221;acc&#8221; or &#8220;all&#8221;</li>
<li><strong>block_size</strong> &#8211; the chosen size for WORKGROUP_SIZE</li>
<li><strong>platformid</strong> (<em>int</em>) &#8211; number of the platform as given by clinfo</li>
<li><strong>deviceid</strong> (<em>int</em>) &#8211; number of the device as given by clinfo</li>
<li><strong>checksum</strong> &#8211; pre - calculated checksum to prevent re - calculating it :)</li>
<li><strong>profile</strong> &#8211; store profiling elements</li>
<li><strong>empty</strong> &#8211; value to be assigned to bins without contribution from any pixel</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim_csr_dis.OCL_CSR_Integrator.integrate">
<tt class="descname">integrate</tt><big>(</big><em>data</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>solidAngle=None</em>, <em>polarization=None</em>, <em>dark_checksum=None</em>, <em>flat_checksum=None</em>, <em>solidAngle_checksum=None</em>, <em>polarization_checksum=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_csr_dis.OCL_CSR_Integrator.integrate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim_csr_dis.OCL_CSR_Integrator.log_profile">
<tt class="descname">log_profile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_csr_dis.OCL_CSR_Integrator.log_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>If we are in profiling mode, prints out all timing for every
single OpenCL call</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.io">
<span id="io-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">io</span></tt> Module<a class="headerlink" href="#module-pyFAI.io" title="Permalink to this headline">¶</a></h1>
<p>Module for &#8220;high-performance&#8221; writing in either 1D with Ascii , 
or 2D with FabIO or even nD with n varying from  2 to 4 using HDF5</p>
<p>Stand-alone module which tries to offer interface to HDF5 via H5Py and
capabilities to write EDF or other formats using fabio.</p>
<p>Can be imported without h5py but then limited to fabio &amp; ascii formats.</p>
<p>TODO:</p>
<ul class="simple">
<li>Add monitor to HDF5</li>
</ul>
<dl class="class">
<dt id="pyFAI.io.AsciiWriter">
<em class="property">class </em><tt class="descclassname">pyFAI.io.</tt><tt class="descname">AsciiWriter</tt><big>(</big><em>filename=None</em>, <em>prefix='fai_'</em>, <em>extension='.dat'</em><big>)</big><a class="headerlink" href="#pyFAI.io.AsciiWriter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.io.Writer" title="pyFAI.io.Writer"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.io.Writer</span></tt></a></p>
<p>Ascii file writer (.xy or .dat)</p>
<dl class="method">
<dt id="pyFAI.io.AsciiWriter.__init__">
<tt class="descname">__init__</tt><big>(</big><em>filename=None</em>, <em>prefix='fai_'</em>, <em>extension='.dat'</em><big>)</big><a class="headerlink" href="#pyFAI.io.AsciiWriter.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.io.AsciiWriter.init">
<tt class="descname">init</tt><big>(</big><em>fai_cfg=None</em>, <em>lima_cfg=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.AsciiWriter.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the directory that will host the output file(s)</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.AsciiWriter.write">
<tt class="descname">write</tt><big>(</big><em>data</em>, <em>index=0</em><big>)</big><a class="headerlink" href="#pyFAI.io.AsciiWriter.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.io.DefaultAiWriter">
<em class="property">class </em><tt class="descclassname">pyFAI.io.</tt><tt class="descname">DefaultAiWriter</tt><big>(</big><em>filename</em>, <em>ai</em><big>)</big><a class="headerlink" href="#pyFAI.io.DefaultAiWriter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.io.Writer" title="pyFAI.io.Writer"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.io.Writer</span></tt></a></p>
<dl class="method">
<dt id="pyFAI.io.DefaultAiWriter.__init__">
<tt class="descname">__init__</tt><big>(</big><em>filename</em>, <em>ai</em><big>)</big><a class="headerlink" href="#pyFAI.io.DefaultAiWriter.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor of the historical writer of azimuthalIntegrator.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.DefaultAiWriter.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.io.DefaultAiWriter.close" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.io.DefaultAiWriter.flush">
<tt class="descname">flush</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.io.DefaultAiWriter.flush" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.io.DefaultAiWriter.make_headers">
<tt class="descname">make_headers</tt><big>(</big><em>hdr='#'</em>, <em>has_dark=False</em>, <em>has_flat=False</em>, <em>polarization_factor=None</em>, <em>normalization_factor=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.DefaultAiWriter.make_headers" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>hdr</strong> (<em>str</em>) &#8211; string used as comment in the header</li>
<li><strong>has_dark</strong> (<em>bool</em>) &#8211; save the darks filenames (default: no)</li>
<li><strong>has_flat</strong> (<em>bool</em>) &#8211; save the flat filenames (default: no)</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; the polarization factor</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the header</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">str</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.DefaultAiWriter.save1D">
<tt class="descname">save1D</tt><big>(</big><em>filename</em>, <em>dim1</em>, <em>I</em>, <em>error=None</em>, <em>dim1_unit='2th_deg'</em>, <em>has_dark=False</em>, <em>has_flat=False</em>, <em>polarization_factor=None</em>, <em>normalization_factor=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.DefaultAiWriter.save1D" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; the filename used to save the 1D integration</li>
<li><strong>dim1</strong> (<em>numpy.ndarray</em>) &#8211; the x coordinates of the integrated curve</li>
<li><strong>I</strong> (<em>numpy.mdarray</em>) &#8211; The integrated intensity</li>
<li><strong>error</strong> (<em>numpy.ndarray or None</em>) &#8211; the error bar for each intensity</li>
<li><strong>dim1_unit</strong> (<a class="reference internal" href="#pyFAI.units.Unit" title="pyFAI.units.Unit"><em>pyFAI.units.Unit</em></a>) &#8211; the unit of the dim1 array</li>
<li><strong>has_dark</strong> (<em>bool</em>) &#8211; save the darks filenames (default: no)</li>
<li><strong>has_flat</strong> (<em>bool</em>) &#8211; save the flat filenames (default: no)</li>
<li><strong>polarization_factor</strong> (<em>float, None</em>) &#8211; the polarization factor</li>
<li><strong>normalization_factor</strong> (<em>float, None</em>) &#8211; the monitor value</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This method save the result of a 1D integration.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.DefaultAiWriter.save2D">
<tt class="descname">save2D</tt><big>(</big><em>filename</em>, <em>I</em>, <em>dim1</em>, <em>dim2</em>, <em>error=None</em>, <em>dim1_unit='2th_deg'</em>, <em>has_dark=False</em>, <em>has_flat=False</em>, <em>polarization_factor=None</em>, <em>normalization_factor=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.DefaultAiWriter.save2D" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; the filename used to save the 2D histogram</li>
<li><strong>dim1</strong> (<em>numpy.ndarray</em>) &#8211; the 1st coordinates of the histogram</li>
<li><strong>dim1</strong> &#8211; the 2nd coordinates of the histogram</li>
<li><strong>I</strong> (<em>numpy.mdarray</em>) &#8211; The integrated intensity</li>
<li><strong>error</strong> (<em>numpy.ndarray or None</em>) &#8211; the error bar for each intensity</li>
<li><strong>dim1_unit</strong> (<a class="reference internal" href="#pyFAI.units.Unit" title="pyFAI.units.Unit"><em>pyFAI.units.Unit</em></a>) &#8211; the unit of the dim1 array</li>
<li><strong>has_dark</strong> (<em>bool</em>) &#8211; save the darks filenames (default: no)</li>
<li><strong>has_flat</strong> (<em>bool</em>) &#8211; save the flat filenames (default: no)</li>
<li><strong>polarization_factor</strong> (<em>float, None</em>) &#8211; the polarization factor</li>
<li><strong>normalization_factor</strong> (<em>float, None</em>) &#8211; the monitor value</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This method save the result of a 2D integration.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.DefaultAiWriter.set_filename">
<tt class="descname">set_filename</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.io.DefaultAiWriter.set_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the filename while will be used</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.DefaultAiWriter.write">
<tt class="descname">write</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyFAI.io.DefaultAiWriter.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimalistic method to limit the overhead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> &#8211; array with intensities or tuple (2th,I) or (I,2th,chi)        :type data: Integrate1dResult, Integrate2dResult</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.io.FabioWriter">
<em class="property">class </em><tt class="descclassname">pyFAI.io.</tt><tt class="descname">FabioWriter</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.FabioWriter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.io.Writer" title="pyFAI.io.Writer"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.io.Writer</span></tt></a></p>
<p>Image file writer based on FabIO</p>
<p>TODO !!!</p>
<dl class="method">
<dt id="pyFAI.io.FabioWriter.__init__">
<tt class="descname">__init__</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.FabioWriter.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.io.FabioWriter.init">
<tt class="descname">init</tt><big>(</big><em>fai_cfg=None</em>, <em>lima_cfg=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.FabioWriter.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the directory that will host the output file(s)</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.FabioWriter.write">
<tt class="descname">write</tt><big>(</big><em>data</em>, <em>index=0</em><big>)</big><a class="headerlink" href="#pyFAI.io.FabioWriter.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.io.HDF5Writer">
<em class="property">class </em><tt class="descclassname">pyFAI.io.</tt><tt class="descname">HDF5Writer</tt><big>(</big><em>filename</em>, <em>hpath='data'</em>, <em>fast_scan_width=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.HDF5Writer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.io.Writer" title="pyFAI.io.Writer"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.io.Writer</span></tt></a></p>
<p>Class allowing to write HDF5 Files.</p>
<dl class="attribute">
<dt id="pyFAI.io.HDF5Writer.CONFIG">
<tt class="descname">CONFIG</tt><em class="property"> = 'pyFAI'</em><a class="headerlink" href="#pyFAI.io.HDF5Writer.CONFIG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.io.HDF5Writer.DATASET_NAME">
<tt class="descname">DATASET_NAME</tt><em class="property"> = 'data'</em><a class="headerlink" href="#pyFAI.io.HDF5Writer.DATASET_NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.io.HDF5Writer.__init__">
<tt class="descname">__init__</tt><big>(</big><em>filename</em>, <em>hpath='data'</em>, <em>fast_scan_width=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.HDF5Writer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor of an HDF5 writer:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> &#8211; name of the file</li>
<li><strong>hpath</strong> &#8211; name of the group: it will contain data (2-4D dataset), [tth|q|r] and pyFAI, group containing the configuration</li>
<li><strong>fast_scan_width</strong> &#8211; set it to define the width of</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.HDF5Writer.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.io.HDF5Writer.close" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.io.HDF5Writer.flush">
<tt class="descname">flush</tt><big>(</big><em>radial=None</em>, <em>azimuthal=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.HDF5Writer.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Update some data like axis units and so on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>radial</strong> &#8211; position in radial direction</li>
<li><strong>azimuthal</strong> &#8211; position in azimuthal direction</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.HDF5Writer.init">
<tt class="descname">init</tt><big>(</big><em>fai_cfg=None</em>, <em>lima_cfg=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.HDF5Writer.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the HDF5 file for writing
:param fai_cfg: the configuration of the worker as a dictionary</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.HDF5Writer.write">
<tt class="descname">write</tt><big>(</big><em>data</em>, <em>index=0</em><big>)</big><a class="headerlink" href="#pyFAI.io.HDF5Writer.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimalistic method to limit the overhead.
:param data: array with intensities or tuple (2th,I) or (I,2th,chi)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.io.Nexus">
<em class="property">class </em><tt class="descclassname">pyFAI.io.</tt><tt class="descname">Nexus</tt><big>(</big><em>filename</em>, <em>mode='r'</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Writer class to handle Nexus/HDF5 data</p>
<p>Manages:</p>
<ul>
<li><p class="first">entry</p>
<blockquote>
<div><ul>
<li><p class="first">pyFAI-subentry</p>
<blockquote>
<div><ul class="simple">
<li>detector</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
<p>TODO: make it thread-safe !!!</p>
<dl class="method">
<dt id="pyFAI.io.Nexus.__init__">
<tt class="descname">__init__</tt><big>(</big><em>filename</em>, <em>mode='r'</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> &#8211; name of the hdf5 file containing the nexus</li>
<li><strong>mode</strong> &#8211; can be r or a</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.close" title="Permalink to this definition">¶</a></dt>
<dd><p>close the filename and update all entries</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.deep_copy">
<tt class="descname">deep_copy</tt><big>(</big><em>name</em>, <em>obj</em>, <em>where='/'</em>, <em>toplevel=None</em>, <em>excluded=None</em>, <em>overwrite=False</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.deep_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>perform a deep copy:
create a &#8220;name&#8221; entry in self containing a copy of the object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>where</strong> &#8211; path to the toplevel object (i.e. root)</li>
<li><strong>toplevel</strong> &#8211; firectly the top level Group</li>
<li><strong>excluded</strong> &#8211; list of keys to be excluded</li>
<li><strong>overwrite</strong> &#8211; replace content if already existing</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.find_detector">
<tt class="descname">find_detector</tt><big>(</big><em>all=False</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.find_detector" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to find a detector within a NeXus file, takes the first compatible detector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>all</strong> &#8211; return all detectors found as a list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pyFAI.io.Nexus.get_attr">
<em class="property">classmethod </em><tt class="descname">get_attr</tt><big>(</big><em>dset</em>, <em>name</em>, <em>default=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.get_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the attribute of the dataset</p>
<p>Handles the ascii -&gt; unicode issue in python3 #275</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dset</strong> &#8211; a HDF5 dataset (or a group)</li>
<li><strong>name</strong> &#8211; name of the attribute</li>
<li><strong>default</strong> &#8211; default value to be returned</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">attribute value decoded in python3 or default</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.get_class">
<tt class="descname">get_class</tt><big>(</big><em>grp</em>, <em>class_type='NXcollection'</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.get_class" title="Permalink to this definition">¶</a></dt>
<dd><p>return all sub-groups of the given type within a group</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>grp</strong> &#8211; HDF5 group</li>
<li><strong>class_type</strong> &#8211; name of the NeXus class</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.get_data">
<tt class="descname">get_data</tt><big>(</big><em>grp</em>, <em>class_type='NXdata'</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>return all dataset of the the NeXus class NXdata</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>grp</strong> &#8211; HDF5 group</li>
<li><strong>class_type</strong> &#8211; name of the NeXus class</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.get_entries">
<tt class="descname">get_entries</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.get_entries" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieves all entry sorted the latest first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of HDF5 groups</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.get_entry">
<tt class="descname">get_entry</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.get_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves an entry from its name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> &#8211; name of the entry to retrieve</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">HDF5 group of NXclass == NXentry</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.new_class">
<tt class="descname">new_class</tt><big>(</big><em>grp</em>, <em>name</em>, <em>class_type='NXcollection'</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.new_class" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new sub-group with  type class_type
:param grp: parent group
:param name: name of the sub-group
:param class_type: NeXus class name
:return: subgroup created</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.new_detector">
<tt class="descname">new_detector</tt><big>(</big><em>name='detector'</em>, <em>entry='entry'</em>, <em>subentry='pyFAI'</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.new_detector" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new entry/pyFAI/Detector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>detector</strong> &#8211; name of the detector</li>
<li><strong>entry</strong> &#8211; name of the entry</li>
<li><strong>subentry</strong> &#8211; all pyFAI description of detectors should be in a pyFAI sub-entry</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.new_entry">
<tt class="descname">new_entry</tt><big>(</big><em>entry='entry'</em>, <em>program_name='pyFAI'</em>, <em>title='description of experiment'</em>, <em>force_time=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.new_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new entry</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>entry</strong> &#8211; name of the entry</li>
<li><strong>program_name</strong> &#8211; value of the field as string</li>
<li><strong>title</strong> &#8211; value of the field as string</li>
<li><strong>force_time</strong> &#8211; enforce the start_time (as string!)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the corresponding HDF5 group</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.new_instrument">
<tt class="descname">new_instrument</tt><big>(</big><em>entry='entry'</em>, <em>instrument_name='id00'</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.new_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an instrument in an entry or create both the entry and the instrument if</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.io.Writer">
<em class="property">class </em><tt class="descclassname">pyFAI.io.</tt><tt class="descname">Writer</tt><big>(</big><em>filename=None</em>, <em>extension=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.Writer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Abstract class for writers.</p>
<dl class="attribute">
<dt id="pyFAI.io.Writer.CONFIG_ITEMS">
<tt class="descname">CONFIG_ITEMS</tt><em class="property"> = ['filename', 'dirname', 'extension', 'subdir', 'hpath']</em><a class="headerlink" href="#pyFAI.io.Writer.CONFIG_ITEMS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.io.Writer.__init__">
<tt class="descname">__init__</tt><big>(</big><em>filename=None</em>, <em>extension=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.Writer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor of the class</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Writer.flush">
<tt class="descname">flush</tt><big>(</big><em>*arg</em>, <em>**kwarg</em><big>)</big><a class="headerlink" href="#pyFAI.io.Writer.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>To be implemented</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Writer.init">
<tt class="descname">init</tt><big>(</big><em>fai_cfg=None</em>, <em>lima_cfg=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.Writer.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the directory that will host the output file(s)
:param fai_cfg: configuration for worker
:param lima_cfg: configuration for acquisition</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Writer.setJsonConfig">
<tt class="descname">setJsonConfig</tt><big>(</big><em>json_config=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.Writer.setJsonConfig" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the JSON configuration</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Writer.write">
<tt class="descname">write</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyFAI.io.Writer.write" title="Permalink to this definition">¶</a></dt>
<dd><p>To be implemented</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.io.from_isotime">
<tt class="descclassname">pyFAI.io.</tt><tt class="descname">from_isotime</tt><big>(</big><em>text</em>, <em>use_tz=False</em><big>)</big><a class="headerlink" href="#pyFAI.io.from_isotime" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>text</strong> &#8211; string representing the time is iso format</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.io.get_isotime">
<tt class="descclassname">pyFAI.io.</tt><tt class="descname">get_isotime</tt><big>(</big><em>forceTime=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.get_isotime" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>forceTime</strong> (<em>float</em>) &#8211; enforce a given time (current by default)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the current time as an ISO8601 string</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">string</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.io.is_hdf5">
<tt class="descclassname">pyFAI.io.</tt><tt class="descname">is_hdf5</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.io.is_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a file is actually a HDF5 file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; this file has better to exist</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pyFAI.calibration">
<span id="calibration-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">calibration</span></tt> Module<a class="headerlink" href="#module-pyFAI.calibration" title="Permalink to this headline">¶</a></h1>
<p>pyFAI-calib</p>
<p>A tool for determining the geometry of a detector using a reference sample.</p>
<dl class="class">
<dt id="pyFAI.calibration.AbstractCalibration">
<em class="property">class </em><tt class="descclassname">pyFAI.calibration.</tt><tt class="descname">AbstractCalibration</tt><big>(</big><em>dataFiles=None</em>, <em>darkFiles=None</em>, <em>flatFiles=None</em>, <em>pixelSize=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>wavelength=None</em>, <em>calibrant=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Everything that is common to Calibration and Recalibration</p>
<dl class="attribute">
<dt id="pyFAI.calibration.AbstractCalibration.HELP">
<tt class="descname">HELP</tt><em class="property"> = {'reset': 'Reset the geometry to the initial guess (rotation to zero, distance to 0.1m, poni at the center of the image)', 'delete': 'delete a group of points, provide the letter.', 'set': &quot;set the value of a parameter to the given value, i.e 'set wavelength 0.1 nm', units are optional&quot;, 'chiplot': 'plot control point radial error as function of azimuthal angle, optional parameters: the rings for which this need to be plotted', 'help': &quot;Try to get the help of a given action, like 'refine?'. Use done when finished. Most command are composed of 'action parameter value' like 'set wavelength 1 A'.&quot;, 'weight': 'toggle from weighted to unweighted mode...', 'get': 'print he value of a parameter', 'fix': &quot;fixes the value of a parameter so that its value will not be optimized, i.e. 'fix wavelength'&quot;, 'validate2': 'measures the offset of the center as function of azimuthal angle by cross-correlation of 2 plots, 180 deg appart. Option: number of azimuthal sliced, default: 36', 'show': &quot;Just print out the current parameter set. Optional parameters are units for length, rotation and wavelength, i.e. 'show mm deg A'&quot;, 'bound': &quot;sets the upper and lower bound of a parameter: 'bound dist 0.1 0.2'&quot;, 'free': &quot;frees the parameter so that the value can be optimized, i.e. 'free wavelength'&quot;, 'bounds': 'sets the upper and lower bound of all parameters', 'abort': 'quit immediately, discarding any unsaved changes', 'done': 'finishes the processing, performs an integration and quits', 'refine': 'performs a new cycle of refinement', 'integrate': 'perform the azimuthal integration and display results', 'validate': 'plot the offset between the calibrated image and the back-projected image', 'recalib': 'extract a new set of rings and re-perform the calibration. One can specify how many rings to extract and the algorithm to use (blob, massif, watershed) and the nb_pts_per_deg in azimuth', 'assign': 'Change the assignment of a group of points to a rings', 'define': 'Re-define the value for a constant internal parameter of the program like max_iter, nPt_1D, nPt_2D_azim, nPt_2D_rad, integrator_method, error_model. Warning: attribute change may be harmful !'}</em><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.HELP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibration.AbstractCalibration.PARAMETERS">
<tt class="descname">PARAMETERS</tt><em class="property"> = ['dist', 'poni1', 'poni2', 'rot1', 'rot2', 'rot3', 'wavelength']</em><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.PARAMETERS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibration.AbstractCalibration.PTS_PER_DEG">
<tt class="descname">PTS_PER_DEG</tt><em class="property"> = 0.3</em><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.PTS_PER_DEG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibration.AbstractCalibration.UNITS">
<tt class="descname">UNITS</tt><em class="property"> = {'poni1': 'meter', 'poni2': 'meter', 'rot1': 'radian', 'rot3': 'radian', 'rot2': 'radian', 'wavelength': 'meter', 'dist': 'meter'}</em><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.UNITS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibration.AbstractCalibration.VALID_URL">
<tt class="descname">VALID_URL</tt><em class="property"> = ['', 'file', 'hdf5', 'nxs', 'h5']</em><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.VALID_URL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.__init__">
<tt class="descname">__init__</tt><big>(</big><em>dataFiles=None</em>, <em>darkFiles=None</em>, <em>flatFiles=None</em>, <em>pixelSize=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>wavelength=None</em>, <em>calibrant=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor of AbstractCalibration</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dataFiles</strong> &#8211; list of filenames containing data images</li>
<li><strong>darkFiles</strong> &#8211; list of filenames containing dark current images</li>
<li><strong>flatFiles</strong> &#8211; list of filenames containing flat images</li>
<li><strong>pixelSize</strong> &#8211; size of the pixel in meter as 2 tuple</li>
<li><strong>splineFile</strong> &#8211; file containing the distortion of the taper</li>
<li><strong>detector</strong> &#8211; Detector name or instance</li>
<li><strong>wavelength</strong> &#8211; radiation wavelength in meter</li>
<li><strong>calibrant</strong> &#8211; pyFAI.calibrant.Calibrant instance</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.analyse_options">
<tt class="descname">analyse_options</tt><big>(</big><em>options=None</em>, <em>args=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.analyse_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyzes options and arguments</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">option,arguments</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.chiplot">
<tt class="descname">chiplot</tt><big>(</big><em>rings=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.chiplot" title="Permalink to this definition">¶</a></dt>
<dd><p>plot delta_2theta/2theta = f(chi) and fit the curve.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rings</strong> &#8211; list of rings to consider</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.configure_parser">
<tt class="descname">configure_parser</tt><big>(</big><em>version='calibration from pyFAI  version 0.13.0: 02/12/2016'</em>, <em>usage='pyFAI-calib [options] input_image.edf'</em>, <em>description=None</em>, <em>epilog=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.configure_parser" title="Permalink to this definition">¶</a></dt>
<dd><p>Common configuration for parsers</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.extract_cpt">
<tt class="descname">extract_cpt</tt><big>(</big><em>method='massif'</em>, <em>pts_per_deg=1.0</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.extract_cpt" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs an automatic keypoint extraction:
Can be used in recalib or in calib after a first calibration has been performed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>method</strong> &#8211; method for keypoint extraction</li>
<li><strong>pts_per_deg</strong> &#8211; number of control points per azimuthal degree (increase for better precision)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.get_pixelSize">
<tt class="descname">get_pixelSize</tt><big>(</big><em>ans</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.get_pixelSize" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a comma separated sting into pixel size</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.postProcess">
<tt class="descname">postProcess</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.postProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Common part: shows the result of the azimuthal integration in 1D and 2D</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.preprocess">
<tt class="descname">preprocess</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>Common part:
do dark, flat correction thresholding, ...
and read missing data from keyboard if needed</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.prompt">
<tt class="descname">prompt</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.prompt" title="Permalink to this definition">¶</a></dt>
<dd><p>prompt for commands to guide the calibration process</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True when the user is happy with what he has, False to request another refinement</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.read_dSpacingFile">
<tt class="descname">read_dSpacingFile</tt><big>(</big><em>verbose=True</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.read_dSpacingFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the name of the calibrant / file with d-spacing</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.read_pixelsSize">
<tt class="descname">read_pixelsSize</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.read_pixelsSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the pixel size from prompt if not available</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.read_wavelength">
<tt class="descname">read_wavelength</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.read_wavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the wavelength</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.refine">
<tt class="descname">refine</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the common geometry refinement part</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.reset_geometry">
<tt class="descname">reset_geometry</tt><big>(</big><em>how='center'</em>, <em>refine=False</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.reset_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the geometry: no tilt in all cases</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>how</strong> &#8211; multiple options
* center: set the PONI at the center of the detector
* ring: center the poni at the middle of the inner-most ring
* best: try both option and keeps the best (this option is not available)</li>
<li><strong>refine</strong> &#8211; launch the refinement (argument not used)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.set_data">
<tt class="descname">set_data</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>call-back function for the peak-picker</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.validate_calibration">
<tt class="descname">validate_calibration</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.validate_calibration" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the calibration and calculate the offset in the diffraction image</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.validate_center">
<tt class="descname">validate_center</tt><big>(</big><em>slices=36</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.validate_center" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the position of the center by cross-correlating two spectra 180 deg appart.
Output values are in micron.</p>
<p>Designed for orthogonal setup with centered beam...</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>slices</strong> &#8211; number of slices on which perform</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibration.AbstractCalibration.win_error">
<tt class="descname">win_error</tt><em class="property"> = 'We are under windows with a 32 bit version of python, matplotlib is not able to display too many images without crashing, this is why the window showing the diffraction image is closed'</em><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.win_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.calibration.Calibration">
<em class="property">class </em><tt class="descclassname">pyFAI.calibration.</tt><tt class="descname">Calibration</tt><big>(</big><em>dataFiles=None</em>, <em>darkFiles=None</em>, <em>flatFiles=None</em>, <em>pixelSize=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>gaussianWidth=None</em>, <em>wavelength=None</em>, <em>calibrant=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.Calibration" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.calibration.AbstractCalibration" title="pyFAI.calibration.AbstractCalibration"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.calibration.AbstractCalibration</span></tt></a></p>
<p>class doing the calibration of frames</p>
<dl class="method">
<dt id="pyFAI.calibration.Calibration.__init__">
<tt class="descname">__init__</tt><big>(</big><em>dataFiles=None</em>, <em>darkFiles=None</em>, <em>flatFiles=None</em>, <em>pixelSize=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>gaussianWidth=None</em>, <em>wavelength=None</em>, <em>calibrant=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.Calibration.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for calibration:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dataFiles</strong> &#8211; list of filenames containing data images</li>
<li><strong>darkFiles</strong> &#8211; list of filenames containing dark current images</li>
<li><strong>flatFiles</strong> &#8211; list of filenames containing flat images</li>
<li><strong>pixelSize</strong> &#8211; size of the pixel in meter as 2 tuple</li>
<li><strong>splineFile</strong> &#8211; file containing the distortion of the taper</li>
<li><strong>detector</strong> &#8211; Detector name or instance</li>
<li><strong>wavelength</strong> &#8211; radiation wavelength in meter</li>
<li><strong>calibrant</strong> &#8211; pyFAI.calibrant.Calibrant instance</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.Calibration.gui_peakPicker">
<tt class="descname">gui_peakPicker</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.Calibration.gui_peakPicker" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.Calibration.initgeoRef">
<tt class="descname">initgeoRef</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.Calibration.initgeoRef" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to initialise the GeometryRefinement (dist, poni, rot)
Returns a dictionary of key value pairs</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.Calibration.parse">
<tt class="descname">parse</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.Calibration.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>parse options from command line</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.Calibration.preprocess">
<tt class="descname">preprocess</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.Calibration.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>do dark, flat correction thresholding, ...</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.Calibration.refine">
<tt class="descname">refine</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.Calibration.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the geometry refinement part specific to Calibration
Sets up the initial guess when starting pyFAI-calib</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.calibration.CheckCalib">
<em class="property">class </em><tt class="descclassname">pyFAI.calibration.</tt><tt class="descname">CheckCalib</tt><big>(</big><em>poni=None</em>, <em>img=None</em>, <em>unit='2th_deg'</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.CheckCalib" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="pyFAI.calibration.CheckCalib.__init__">
<tt class="descname">__init__</tt><big>(</big><em>poni=None</em>, <em>img=None</em>, <em>unit='2th_deg'</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.CheckCalib.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.CheckCalib.get_1dsize">
<tt class="descname">get_1dsize</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.CheckCalib.get_1dsize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.CheckCalib.integrate">
<tt class="descname">integrate</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.CheckCalib.integrate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.CheckCalib.parse">
<tt class="descname">parse</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.CheckCalib.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.CheckCalib.rebuild">
<tt class="descname">rebuild</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.CheckCalib.rebuild" title="Permalink to this definition">¶</a></dt>
<dd><p>Rebuild the diffraction image and measures the offset with the reference
:return: offset</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.CheckCalib.show">
<tt class="descname">show</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.CheckCalib.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the image with the the errors</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibration.CheckCalib.size1d">
<tt class="descname">size1d</tt><a class="headerlink" href="#pyFAI.calibration.CheckCalib.size1d" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.CheckCalib.smooth_mask">
<tt class="descname">smooth_mask</tt><big>(</big><em>hwhm=5</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.CheckCalib.smooth_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>smooth out around the mask to avoid aligning on the mask</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.calibration.MultiCalib">
<em class="property">class </em><tt class="descclassname">pyFAI.calibration.</tt><tt class="descname">MultiCalib</tt><big>(</big><em>dataFiles=None</em>, <em>darkFiles=None</em>, <em>flatFiles=None</em>, <em>pixelSize=None</em>, <em>splineFile=None</em>, <em>detector=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.MultiCalib" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="pyFAI.calibration.MultiCalib.__init__">
<tt class="descname">__init__</tt><big>(</big><em>dataFiles=None</em>, <em>darkFiles=None</em>, <em>flatFiles=None</em>, <em>pixelSize=None</em>, <em>splineFile=None</em>, <em>detector=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.MultiCalib.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.MultiCalib.get_pixelSize">
<tt class="descname">get_pixelSize</tt><big>(</big><em>ans</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.MultiCalib.get_pixelSize" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a comma separated sting into pixel size</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.MultiCalib.parse">
<tt class="descname">parse</tt><big>(</big><em>exe=None</em>, <em>description=None</em>, <em>epilog=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.MultiCalib.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>parse options from command line
:param exe: name of the program (MX-calibrate)
:param description: Description of the program</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.MultiCalib.process">
<tt class="descname">process</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.MultiCalib.process" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.MultiCalib.read_dSpacingFile">
<tt class="descname">read_dSpacingFile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.MultiCalib.read_dSpacingFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the name of the calibrant or the file with d-spacing</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.MultiCalib.read_pixelsSize">
<tt class="descname">read_pixelsSize</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.MultiCalib.read_pixelsSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the pixel size from prompt if not available</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.MultiCalib.read_wavelength">
<tt class="descname">read_wavelength</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.MultiCalib.read_wavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the wavelength</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.MultiCalib.regression">
<tt class="descname">regression</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.MultiCalib.regression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.calibration.Recalibration">
<em class="property">class </em><tt class="descclassname">pyFAI.calibration.</tt><tt class="descname">Recalibration</tt><big>(</big><em>dataFiles=None</em>, <em>darkFiles=None</em>, <em>flatFiles=None</em>, <em>pixelSize=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>wavelength=None</em>, <em>calibrant=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.Recalibration" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.calibration.AbstractCalibration" title="pyFAI.calibration.AbstractCalibration"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.calibration.AbstractCalibration</span></tt></a></p>
<p>class doing the re-calibration of frames</p>
<dl class="method">
<dt id="pyFAI.calibration.Recalibration.__init__">
<tt class="descname">__init__</tt><big>(</big><em>dataFiles=None</em>, <em>darkFiles=None</em>, <em>flatFiles=None</em>, <em>pixelSize=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>wavelength=None</em>, <em>calibrant=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.Recalibration.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for Recalibration:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dataFiles</strong> &#8211; list of filenames containing data images</li>
<li><strong>darkFiles</strong> &#8211; list of filenames containing dark current images</li>
<li><strong>flatFiles</strong> &#8211; list of filenames containing flat images</li>
<li><strong>pixelSize</strong> &#8211; size of the pixel in meter as 2 tuple</li>
<li><strong>splineFile</strong> &#8211; file containing the distortion of the taper</li>
<li><strong>detector</strong> &#8211; Detector name or instance</li>
<li><strong>wavelength</strong> &#8211; radiation wavelength in meter</li>
<li><strong>calibrant</strong> &#8211; pyFAI.calibrant.Calibrant instance</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.Recalibration.parse">
<tt class="descname">parse</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.Recalibration.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>parse options from command line</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.Recalibration.preprocess">
<tt class="descname">preprocess</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.Recalibration.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>do dark, flat correction thresholding, ...</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.Recalibration.read_dSpacingFile">
<tt class="descname">read_dSpacingFile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.Recalibration.read_dSpacingFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the name of the file with d-spacing</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.Recalibration.refine">
<tt class="descname">refine</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.Recalibration.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the geometry refinement part specific to Recalibration</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.calibration.calib">
<tt class="descclassname">pyFAI.calibration.</tt><tt class="descname">calib</tt><big>(</big><em>img</em>, <em>calibrant</em>, <em>detector</em>, <em>basename='from_ipython'</em>, <em>reconstruct=False</em>, <em>dist=0.1</em>, <em>gaussian=None</em>, <em>interactive=True</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.calib" title="Permalink to this definition">¶</a></dt>
<dd><p>Procedural interfact for calibration</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>img</strong> &#8211; 2d array representing the calibration image</li>
<li><strong>calibrant</strong> &#8211; Instance of Calibrant, set-up with wavelength</li>
<li><strong>detector</strong> &#8211; Detector instance containing the mask</li>
<li><strong>basename</strong> &#8211; output file base</li>
<li><strong>recontruct</strong> &#8211; perform image reconstruction of masked pixel ?</li>
<li><strong>dist</strong> &#8211; initial distance</li>
<li><strong>gaussian</strong> &#8211; width of the gaussian used for difference of gaussian in the &#8220;massif&#8221; peak-picking algorithm</li>
<li><strong>interactive</strong> &#8211; set to False for testing</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">AzimuthalIntegrator instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.calibration.get_detector">
<tt class="descclassname">pyFAI.calibration.</tt><tt class="descname">get_detector</tt><big>(</big><em>detector</em>, <em>datafiles=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.get_detector" title="Permalink to this definition">¶</a></dt>
<dd><p>Detector factory taking into account the binning knowing the datafiles</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>detector</strong> &#8211; string or detector or other junk</li>
<li><strong>datafiles</strong> &#8211; can be a list of images to be opened and their shape used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return pyFAI.detector.Detector instance
:raise RuntimeError: If no detector found</p>
</dd></dl>

</div>
<div class="section" id="module-pyFAI.peak_picker">
<span id="peak-picker-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">peak_picker</span></tt> Module<a class="headerlink" href="#module-pyFAI.peak_picker" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.peak_picker.ControlPoints">
<em class="property">class </em><tt class="descclassname">pyFAI.peak_picker.</tt><tt class="descname">ControlPoints</tt><big>(</big><em>filename=None</em>, <em>calibrant=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class contains a set of control points with (optionally) their ring number hence d-spacing and diffraction  2Theta angle ...</p>
<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.__init__">
<tt class="descname">__init__</tt><big>(</big><em>filename=None</em>, <em>calibrant=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.append">
<tt class="descname">append</tt><big>(</big><em>points</em>, <em>ring=None</em>, <em>annotate=None</em>, <em>plot=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.append" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>point</strong> &#8211; list of points</li>
<li><strong>ring</strong> &#8211; ring number</li>
<li><strong>annotate</strong> &#8211; matplotlib.annotate reference</li>
<li><strong>plot</strong> &#8211; matplotlib.plot reference</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">PointGroup instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.append_2theta_deg">
<tt class="descname">append_2theta_deg</tt><big>(</big><em>points</em>, <em>angle=None</em>, <em>ring=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.append_2theta_deg" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>point</strong> &#8211; list of points</li>
<li><strong>angle</strong> &#8211; 2-theta angle in degrees</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.check">
<tt class="descname">check</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.check" title="Permalink to this definition">¶</a></dt>
<dd><p>check internal consistency of the class</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.peak_picker.ControlPoints.dSpacing">
<tt class="descname">dSpacing</tt><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.dSpacing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.get">
<tt class="descname">get</tt><big>(</big><em>ring=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.get" title="Permalink to this definition">¶</a></dt>
<dd><p>retireves the last set of points for a given ring (by default the last)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ring</strong> &#8211; index of ring to search for</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.getList">
<tt class="descname">getList</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.getList" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the list of control points suitable for geometry refinement with ring number</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.getList2theta">
<tt class="descname">getList2theta</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.getList2theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the list of control points suitable for geometry refinement</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.getListRing">
<tt class="descname">getListRing</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.getListRing" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the list of control points suitable for geometry refinement with ring number</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.getWeightedList">
<tt class="descname">getWeightedList</tt><big>(</big><em>image</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.getWeightedList" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the list of control points suitable for geometry refinement with ring number and intensities
:param image:
:return: a (x,4) array with pos0, pos1, ring nr and intensity</p>
<p>#TODO: refine the value of the intensity using 2nd order polynomia</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.get_dSpacing">
<tt class="descname">get_dSpacing</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.get_dSpacing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.get_wavelength">
<tt class="descname">get_wavelength</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.get_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.load">
<tt class="descname">load</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.load" title="Permalink to this definition">¶</a></dt>
<dd><p>load all control points from a file</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.pop">
<tt class="descname">pop</tt><big>(</big><em>ring=None</em>, <em>lbl=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the set of points, either from its code or from a given ring (by default the last)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ring</strong> &#8211; index of ring of which remove the last group</li>
<li><strong>lbl</strong> &#8211; code of the ring to remove</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.readRingNrFromKeyboard">
<tt class="descname">readRingNrFromKeyboard</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.readRingNrFromKeyboard" title="Permalink to this definition">¶</a></dt>
<dd><p>Ask the ring number values for the given points</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all stored values and resets them to default</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.save">
<tt class="descname">save</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a set of control points to a file
:param filename: name of the file
:return: None</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.setWavelength_change2th">
<tt class="descname">setWavelength_change2th</tt><big>(</big><em>value=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.setWavelength_change2th" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.setWavelength_changeDs">
<tt class="descname">setWavelength_changeDs</tt><big>(</big><em>value=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.setWavelength_changeDs" title="Permalink to this definition">¶</a></dt>
<dd><p>This is probably not a good idea, but who knows !</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.set_dSpacing">
<tt class="descname">set_dSpacing</tt><big>(</big><em>lst</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.set_dSpacing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.set_wavelength">
<tt class="descname">set_wavelength</tt><big>(</big><em>value=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.set_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.peak_picker.ControlPoints.wavelength">
<tt class="descname">wavelength</tt><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.peak_picker.PeakPicker">
<em class="property">class </em><tt class="descclassname">pyFAI.peak_picker.</tt><tt class="descname">PeakPicker</tt><big>(</big><em>data</em>, <em>reconst=False</em>, <em>mask=None</em>, <em>pointfile=None</em>, <em>calibrant=None</em>, <em>wavelength=None</em>, <em>detector=None</em>, <em>method='massif'</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class is in charge of peak picking, i.e. find bragg spots in the image
Two methods can be used : massif or blob</p>
<dl class="attribute">
<dt id="pyFAI.peak_picker.PeakPicker.VALID_METHODS">
<tt class="descname">VALID_METHODS</tt><em class="property"> = ['massif', 'blob', 'watershed']</em><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.VALID_METHODS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.__init__">
<tt class="descname">__init__</tt><big>(</big><em>data</em>, <em>reconst=False</em>, <em>mask=None</em>, <em>pointfile=None</em>, <em>calibrant=None</em>, <em>wavelength=None</em>, <em>detector=None</em>, <em>method='massif'</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; input image as numpy array</li>
<li><strong>reconst</strong> &#8211; shall masked part or negative values be reconstructed (wipe out problems with pilatus gaps)</li>
<li><strong>mask</strong> &#8211; area in which keypoints will not be considered as valid</li>
<li><strong>pointfile</strong> &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.closeGUI">
<tt class="descname">closeGUI</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.closeGUI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.contour">
<tt class="descname">contour</tt><big>(</big><em>data</em>, <em>cmap='autumn'</em>, <em>linewidths=2</em>, <em>linestyles='dashed'</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Overlay a contour-plot</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> &#8211; 2darray with the 2theta values in radians...</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.display_points">
<tt class="descname">display_points</tt><big>(</big><em>minIndex=0</em>, <em>reset=False</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.display_points" title="Permalink to this definition">¶</a></dt>
<dd><p>display all points and their ring annotations
:param minIndex: ring index to start with
:param reset: remove all point before re-displaying them</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.finish">
<tt class="descname">finish</tt><big>(</big><em>filename=None</em>, <em>callback=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.finish" title="Permalink to this definition">¶</a></dt>
<dd><p>Ask the ring number for the given points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; file with the point coordinates saved</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.gui">
<tt class="descname">gui</tt><big>(</big><em>log=False</em>, <em>maximize=False</em>, <em>pick=True</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.gui" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>log</strong> &#8211; show z in log scale</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.peak_picker.PeakPicker.help">
<tt class="descname">help</tt><em class="property"> = ['Please select rings on the diffraction image. In parenthesis, some modified shortcuts for single button mouse (Apple):', ' * Right-click (click+n):         try an auto find for a ring', ' * Right-click + Ctrl (click+b):  create new group with one point', ' * Right-click + Shift (click+v): add one point to current group', ' * Right-click + m (click+m):     find more points for current group', ' * Center-click or (click+d):     erase current group', ' * Center-click + 1 or (click+1): erase closest point from current group']</em><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.help" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.init">
<tt class="descname">init</tt><big>(</big><em>method</em>, <em>sync=True</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Unified initializer</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.load">
<tt class="descname">load</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.load" title="Permalink to this definition">¶</a></dt>
<dd><p>load a filename and plot data on the screen (if GUI)</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.massif_contour">
<tt class="descname">massif_contour</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.massif_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Overlays a mask over a diffraction image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> &#8211; mask to be overlaid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.on_minus_pts_clicked">
<tt class="descname">on_minus_pts_clicked</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.on_minus_pts_clicked" title="Permalink to this definition">¶</a></dt>
<dd><p>callback function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.on_option_clicked">
<tt class="descname">on_option_clicked</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.on_option_clicked" title="Permalink to this definition">¶</a></dt>
<dd><p>callback function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.on_plus_pts_clicked">
<tt class="descname">on_plus_pts_clicked</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.on_plus_pts_clicked" title="Permalink to this definition">¶</a></dt>
<dd><p>callback function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.on_refine_clicked">
<tt class="descname">on_refine_clicked</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.on_refine_clicked" title="Permalink to this definition">¶</a></dt>
<dd><p>callback function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.onclick">
<tt class="descname">onclick</tt><big>(</big><em>event</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.onclick" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when a mouse is clicked</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.peaks_from_area">
<tt class="descname">peaks_from_area</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.peaks_from_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of peaks within an area</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mask</strong> &#8211; 2d array with mask.</li>
<li><strong>Imin</strong> &#8211; minimum of intensity above the background to keep the point</li>
<li><strong>keep</strong> &#8211; maximum number of points to keep</li>
<li><strong>method</strong> &#8211; enforce the use of detection using &#8220;massif&#8221; or &#8220;blob&#8221; or &#8220;watershed&#8221;</li>
<li><strong>ring</strong> &#8211; ring number to which assign the  points</li>
<li><strong>dmin</strong> &#8211; minimum distance between two peaks (in pixels)</li>
<li><strong>seed</strong> &#8211; good starting points.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of peaks [y,x], [y,x], ...]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.remove_grp">
<tt class="descname">remove_grp</tt><big>(</big><em>lbl</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.remove_grp" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a group of points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lbl</strong> &#8211; label of the group of points</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset control point and graph (if needed)</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.sync_init">
<tt class="descname">sync_init</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.sync_init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.peak_picker.PointGroup">
<em class="property">class </em><tt class="descclassname">pyFAI.peak_picker.</tt><tt class="descname">PointGroup</tt><big>(</big><em>points=None</em>, <em>ring=None</em>, <em>annotate=None</em>, <em>plot=None</em>, <em>force_label=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PointGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Class contains a group of points ...
They all belong to the same Debye-Scherrer ring</p>
<dl class="method">
<dt id="pyFAI.peak_picker.PointGroup.__init__">
<tt class="descname">__init__</tt><big>(</big><em>points=None</em>, <em>ring=None</em>, <em>annotate=None</em>, <em>plot=None</em>, <em>force_label=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>points</strong> &#8211; list of points</li>
<li><strong>ring</strong> &#8211; ring number</li>
<li><strong>annotate</strong> &#8211; reference to the matplotlib annotate output</li>
<li><strong>plot</strong> &#8211; reference to the matplotlib plot</li>
<li><strong>force_label</strong> &#8211; allows to enforce the label</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.peak_picker.PointGroup.code">
<tt class="descname">code</tt><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.code" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerical value for the label: mainly for sorting</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyFAI.peak_picker.PointGroup.get_label">
<em class="property">classmethod </em><tt class="descname">get_label</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.get_label" title="Permalink to this definition">¶</a></dt>
<dd><p>return the next label</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PointGroup.get_ring">
<tt class="descname">get_ring</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.get_ring" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.peak_picker.PointGroup.label">
<tt class="descname">label</tt><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.label" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.peak_picker.PointGroup.last_label">
<tt class="descname">last_label</tt><em class="property"> = 0</em><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.last_label" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pyFAI.peak_picker.PointGroup.reset_label">
<em class="property">classmethod </em><tt class="descname">reset_label</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.reset_label" title="Permalink to this definition">¶</a></dt>
<dd><p>reset intenal counter</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.peak_picker.PointGroup.ring">
<tt class="descname">ring</tt><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.ring" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pyFAI.peak_picker.PointGroup.set_label">
<em class="property">classmethod </em><tt class="descname">set_label</tt><big>(</big><em>label</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.set_label" title="Permalink to this definition">¶</a></dt>
<dd><p>update the internal counter if needed</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PointGroup.set_ring">
<tt class="descname">set_ring</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.set_ring" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.massif">
<span id="massif-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">massif</span></tt> Module<a class="headerlink" href="#module-pyFAI.massif" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.massif.Massif">
<em class="property">class </em><tt class="descclassname">pyFAI.massif.</tt><tt class="descname">Massif</tt><big>(</big><em>data=None</em><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A massif is defined as an area around a peak, it is used to find neighboring peaks</p>
<dl class="attribute">
<dt id="pyFAI.massif.Massif.TARGET_SIZE">
<tt class="descname">TARGET_SIZE</tt><em class="property"> = 1024</em><a class="headerlink" href="#pyFAI.massif.Massif.TARGET_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.__init__">
<tt class="descname">__init__</tt><big>(</big><em>data=None</em><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.calculate_massif">
<tt class="descname">calculate_massif</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.calculate_massif" title="Permalink to this definition">¶</a></dt>
<dd><p>defines a map of the massif around x and returns the mask</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.delValleySize">
<tt class="descname">delValleySize</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.delValleySize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.find_peaks">
<tt class="descname">find_peaks</tt><big>(</big><em>x</em>, <em>nmax=200</em>, <em>annotate=None</em>, <em>massif_contour=None</em>, <em>stdout=&lt;open file '&lt;stdout&gt;'</em>, <em>mode 'w' at 0x7f23416fe150&gt;</em><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.find_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>All in one function that finds a maximum from the given seed (x)
then calculates the region extension and extract position of the neighboring peaks.
:param x: seed for the calculation, input coordinates
:param nmax: maximum number of peak per region
:param annotate: call back method taking number of points + coordinate as input.
:param massif_contour: callback to show the contour of a massif with the given index.
:param stdout: this is the file where output is written by default.
:return: list of peaks</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.getBinnedData">
<tt class="descname">getBinnedData</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.getBinnedData" title="Permalink to this definition">¶</a></dt>
<dd><p>:return binned data</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.getBluredData">
<tt class="descname">getBluredData</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.getBluredData" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a blurred image</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.getLabeledMassif">
<tt class="descname">getLabeledMassif</tt><big>(</big><em>pattern=None</em><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.getLabeledMassif" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an image composed of int with a different value for each massif</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.getMedianData">
<tt class="descname">getMedianData</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.getMedianData" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a spacial median filtered image</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.getValleySize">
<tt class="descname">getValleySize</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.getValleySize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.initValleySize">
<tt class="descname">initValleySize</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.initValleySize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.nearest_peak">
<tt class="descname">nearest_peak</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.nearest_peak" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> &#8211; coordinates of the peak</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the coordinates of the nearest peak</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.peaks_from_area">
<tt class="descname">peaks_from_area</tt><big>(</big><em>mask</em>, <em>Imin=None</em>, <em>keep=1000</em>, <em>dmin=0.0</em>, <em>seed=None</em>, <em>**kwarg</em><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.peaks_from_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of peaks within an area</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mask</strong> &#8211; 2d array with mask.</li>
<li><strong>Imin</strong> &#8211; minimum of intensity above the background to keep the point</li>
<li><strong>keep</strong> &#8211; maximum number of points to keep</li>
<li><strong>kwarg</strong> &#8211; ignored parameters</li>
<li><strong>dmin</strong> &#8211; minimum distance to another peak</li>
<li><strong>seed</strong> &#8211; list of good guesses to start with</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of peaks [y,x], [y,x], ...]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.setValleySize">
<tt class="descname">setValleySize</tt><big>(</big><em>size</em><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.setValleySize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.massif.Massif.valley_size">
<tt class="descname">valley_size</tt><a class="headerlink" href="#pyFAI.massif.Massif.valley_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the minimum distance between two massifs</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.blob_detection">
<span id="blob-detection-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">blob_detection</span></tt> Module<a class="headerlink" href="#module-pyFAI.blob_detection" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.blob_detection.BlobDetection">
<em class="property">class </em><tt class="descclassname">pyFAI.blob_detection.</tt><tt class="descname">BlobDetection</tt><big>(</big><em>img</em>, <em>cur_sigma=0.25</em>, <em>init_sigma=0.5</em>, <em>dest_sigma=1</em>, <em>scale_per_octave=2</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Performs a blob detection:
<a class="reference external" href="http://en.wikipedia.org/wiki/Blob_detection">http://en.wikipedia.org/wiki/Blob_detection</a>
using a Difference of Gaussian + Pyramid of Gaussians</p>
<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.__init__">
<tt class="descname">__init__</tt><big>(</big><em>img</em>, <em>cur_sigma=0.25</em>, <em>init_sigma=0.5</em>, <em>dest_sigma=1</em>, <em>scale_per_octave=2</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a blob detection:
<a class="reference external" href="http://en.wikipedia.org/wiki/Blob_detection">http://en.wikipedia.org/wiki/Blob_detection</a>
using a Difference of Gaussian + Pyramid of Gaussians</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>img</strong> &#8211; input image</li>
<li><strong>cur_sigma</strong> &#8211; estimated smoothing of the input image. 0.25 correspond to no interaction between pixels.</li>
<li><strong>init_sigma</strong> &#8211; start searching at this scale (sigma=0.5: 10% interaction with first neighbor)</li>
<li><strong>dest_sigma</strong> &#8211; sigma at which the resolution is lowered (change of octave)</li>
<li><strong>scale_per_octave</strong> &#8211; Number of scale to be performed per octave</li>
<li><strong>mask</strong> &#8211; mask where pixel are not valid</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.direction">
<tt class="descname">direction</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform and plot the two main directions of the peaks, considering their previously
calculated scale ,by calculating the Hessian at different sizes as the combination of
gaussians and their first and second derivatives</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.nearest_peak">
<tt class="descname">nearest_peak</tt><big>(</big><em>p</em>, <em>refine=True</em>, <em>Imin=None</em><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.nearest_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the nearest peak from a position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> &#8211; input position (y,x) 2-tuple of float</li>
<li><strong>refine</strong> &#8211; shall the position be refined on the raw data</li>
<li><strong>Imin</strong> &#8211; minimum of intensity above the background</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.peaks_from_area">
<tt class="descname">peaks_from_area</tt><big>(</big><em>mask</em>, <em>keep=None</em>, <em>refine=True</em>, <em>Imin=None</em>, <em>dmin=0.0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.peaks_from_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of peaks within an area</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mask</strong> &#8211; 2d array with mask.</li>
<li><strong>refine</strong> &#8211; shall the position be refined on the raw data</li>
<li><strong>Imin</strong> &#8211; minimum of intensity above the background</li>
<li><strong>kwarg</strong> &#8211; ignored parameters</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of peaks [y,x], [y,x], ...]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.process">
<tt class="descname">process</tt><big>(</big><em>max_octave=None</em><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the keypoint extraction for max_octave cycles or until all octaves have been processed.
:param max_octave: number of octave to process</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.refine_Hessian">
<tt class="descname">refine_Hessian</tt><big>(</big><em>kpx</em>, <em>kpy</em>, <em>kps</em><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.refine_Hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>Refine the keypoint location based on a 3 point derivative, and delete
non-coherent keypoints.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>kpx</strong> &#8211; x_pos of keypoint</li>
<li><strong>kpy</strong> &#8211; y_pos of keypoint</li>
<li><strong>kps</strong> &#8211; s_pos of keypoint</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">arrays of corrected coordinates of keypoints, values and
locations of keypoints</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.refine_Hessian_SG">
<tt class="descname">refine_Hessian_SG</tt><big>(</big><em>kpx</em>, <em>kpy</em>, <em>kps</em><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.refine_Hessian_SG" title="Permalink to this definition">¶</a></dt>
<dd><p>Savitzky Golay algorithm to check if a point is really the maximum
:param kpx: x_pos of keypoint
:param kpy: y_pos of keypoint
:param kps: s_pos of keypoint
:return array of corrected keypoints</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.refinement">
<tt class="descname">refinement</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.refinement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.show_neighboor">
<tt class="descname">show_neighboor</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.show_neighboor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.show_stats">
<tt class="descname">show_stats</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.show_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Shows a window with the repartition of keypoint in function of scale/intensity</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.blob_detection.BlobDetection.tresh">
<tt class="descname">tresh</tt><em class="property"> = 0.6</em><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.tresh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.blob_detection.image_test">
<tt class="descclassname">pyFAI.blob_detection.</tt><tt class="descname">image_test</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.image_test" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyFAI.blob_detection.local_max">
<tt class="descclassname">pyFAI.blob_detection.</tt><tt class="descname">local_max</tt><big>(</big><em>dogs</em>, <em>mask=None</em>, <em>n_5=True</em><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.local_max" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dogs</strong> &#8211; 3d array with (sigma,y,x) containing difference of gaussians</li>
<li><strong>mask</strong> &#8211; mask out keypoint next to the mask (or inside the mask)</li>
<li><strong>n_5</strong> &#8211; look for a larger neighborhood</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.blob_detection.make_gaussian">
<tt class="descclassname">pyFAI.blob_detection.</tt><tt class="descname">make_gaussian</tt><big>(</big><em>im</em>, <em>sigma</em>, <em>xc</em>, <em>yc</em><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.make_gaussian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyFAI.calibrant">
<span id="calibrant-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">calibrant</span></tt> Module<a class="headerlink" href="#module-pyFAI.calibrant" title="Permalink to this headline">¶</a></h1>
<p>Calibrant</p>
<p>A module containing classical calibrant and also tools to generate d-spacing.</p>
<p>Interesting formula:
<a class="reference external" href="http://geoweb3.princeton.edu/research/MineralPhy/xtalgeometry.pdf">http://geoweb3.princeton.edu/research/MineralPhy/xtalgeometry.pdf</a></p>
<dl class="class">
<dt id="pyFAI.calibrant.Calibrant">
<em class="property">class </em><tt class="descclassname">pyFAI.calibrant.</tt><tt class="descname">Calibrant</tt><big>(</big><em>filename=None</em>, <em>dSpacing=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A calibrant is a reference compound where the d-spacing (interplanar distances)
are known. They are expressed in Angstrom (in the file)</p>
<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.__init__">
<tt class="descname">__init__</tt><big>(</big><em>filename=None</em>, <em>dSpacing=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.append_2th">
<tt class="descname">append_2th</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.append_2th" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.append_dSpacing">
<tt class="descname">append_dSpacing</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.append_dSpacing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibrant.Calibrant.dSpacing">
<tt class="descname">dSpacing</tt><a class="headerlink" href="#pyFAI.calibrant.Calibrant.dSpacing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.fake_calibration_image">
<tt class="descname">fake_calibration_image</tt><big>(</big><em>ai</em>, <em>shape=None</em>, <em>Imax=1.0</em>, <em>U=0</em>, <em>V=0</em>, <em>W=0.0001</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.fake_calibration_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a fake calibration image from an azimuthal integrator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ai</strong> &#8211; azimuthal integrator</li>
<li><strong>Imax</strong> &#8211; maximum intensity of rings</li>
<li><strong>V, W</strong> (<em>U,</em>) &#8211; width of the peak from Caglioti&#8217;s law (FWHM^2 = Utan(th)^2 + Vtan(th) + W)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.get_2th">
<tt class="descname">get_2th</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.get_2th" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.get_2th_index">
<tt class="descname">get_2th_index</tt><big>(</big><em>angle</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.get_2th_index" title="Permalink to this definition">¶</a></dt>
<dd><p>return the index in the 2theta angle index</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.get_dSpacing">
<tt class="descname">get_dSpacing</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.get_dSpacing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.get_wavelength">
<tt class="descname">get_wavelength</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.get_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.load_file">
<tt class="descname">load_file</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.load_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.save_dSpacing">
<tt class="descname">save_dSpacing</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.save_dSpacing" title="Permalink to this definition">¶</a></dt>
<dd><p>save the d-spacing to a file</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.setWavelength_change2th">
<tt class="descname">setWavelength_change2th</tt><big>(</big><em>value=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.setWavelength_change2th" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.setWavelength_changeDs">
<tt class="descname">setWavelength_changeDs</tt><big>(</big><em>value=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.setWavelength_changeDs" title="Permalink to this definition">¶</a></dt>
<dd><p>This is probably not a good idea, but who knows !</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.set_dSpacing">
<tt class="descname">set_dSpacing</tt><big>(</big><em>lst</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.set_dSpacing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.set_wavelength">
<tt class="descname">set_wavelength</tt><big>(</big><em>value=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.set_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibrant.Calibrant.wavelength">
<tt class="descname">wavelength</tt><a class="headerlink" href="#pyFAI.calibrant.Calibrant.wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.calibrant.Cell">
<em class="property">class </em><tt class="descclassname">pyFAI.calibrant.</tt><tt class="descname">Cell</tt><big>(</big><em>a=1</em>, <em>b=1</em>, <em>c=1</em>, <em>alpha=90</em>, <em>beta=90</em>, <em>gamma=90</em>, <em>lattice='triclinic'</em>, <em>lattice_type='P'</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This is a cell object, able to calculate the volume and d-spacing according to formula from:</p>
<p><a class="reference external" href="http://geoweb3.princeton.edu/research/MineralPhy/xtalgeometry.pdf">http://geoweb3.princeton.edu/research/MineralPhy/xtalgeometry.pdf</a></p>
<dl class="method">
<dt id="pyFAI.calibrant.Cell.__init__">
<tt class="descname">__init__</tt><big>(</big><em>a=1</em>, <em>b=1</em>, <em>c=1</em>, <em>alpha=90</em>, <em>beta=90</em>, <em>gamma=90</em>, <em>lattice='triclinic'</em>, <em>lattice_type='P'</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor of the Cell class:</p>
<p>Crystalographic units are Angstrom for distances and degrees for angles !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a,b,c</strong> &#8211; unit cell length in Angstrom</li>
<li><strong>beta, gamma</strong> (<em>alpha,</em>) &#8211; unit cell angle in degrees</li>
<li><strong>lattice</strong> &#8211; &#8220;cubic&#8221;, &#8220;tetragonal&#8221;, &#8220;hexagonal&#8221;, &#8220;rhombohedral&#8221;, &#8220;orthorhombic&#8221;, &#8220;monoclinic&#8221;, &#8220;triclinic&#8221;</li>
<li><strong>lattice_type</strong> &#8211; P, I, F, C or R</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pyFAI.calibrant.Cell.cubic">
<em class="property">classmethod </em><tt class="descname">cubic</tt><big>(</big><em>a</em>, <em>lattice_type='P'</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.cubic" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for cubic lattices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>a</strong> &#8211; unit cell length</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Cell.d">
<tt class="descname">d</tt><big>(</big><em>hkl</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.d" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the actual d-spacing for a 3-tuple of integer representing a
family of Miller plans</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hkl</strong> &#8211; 3-tuple of integers</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the inter-planar distance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Cell.d_spacing">
<tt class="descname">d_spacing</tt><big>(</big><em>dmin=1.0</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.d_spacing" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate all d-spacing down to dmin</p>
<p>applies selection rules</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dmin</strong> &#8211; minimum value of spacing requested</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict d-spacing as string, list of tuple with Miller indices
preceded with the numerical value</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pyFAI.calibrant.Cell.diamond">
<em class="property">classmethod </em><tt class="descname">diamond</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.diamond" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for Diamond type FCC like Si and Ge</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>a</strong> &#8211; unit cell length</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Cell.get_type">
<tt class="descname">get_type</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.get_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pyFAI.calibrant.Cell.hexagonal">
<em class="property">classmethod </em><tt class="descname">hexagonal</tt><big>(</big><em>a</em>, <em>c</em>, <em>lattice_type='P'</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.hexagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for hexagonal lattices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; unit cell length</li>
<li><strong>c</strong> &#8211; unit cell length</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibrant.Cell.lattices">
<tt class="descname">lattices</tt><em class="property"> = ['cubic', 'tetragonal', 'hexagonal', 'rhombohedral', 'orthorhombic', 'monoclinic', 'triclinic']</em><a class="headerlink" href="#pyFAI.calibrant.Cell.lattices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pyFAI.calibrant.Cell.monoclinic">
<em class="property">classmethod </em><tt class="descname">monoclinic</tt><big>(</big><em>a</em>, <em>b</em>, <em>c</em>, <em>beta</em>, <em>lattice_type='P'</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.monoclinic" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for hexagonal lattices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; unit cell length</li>
<li><strong>b</strong> &#8211; unit cell length</li>
<li><strong>c</strong> &#8211; unit cell length</li>
<li><strong>beta</strong> &#8211; unit cell angle</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pyFAI.calibrant.Cell.orthorhombic">
<em class="property">classmethod </em><tt class="descname">orthorhombic</tt><big>(</big><em>a</em>, <em>b</em>, <em>c</em>, <em>lattice_type='P'</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.orthorhombic" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for orthorhombic lattices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; unit cell length</li>
<li><strong>b</strong> &#8211; unit cell length</li>
<li><strong>c</strong> &#8211; unit cell length</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pyFAI.calibrant.Cell.rhombohedral">
<em class="property">classmethod </em><tt class="descname">rhombohedral</tt><big>(</big><em>a</em>, <em>alpha</em>, <em>lattice_type='P'</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.rhombohedral" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for hexagonal lattices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; unit cell length</li>
<li><strong>alpha</strong> &#8211; unit cell angle</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Cell.save">
<tt class="descname">save</tt><big>(</big><em>name</em>, <em>long_name=None</em>, <em>doi=None</em>, <em>dmin=1.0</em>, <em>dest_dir=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save informations about the cell in a d-spacing file, usable as Calibrant</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; name of the calibrant</li>
<li><strong>doi</strong> &#8211; reference of the publication used to parametrize the cell</li>
<li><strong>dmin</strong> &#8211; minimal d-spacing</li>
<li><strong>dest_dir</strong> &#8211; name of the directory where to save the result</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibrant.Cell.selection_rules">
<tt class="descname">selection_rules</tt><em class="property"> = None</em><a class="headerlink" href="#pyFAI.calibrant.Cell.selection_rules" title="Permalink to this definition">¶</a></dt>
<dd><p>contains a list of functions returning True(allowed)/False(forbiden)/None(unknown)</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Cell.set_type">
<tt class="descname">set_type</tt><big>(</big><em>lattice_type</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.set_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pyFAI.calibrant.Cell.tetragonal">
<em class="property">classmethod </em><tt class="descname">tetragonal</tt><big>(</big><em>a</em>, <em>c</em>, <em>lattice_type='P'</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.tetragonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for tetragonal lattices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; unit cell length</li>
<li><strong>c</strong> &#8211; unit cell length</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibrant.Cell.type">
<tt class="descname">type</tt><a class="headerlink" href="#pyFAI.calibrant.Cell.type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibrant.Cell.types">
<tt class="descname">types</tt><em class="property"> = {'I': 'Body centered', 'P': 'Primitive', 'C': 'Side centered', 'R': 'Rhombohedral', 'F': 'Face centered'}</em><a class="headerlink" href="#pyFAI.calibrant.Cell.types" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibrant.Cell.volume">
<tt class="descname">volume</tt><a class="headerlink" href="#pyFAI.calibrant.Cell.volume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.calibrant.calibrant_factory">
<em class="property">class </em><tt class="descclassname">pyFAI.calibrant.</tt><tt class="descname">calibrant_factory</tt><big>(</big><em>basedir=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.calibrant_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Behaves like a dict but is actually a factory:</p>
<p>Each time one retrieves an object it is a new geniune new calibrant (unmodified)</p>
<dl class="method">
<dt id="pyFAI.calibrant.calibrant_factory.__init__">
<tt class="descname">__init__</tt><big>(</big><em>basedir=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.calibrant_factory.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>basedir</strong> &#8211; directory name where to search for the calibrants</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.calibrant_factory.get">
<tt class="descname">get</tt><big>(</big><em>what</em>, <em>notfound=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.calibrant_factory.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.calibrant_factory.has_key">
<tt class="descname">has_key</tt><big>(</big><em>k</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.calibrant_factory.has_key" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.calibrant_factory.items">
<tt class="descname">items</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibrant.calibrant_factory.items" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.calibrant_factory.keys">
<tt class="descname">keys</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibrant.calibrant_factory.keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.calibrant_factory.values">
<tt class="descname">values</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibrant.calibrant_factory.values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.distortion">
<span id="distortion-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">distortion</span></tt> Module<a class="headerlink" href="#module-pyFAI.distortion" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.distortion.Distortion">
<em class="property">class </em><tt class="descclassname">pyFAI.distortion.</tt><tt class="descname">Distortion</tt><big>(</big><em>detector='detector'</em>, <em>shape=None</em>, <em>resize=False</em>, <em>empty=0</em>, <em>mask=None</em>, <em>method='CSR'</em>, <em>device=None</em>, <em>workgroup=8</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Distortion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class applies a distortion correction on an image.</p>
<p>New version compatible both with CSR and LUT...</p>
<dl class="method">
<dt id="pyFAI.distortion.Distortion.__init__">
<tt class="descname">__init__</tt><big>(</big><em>detector='detector'</em>, <em>shape=None</em>, <em>resize=False</em>, <em>empty=0</em>, <em>mask=None</em>, <em>method='CSR'</em>, <em>device=None</em>, <em>workgroup=8</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Distortion.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>detector</strong> &#8211; detector instance or detector name</li>
<li><strong>shape</strong> &#8211; shape of the output image</li>
<li><strong>resize</strong> &#8211; allow the output shape to be different from the input shape</li>
<li><strong>empty</strong> &#8211; value to be given for empty bins</li>
<li><strong>method</strong> &#8211; &#8220;lut&#8221; or &#8220;csr&#8221;, the former is faster</li>
<li><strong>device</strong> &#8211; Name of the device: None for OpenMP, &#8220;cpu&#8221; or &#8220;gpu&#8221; or the id of the OpenCL device a 2-tuple of integer</li>
<li><strong>workgroup</strong> &#8211; workgroup size for CSR on OpenCL</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Distortion.calc_LUT">
<tt class="descname">calc_LUT</tt><big>(</big><em>use_common=True</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Distortion.calc_LUT" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Look-up table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">look up table either in CSR or LUT format depending on serl.method</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Distortion.calc_init">
<tt class="descname">calc_init</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Distortion.calc_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize all arrays</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Distortion.calc_pos">
<tt class="descname">calc_pos</tt><big>(</big><em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Distortion.calc_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the pixel boundary position on the regular grid</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">pixel corner positions (in pixel units) on the regular grid</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of shape (nrow, ncol, 4, 2)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Distortion.calc_size">
<tt class="descname">calc_size</tt><big>(</big><em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Distortion.calc_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the number of pixels falling into every single bin and</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">max of pixel falling into a single bin</td>
</tr>
</tbody>
</table>
<p>Considering the &#8220;half-CCD&#8221; spline from ID11 which describes a (1025,2048) detector,
the physical location of pixels should go from:
[-17.48634 : 1027.0543, -22.768829 : 2028.3689]
We chose to discard pixels falling outside the [0:1025,0:2048] range with a lose of intensity</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Distortion.correct">
<tt class="descname">correct</tt><big>(</big><em>image</em>, <em>dummy=None</em>, <em>delta_dummy=None</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Distortion.correct" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct an image based on the look-up table calculated ...</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>image</strong> &#8211; 2D-array with the image</li>
<li><strong>dummy</strong> &#8211; value suggested for bad pixels</li>
<li><strong>delta_dummy</strong> &#8211; precision of the dummy value</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">corrected 2D image</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Distortion.reset">
<tt class="descname">reset</tt><big>(</big><em>method=None</em>, <em>device=None</em>, <em>workgroup=None</em>, <em>prepare=True</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Distortion.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the distortion correction and re-calculate the look-up table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>method</strong> &#8211; can be &#8220;lut&#8221; or &#8220;csr&#8221;, &#8220;lut&#8221; looks faster</li>
<li><strong>device</strong> &#8211; can be None, &#8220;cpu&#8221; or &#8220;gpu&#8221; or the id as a 2-tuple of integer</li>
<li><strong>worgroup</strong> &#8211; enforce the workgroup size for CSR.</li>
<li><strong>prepare</strong> &#8211; set to false to only reset and not re-initialize</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.distortion.Distortion.shape_out">
<tt class="descname">shape_out</tt><a class="headerlink" href="#pyFAI.distortion.Distortion.shape_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate/cache the output shape</p>
<p>:return output shape</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Distortion.uncorrect">
<tt class="descname">uncorrect</tt><big>(</big><em>image</em>, <em>use_cython=False</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Distortion.uncorrect" title="Permalink to this definition">¶</a></dt>
<dd><p>Take an image which has been corrected and transform it into it&#8217;s raw (with loss of information)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image</strong> &#8211; 2D-array with the image</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">uncorrected 2D image</td>
</tr>
</tbody>
</table>
<p>Nota: to retrieve the input mask on can do:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">msk</span> <span class="o">=</span>  <span class="n">dis</span><span class="o">.</span><span class="n">uncorrect</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">dis</span><span class="o">.</span><span class="n">_shape_out</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.distortion.Quad">
<em class="property">class </em><tt class="descclassname">pyFAI.distortion.</tt><tt class="descname">Quad</tt><big>(</big><em>buffer</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Quad modelisation.</p>
<img alt="Modelization of the quad" src="../_images/quad_model.svg" /><dl class="method">
<dt id="pyFAI.distortion.Quad.__init__">
<tt class="descname">__init__</tt><big>(</big><em>buffer</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.calc_area">
<tt class="descname">calc_area</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.calc_area" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.calc_area_AB">
<tt class="descname">calc_area_AB</tt><big>(</big><em>I1</em>, <em>I2</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.calc_area_AB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.calc_area_BC">
<tt class="descname">calc_area_BC</tt><big>(</big><em>J1</em>, <em>J2</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.calc_area_BC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.calc_area_CD">
<tt class="descname">calc_area_CD</tt><big>(</big><em>K1</em>, <em>K2</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.calc_area_CD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.calc_area_DA">
<tt class="descname">calc_area_DA</tt><big>(</big><em>L1</em>, <em>L2</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.calc_area_DA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.calc_area_old">
<tt class="descname">calc_area_old</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.calc_area_old" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.calc_area_vectorial">
<tt class="descname">calc_area_vectorial</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.calc_area_vectorial" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.get_box">
<tt class="descname">get_box</tt><big>(</big><em>i</em>, <em>j</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.get_box" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.get_box_size0">
<tt class="descname">get_box_size0</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.get_box_size0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.get_box_size1">
<tt class="descname">get_box_size1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.get_box_size1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.get_idx">
<tt class="descname">get_idx</tt><big>(</big><em>i</em>, <em>j</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.get_idx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.get_offset0">
<tt class="descname">get_offset0</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.get_offset0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.get_offset1">
<tt class="descname">get_offset1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.get_offset1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.init_slope">
<tt class="descname">init_slope</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.init_slope" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.integrateAB">
<tt class="descname">integrateAB</tt><big>(</big><em>start</em>, <em>stop</em>, <em>calc_area</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.integrateAB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.populate_box">
<tt class="descname">populate_box</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.populate_box" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.reinit">
<tt class="descname">reinit</tt><big>(</big><em>A0</em>, <em>A1</em>, <em>B0</em>, <em>B1</em>, <em>C0</em>, <em>C1</em>, <em>D0</em>, <em>D1</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.reinit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.distortion.test">
<tt class="descclassname">pyFAI.distortion.</tt><tt class="descname">test</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.test" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyFAI.worker">
<span id="worker-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">worker</span></tt> Module<a class="headerlink" href="#module-pyFAI.worker" title="Permalink to this headline">¶</a></h1>
<p>This module contains the Worker class:</p>
<p>A tool able to perform azimuthal integration with:
additional saving capabilities like</p>
<ul class="simple">
<li>save as 2/3D structure in a HDF5 File</li>
<li>read from HDF5 files</li>
</ul>
<p>Aims at being integrated into a plugin like LImA or as model for the GUI</p>
<p>The configuration of this class is mainly done via a dictionary transmitted as a JSON string:
Here are the valid keys:</p>
<ul class="simple">
<li>&#8220;dist&#8221;</li>
<li>&#8220;poni1&#8221;</li>
<li>&#8220;poni2&#8221;</li>
<li>&#8220;rot1&#8221;</li>
<li>&#8220;rot3&#8221;</li>
<li>&#8220;rot2&#8221;</li>
<li>&#8220;pixel1&#8221;</li>
<li>&#8220;pixel2&#8221;</li>
<li>&#8220;splineFile&#8221;</li>
<li>&#8220;wavelength&#8221;</li>
<li>&#8220;poni&#8221; #path of the file</li>
<li>&#8220;chi_discontinuity_at_0&#8221;</li>
<li>&#8220;do_mask&#8221;</li>
<li>&#8220;do_dark&#8221;</li>
<li>&#8220;do_azimuthal_range&#8221;</li>
<li>&#8220;do_flat&#8221;</li>
<li>&#8220;do_2D&#8221;</li>
<li>&#8220;azimuth_range_min&#8221;</li>
<li>&#8220;azimuth_range_max&#8221;</li>
<li>&#8220;polarization_factor&#8221;</li>
<li>&#8220;nbpt_rad&#8221;</li>
<li>&#8220;do_solid_angle&#8221;</li>
<li>&#8220;do_radial_range&#8221;</li>
<li>&#8220;do_poisson&#8221;</li>
<li>&#8220;delta_dummy&#8221;</li>
<li>&#8220;nbpt_azim&#8221;</li>
<li>&#8220;flat_field&#8221;</li>
<li>&#8220;radial_range_min&#8221;</li>
<li>&#8220;dark_current&#8221;</li>
<li>&#8220;do_polarization&#8221;</li>
<li>&#8220;mask_file&#8221;</li>
<li>&#8220;detector&#8221;</li>
<li>&#8220;unit&#8221;</li>
<li>&#8220;radial_range_max&#8221;</li>
<li>&#8220;val_dummy&#8221;</li>
<li>&#8220;do_dummy&#8221;</li>
<li>&#8220;method&#8221;</li>
</ul>
<dl class="class">
<dt id="pyFAI.worker.DistortionWorker">
<em class="property">class </em><tt class="descclassname">pyFAI.worker.</tt><tt class="descname">DistortionWorker</tt><big>(</big><em>detector=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>solidangle=None</em>, <em>polarization=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>device=None</em><big>)</big><a class="headerlink" href="#pyFAI.worker.DistortionWorker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple worker doing dark, flat, solid angle and polarization correction</p>
<dl class="method">
<dt id="pyFAI.worker.DistortionWorker.__init__">
<tt class="descname">__init__</tt><big>(</big><em>detector=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>solidangle=None</em>, <em>polarization=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>device=None</em><big>)</big><a class="headerlink" href="#pyFAI.worker.DistortionWorker.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor of the worker
:param dark: array 
:param flat: array
:param solidangle: solid-angle array
:param polarization: numpy array with 2D polarization corrections
:param device: Used to influance OpenCL behavour: can be &#8220;cpu&#8221;, &#8220;GPU&#8221;, &#8220;Acc&#8221; or even an OpenCL context</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.worker.DistortionWorker.process">
<tt class="descname">process</tt><big>(</big><em>data</em>, <em>normalization_factor=1.0</em><big>)</big><a class="headerlink" href="#pyFAI.worker.DistortionWorker.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data and apply a normalization factor
:param data: input data
:param normalization: normalization factor
:return processed data</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.worker.PixelwiseWorker">
<em class="property">class </em><tt class="descclassname">pyFAI.worker.</tt><tt class="descname">PixelwiseWorker</tt><big>(</big><em>dark=None</em>, <em>flat=None</em>, <em>solidangle=None</em>, <em>polarization=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>device=None</em><big>)</big><a class="headerlink" href="#pyFAI.worker.PixelwiseWorker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple worker doing dark, flat, solid angle and polarization correction</p>
<dl class="method">
<dt id="pyFAI.worker.PixelwiseWorker.__init__">
<tt class="descname">__init__</tt><big>(</big><em>dark=None</em>, <em>flat=None</em>, <em>solidangle=None</em>, <em>polarization=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>device=None</em><big>)</big><a class="headerlink" href="#pyFAI.worker.PixelwiseWorker.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor of the worker</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dark</strong> &#8211; array</li>
<li><strong>flat</strong> &#8211; array</li>
<li><strong>solidangle</strong> &#8211; solid-angle array</li>
<li><strong>polarization</strong> &#8211; numpy array with 2D polarization corrections</li>
<li><strong>device</strong> &#8211; Used to influance OpenCL behavour: can be &#8220;cpu&#8221;, &#8220;GPU&#8221;, &#8220;Acc&#8221; or even an OpenCL context</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.worker.PixelwiseWorker.process">
<tt class="descname">process</tt><big>(</big><em>data</em>, <em>normalization_factor=None</em><big>)</big><a class="headerlink" href="#pyFAI.worker.PixelwiseWorker.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data and apply a normalization factor
:param data: input data
:param normalization: normalization factor
:return processed data</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.worker.Worker">
<em class="property">class </em><tt class="descclassname">pyFAI.worker.</tt><tt class="descname">Worker</tt><big>(</big><em>azimuthalIntegrator=None</em>, <em>shapeIn=(2048</em>, <em>2048)</em>, <em>shapeOut=(360</em>, <em>500)</em>, <em>unit='r_mm'</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>azimuthalIntgrator=None</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="pyFAI.worker.Worker.__init__">
<tt class="descname">__init__</tt><big>(</big><em>azimuthalIntegrator=None</em>, <em>shapeIn=(2048</em>, <em>2048)</em>, <em>shapeOut=(360</em>, <em>500)</em>, <em>unit='r_mm'</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>azimuthalIntgrator=None</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>AzimuthalIntegrator</strong> (<em>azimuthalIntgrator</em>) &#8211; pyFAI.AzimuthalIntegrator instance</li>
<li><strong>AzimuthalIntegrator</strong> &#8211; pyFAI.AzimuthalIntegrator instance (deprecated)</li>
<li><strong>shapeIn</strong> &#8211; image size in input</li>
<li><strong>shapeOut</strong> &#8211; Integrated size: can be (1,2000) for 1D integration</li>
<li><strong>unit</strong> &#8211; can be &#8220;2th_deg, r_mm or q_nm^-1 ...</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.do_2D">
<tt class="descname">do_2D</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.do_2D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.worker.Worker.error_model">
<tt class="descname">error_model</tt><a class="headerlink" href="#pyFAI.worker.Worker.error_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.get_config">
<tt class="descname">get_config</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.get_config" title="Permalink to this definition">¶</a></dt>
<dd><p>return configuration as a dictionary</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.get_error_model">
<tt class="descname">get_error_model</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.get_error_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.get_json_config">
<tt class="descname">get_json_config</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.get_json_config" title="Permalink to this definition">¶</a></dt>
<dd><p>return configuration as a JSON string</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.get_normalization_factor">
<tt class="descname">get_normalization_factor</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.get_normalization_factor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.get_unit">
<tt class="descname">get_unit</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.get_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.worker.Worker.normalization_factor">
<tt class="descname">normalization_factor</tt><a class="headerlink" href="#pyFAI.worker.Worker.normalization_factor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.process">
<tt class="descname">process</tt><big>(</big><em>data</em>, <em>normalization_factor=1.0</em>, <em>writer=None</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Process a frame
#TODO:
dark, flat, sa are missing</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; numpy array containing the input image</li>
<li><strong>writer</strong> &#8211; An open writer in which &#8216;write&#8217; will be called with the result of the integration</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.reconfig">
<tt class="descname">reconfig</tt><big>(</big><em>shape=(2048</em>, <em>2048)</em>, <em>sync=False</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.reconfig" title="Permalink to this definition">¶</a></dt>
<dd><p>This is just to force the integrator to initialize with a given input image shape</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shape</strong> &#8211; shape of the input image</li>
<li><strong>sync</strong> &#8211; return only when synchronized</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>this is just to force the integrator to initialize</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.save_config">
<tt class="descname">save_config</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.save_config" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.setDarkcurrentFile">
<tt class="descname">setDarkcurrentFile</tt><big>(</big><em>imagefile</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.setDarkcurrentFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.setExtension">
<tt class="descname">setExtension</tt><big>(</big><em>ext</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.setExtension" title="Permalink to this definition">¶</a></dt>
<dd><p>enforce the extension of the processed data file written</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.setFlatfieldFile">
<tt class="descname">setFlatfieldFile</tt><big>(</big><em>imagefile</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.setFlatfieldFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.setJsonConfig">
<tt class="descname">setJsonConfig</tt><big>(</big><em>jsonconfig</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.setJsonConfig" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.setSubdir">
<tt class="descname">setSubdir</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.setSubdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the relative or absolute path for processed data</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.set_error_model">
<tt class="descname">set_error_model</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.set_error_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.set_normalization_factor">
<tt class="descname">set_normalization_factor</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.set_normalization_factor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.set_unit">
<tt class="descname">set_unit</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.set_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.worker.Worker.unit">
<tt class="descname">unit</tt><a class="headerlink" href="#pyFAI.worker.Worker.unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.warmup">
<tt class="descname">warmup</tt><big>(</big><em>sync=False</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.warmup" title="Permalink to this definition">¶</a></dt>
<dd><p>Process a dummy image to ensure everything is initialized</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sync</strong> &#8211; wait for processing to be finished</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.worker.make_ai">
<tt class="descclassname">pyFAI.worker.</tt><tt class="descname">make_ai</tt><big>(</big><em>config</em><big>)</big><a class="headerlink" href="#pyFAI.worker.make_ai" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an Azimuthal integrator from the configuration
stand alone function !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>config</strong> &#8211; dict with all parameters</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">configured (but uninitialized) AzimuthalIntgrator</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pyFAI.units">
<span id="units-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">units</span></tt> Module<a class="headerlink" href="#module-pyFAI.units" title="Permalink to this headline">¶</a></h1>
<p>Manages the different units</p>
<p>Nota for developers: this module is used a singleton to store all units in a
unique manner. This explains the number of top-level variables on the one
hand and their CAPITALIZATION on the other.</p>
<dl class="class">
<dt id="pyFAI.units.Unit">
<em class="property">class </em><tt class="descclassname">pyFAI.units.</tt><tt class="descname">Unit</tt><big>(</big><em>name</em>, <em>scale=1</em>, <em>label=None</em>, <em>equation=None</em>, <em>center=None</em>, <em>corner=None</em>, <em>delta=None</em><big>)</big><a class="headerlink" href="#pyFAI.units.Unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Represents a unit.</p>
<p>It has at least a name and a scale (in SI-unit)</p>
<dl class="method">
<dt id="pyFAI.units.Unit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>name</em>, <em>scale=1</em>, <em>label=None</em>, <em>equation=None</em>, <em>center=None</em>, <em>corner=None</em>, <em>delta=None</em><big>)</big><a class="headerlink" href="#pyFAI.units.Unit.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor of a unit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>(str)</em>) &#8211; name of the unit</li>
<li><strong>scale</strong> (<em>(float)</em>) &#8211; scale of th unit to go to SI</li>
<li><strong>label</strong> (<em>(string)</em>) &#8211; label for nice representation in matplotlib,
can use latex representation</li>
<li><strong>equation</strong> (<em>(funct)</em>) &#8211; equation to calculate the value from coordinates
(x,y,z) in detector space.
Parameters of the function are x, y, z, lambda</li>
<li><strong>center</strong> (<em>(str)</em>) &#8211; name of the fast-path function</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.units.Unit.get">
<tt class="descname">get</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#pyFAI.units.Unit.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Mimic the dictionary interface</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>(str)</em>) &#8211; key wanted</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self.key</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.units.eq_2th">
<tt class="descclassname">pyFAI.units.</tt><tt class="descname">eq_2th</tt><big>(</big><em>x</em>, <em>y</em>, <em>z</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.units.eq_2th" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the 2theta aperture of the cone</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; horizontal position, towards the center of the ring, from sample position</li>
<li><strong>y</strong> &#8211; Vertical position, to the roof, from sample position</li>
<li><strong>z</strong> &#8211; distance from sample along the beam</li>
<li><strong>wavelength</strong> &#8211; in meter</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.units.eq_q">
<tt class="descclassname">pyFAI.units.</tt><tt class="descname">eq_q</tt><big>(</big><em>x</em>, <em>y</em>, <em>z</em>, <em>wavelength</em><big>)</big><a class="headerlink" href="#pyFAI.units.eq_q" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the modulus of the scattering vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; horizontal position, towards the center of the ring, from sample position</li>
<li><strong>y</strong> &#8211; Vertical position, to the roof, from sample position</li>
<li><strong>z</strong> &#8211; distance from sample along the beam</li>
<li><strong>wavelength</strong> &#8211; in meter</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.units.eq_r">
<tt class="descclassname">pyFAI.units.</tt><tt class="descname">eq_r</tt><big>(</big><em>x</em>, <em>y</em>, <em>z=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.units.eq_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the radius</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; horizontal position, towards the center of the ring, from sample position</li>
<li><strong>y</strong> &#8211; Vertical position, to the roof, from sample position</li>
<li><strong>z</strong> &#8211; distance from sample along the beam</li>
<li><strong>wavelength</strong> &#8211; in meter</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.units.register_radial_unit">
<tt class="descclassname">pyFAI.units.</tt><tt class="descname">register_radial_unit</tt><big>(</big><em>name</em>, <em>scale=1</em>, <em>label=None</em>, <em>equation=None</em>, <em>center=None</em>, <em>corner=None</em>, <em>delta=None</em><big>)</big><a class="headerlink" href="#pyFAI.units.register_radial_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyFAI.units.to_unit">
<tt class="descclassname">pyFAI.units.</tt><tt class="descname">to_unit</tt><big>(</big><em>obj</em>, <em>type_=None</em><big>)</big><a class="headerlink" href="#pyFAI.units.to_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyFAI.utils">
<span id="utils-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">utils</span></tt> Module<a class="headerlink" href="#module-pyFAI.utils" title="Permalink to this headline">¶</a></h1>
<p>Utilities, mainly for image treatment</p>
<dl class="class">
<dt id="pyFAI.utils.FixedParameters">
<em class="property">class </em><tt class="descclassname">pyFAI.utils.</tt><tt class="descname">FixedParameters</tt><a class="headerlink" href="#pyFAI.utils.FixedParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">set</span></tt></p>
<p>Like a set, made for FixedParameters in geometry refinement</p>
<dl class="method">
<dt id="pyFAI.utils.FixedParameters.add_or_discard">
<tt class="descname">add_or_discard</tt><big>(</big><em>key</em>, <em>value=True</em><big>)</big><a class="headerlink" href="#pyFAI.utils.FixedParameters.add_or_discard" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a value to a set if value, else discard it
:param key: element to added or discared from set
:type value: boolean. If None do nothing !
:return: None</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.binning">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">binning</tt><big>(</big><em>input_img</em>, <em>binsize</em>, <em>norm=True</em><big>)</big><a class="headerlink" href="#pyFAI.utils.binning" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>input_img</strong> &#8211; input ndarray</li>
<li><strong>binsize</strong> &#8211; int or 2-tuple representing the size of the binning</li>
<li><strong>norm</strong> &#8211; if False, do average instead of sum</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">binned input ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.calc_checksum">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">calc_checksum</tt><big>(</big><em>ary</em>, <em>safe=True</em><big>)</big><a class="headerlink" href="#pyFAI.utils.calc_checksum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the checksum by default (or returns its buffer location if unsafe)</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.center_of_mass">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">center_of_mass</tt><big>(</big><em>img</em><big>)</big><a class="headerlink" href="#pyFAI.utils.center_of_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the center of mass of of the array.
Like scipy.ndimage.measurements.center_of_mass
:param img: 2-D array
:return: 2-tuple of float with the center of mass</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.concatenate_cl_kernel">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">concatenate_cl_kernel</tt><big>(</big><em>filenames</em><big>)</big><a class="headerlink" href="#pyFAI.utils.concatenate_cl_kernel" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filenames</strong> (<em>list of str which can be filename of kernel as a string.</em>) &#8211; filenames containing the kernels</td>
</tr>
</tbody>
</table>
<p>this method concatenates all the kernel from the list</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.convert_CamelCase">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">convert_CamelCase</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#pyFAI.utils.convert_CamelCase" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a function name in CamelCase into camel_case</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.deg2rad">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">deg2rad</tt><big>(</big><em>dd</em><big>)</big><a class="headerlink" href="#pyFAI.utils.deg2rad" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert degrees to radian in the range -pi-&gt;pi</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dd</strong> &#8211; angle in degrees</td>
</tr>
</tbody>
</table>
<p>Nota: depending on the platform it could be 0&lt;2pi
A branch is cheaper than a trigo operation</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.dog">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">dog</tt><big>(</big><em>s1</em>, <em>s2</em>, <em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.utils.dog" title="Permalink to this definition">¶</a></dt>
<dd><p>2D difference of gaussian
typically 1 to 10 parameters</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.dog_filter">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">dog_filter</tt><big>(</big><em>input_img</em>, <em>sigma1</em>, <em>sigma2</em>, <em>mode='reflect'</em>, <em>cval=0.0</em><big>)</big><a class="headerlink" href="#pyFAI.utils.dog_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>2-dimensional Difference of Gaussian filter implemented with FFT</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_img</strong> (<em>array-like</em>) &#8211; input_img array to filter</li>
<li><strong>sigma</strong> (<em>scalar or sequence of scalars</em>) &#8211; standard deviation for Gaussian kernel.
The standard deviations of the Gaussian filter are given for each axis as a sequence,
or as a single number, in which case it is equal for all axes.</li>
<li><strong>mode</strong> &#8211; {&#8216;reflect&#8217;,&#8217;constant&#8217;,&#8217;nearest&#8217;,&#8217;mirror&#8217;, &#8216;wrap&#8217;}, optional
The <tt class="docutils literal"><span class="pre">mode</span></tt> parameter determines how the array borders are
handled, where <tt class="docutils literal"><span class="pre">cval</span></tt> is the value when mode is equal to
&#8216;constant&#8217;. Default is &#8216;reflect&#8217;</li>
<li><strong>cval</strong> &#8211; scalar, optional
Value to fill past edges of input if <tt class="docutils literal"><span class="pre">mode</span></tt> is &#8216;constant&#8217;. Default is 0.0</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.expand">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">expand</tt><big>(</big><em>input_img</em>, <em>sigma</em>, <em>mode='constant'</em>, <em>cval=0.0</em><big>)</big><a class="headerlink" href="#pyFAI.utils.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand array a with its reflection on boundaries</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; 2D array</li>
<li><strong>sigma</strong> &#8211; float or 2-tuple of floats.</li>
<li><strong>mode</strong> &#8211; &#8220;constant&#8221;, &#8220;nearest&#8221;, &#8220;reflect&#8221; or &#8220;mirror&#8221;</li>
<li><strong>cval</strong> &#8211; filling value used for constant, 0.0 by default</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Nota: sigma is the half-width of the kernel. For gaussian convolution it is adviced that it is 4*sigma_of_gaussian</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.expand2d">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">expand2d</tt><big>(</big><em>vect</em>, <em>size2</em>, <em>vertical=True</em><big>)</big><a class="headerlink" href="#pyFAI.utils.expand2d" title="Permalink to this definition">¶</a></dt>
<dd><p>This expands a vector to a 2d-array.</p>
<p>The result is the same as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">vertical</span><span class="p">:</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size2</span><span class="p">),</span> <span class="n">vect</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size2</span><span class="p">))</span>
</pre></div>
</div>
<p>This is a ninja optimization: replace *1 with a memcopy, saves 50% of
time at the ms level.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vect</strong> &#8211; 1d vector</li>
<li><strong>size2</strong> &#8211; size of the expanded dimension</li>
<li><strong>vertical</strong> &#8211; if False the vector is expanded to the first dimension.
If True, it is expanded to the second dimension.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.expand_args">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">expand_args</tt><big>(</big><em>args</em><big>)</big><a class="headerlink" href="#pyFAI.utils.expand_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes an argv and expand it (under Windows, cmd does not convert <tt class="docutils literal"><span class="pre">*.tif</span></tt>
into a list of files.
Keeps only valid files (thanks to glob)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> &#8211; list of files or wilcards</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list of actual args</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.float_">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">float_</tt><big>(</big><em>val</em><big>)</big><a class="headerlink" href="#pyFAI.utils.float_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert anything to a float ... or None if not applicable</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.gaussian">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">gaussian</tt><big>(</big><em>M</em>, <em>std</em><big>)</big><a class="headerlink" href="#pyFAI.utils.gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Gaussian window of length M with standard-deviation std.</p>
<p>This differs from the scipy.signal.gaussian implementation as:
- The default for sym=False (needed for gaussian filtering without shift)
- This implementation is normalized</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>M</strong> &#8211; length of the windows (int)</li>
<li><strong>std</strong> &#8211; standatd deviation sigma</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The FWHM is 2*numpy.sqrt(2 * numpy.pi)*std</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.gaussian_filter">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">gaussian_filter</tt><big>(</big><em>input_img</em>, <em>sigma</em>, <em>mode='reflect'</em>, <em>cval=0.0</em>, <em>use_scipy=True</em><big>)</big><a class="headerlink" href="#pyFAI.utils.gaussian_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>2-dimensional Gaussian filter implemented with FFT</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_img</strong> (<em>array-like</em>) &#8211; input array to filter</li>
<li><strong>sigma</strong> (<em>scalar or sequence of scalars</em>) &#8211; standard deviation for Gaussian kernel.
The standard deviations of the Gaussian filter are given for each axis as a sequence,
or as a single number, in which case it is equal for all axes.</li>
<li><strong>mode</strong> &#8211; {&#8216;reflect&#8217;,&#8217;constant&#8217;,&#8217;nearest&#8217;,&#8217;mirror&#8217;, &#8216;wrap&#8217;}, optional
The <tt class="docutils literal"><span class="pre">mode</span></tt> parameter determines how the array borders are
handled, where <tt class="docutils literal"><span class="pre">cval</span></tt> is the value when mode is equal to
&#8216;constant&#8217;. Default is &#8216;reflect&#8217;</li>
<li><strong>cval</strong> &#8211; scalar, optional
Value to fill past edges of input if <tt class="docutils literal"><span class="pre">mode</span></tt> is &#8216;constant&#8217;. Default is 0.0</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.get_calibration_dir">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">get_calibration_dir</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.utils.get_calibration_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>get the full path of a calibration directory</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the full path of the calibrant file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.get_cl_file">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">get_cl_file</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.utils.get_cl_file" title="Permalink to this definition">¶</a></dt>
<dd><p>get the full path of a openCL file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the full path of the openCL source file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.get_ui_file">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">get_ui_file</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.utils.get_ui_file" title="Permalink to this definition">¶</a></dt>
<dd><p>get the full path of a user-interface file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the full path of the ui</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.int_">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">int_</tt><big>(</big><em>val</em><big>)</big><a class="headerlink" href="#pyFAI.utils.int_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert anything to an int ... or None if not applicable</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.is_far_from_group">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">is_far_from_group</tt><big>(</big><em>pt</em>, <em>lst_pts</em>, <em>d2</em><big>)</big><a class="headerlink" href="#pyFAI.utils.is_far_from_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells if a point is far from a group of points, distance greater than d2 (distance squared)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pt</strong> &#8211; point of interest</li>
<li><strong>lst_pts</strong> &#8211; list of points</li>
<li><strong>d2</strong> &#8211; minimum distance squarred</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True If the point is far from all others.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pyFAI.utils.lazy_property">
<em class="property">class </em><tt class="descclassname">pyFAI.utils.</tt><tt class="descname">lazy_property</tt><big>(</big><em>fget</em><big>)</big><a class="headerlink" href="#pyFAI.utils.lazy_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>meant to be used for lazy evaluation of an object attribute.
property should represent non-mutable data, as it replaces itself.</p>
<dl class="method">
<dt id="pyFAI.utils.lazy_property.__init__">
<tt class="descname">__init__</tt><big>(</big><em>fget</em><big>)</big><a class="headerlink" href="#pyFAI.utils.lazy_property.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.maximum_position">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">maximum_position</tt><big>(</big><em>img</em><big>)</big><a class="headerlink" href="#pyFAI.utils.maximum_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as scipy.ndimage.measurements.maximum_position:
Find the position of the maximum of the values of the array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>img</strong> &#8211; 2-D image</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">2-tuple of int with the position of the maximum</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.measure_offset">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">measure_offset</tt><big>(</big><em>img1</em>, <em>img2</em>, <em>method='numpy'</em>, <em>withLog=False</em>, <em>withCorr=False</em><big>)</big><a class="headerlink" href="#pyFAI.utils.measure_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Measure the actual offset between 2 images
:param img1: ndarray, first image
:param img2: ndarray, second image, same shape as img1
:param withLog: shall we return logs as well ? boolean
:return: tuple of floats with the offsets</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.readFloatFromKeyboard">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">readFloatFromKeyboard</tt><big>(</big><em>text</em>, <em>dictVar</em><big>)</big><a class="headerlink" href="#pyFAI.utils.readFloatFromKeyboard" title="Permalink to this definition">¶</a></dt>
<dd><p>Read float from the keyboard ....</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>text</strong> &#8211; string to be displayed</li>
<li><strong>dictVar</strong> &#8211; dict of this type: {1: [set_dist_min],3: [set_dist_min, set_dist_guess, set_dist_max]}</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.read_cl_file">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">read_cl_file</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.utils.read_cl_file" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; read an OpenCL file and apply a preprocessor</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">preprocessed source code</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.relabel">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">relabel</tt><big>(</big><em>label</em>, <em>data</em>, <em>blured</em>, <em>max_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.utils.relabel" title="Permalink to this definition">¶</a></dt>
<dd><p>Relabel limits the number of region in the label array.
They are ranked relatively to their max(I0)-max(blur(I0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>label</strong> &#8211; a label array coming out of <tt class="docutils literal"><span class="pre">scipy.ndimage.measurement.label</span></tt></li>
<li><strong>data</strong> &#8211; an array containing the raw data</li>
<li><strong>blured</strong> &#8211; an array containing the blurred data</li>
<li><strong>max_size</strong> &#8211; the max number of label wanted</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">array like label</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.roundfft">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">roundfft</tt><big>(</big><em>N</em><big>)</big><a class="headerlink" href="#pyFAI.utils.roundfft" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the integer &gt;=N for which size the Fourier analysis is faster (fron the FFT point of view)
Credit: Alessandro Mirone, ESRF, 2012</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>N</strong> &#8211; interger on which one would like to do a Fourier transform</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">integer with a better choice</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.shift">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">shift</tt><big>(</big><em>input_img</em>, <em>shift_val</em><big>)</big><a class="headerlink" href="#pyFAI.utils.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift an array like  scipy.ndimage.interpolation.shift(input_img, shift_val, mode=&#8221;wrap&#8221;, order=0) but faster
:param input_img: 2d numpy array
:param shift_val: 2-tuple of integers
:return: shifted image</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.shiftFFT">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">shiftFFT</tt><big>(</big><em>input_img</em>, <em>shift_val</em>, <em>method='fft'</em><big>)</big><a class="headerlink" href="#pyFAI.utils.shiftFFT" title="Permalink to this definition">¶</a></dt>
<dd><p>Do shift using FFTs</p>
<p>Shift an array like  scipy.ndimage.interpolation.shift(input, shift, mode=&#8221;wrap&#8221;, order=&#8221;infinity&#8221;) but faster
:param input_img: 2d numpy array
:param shift_val: 2-tuple of float
:return: shifted image</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.str_">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">str_</tt><big>(</big><em>val</em><big>)</big><a class="headerlink" href="#pyFAI.utils.str_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert anything to a string ... but None -&gt; &#8220;&#8221;</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.unBinning">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">unBinning</tt><big>(</big><em>binnedArray</em>, <em>binsize</em>, <em>norm=True</em><big>)</big><a class="headerlink" href="#pyFAI.utils.unBinning" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>binnedArray</strong> &#8211; input ndarray</li>
<li><strong>binsize</strong> &#8211; 2-tuple representing the size of the binning</li>
<li><strong>norm</strong> &#8211; if True (default) decrease the intensity by binning factor. If False, it is non-conservative</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">unBinned input ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pyFAI.gui.utils">
<span id="gui-gui-utils-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">gui.gui_utils</span></tt> Module<a class="headerlink" href="#module-pyFAI.gui.utils" title="Permalink to this headline">¶</a></h1>
<p>Module providing gui util tools</p>
<dl class="class">
<dt id="pyFAI.gui.utils.Event">
<em class="property">class </em><tt class="descclassname">pyFAI.gui.utils.</tt><tt class="descname">Event</tt><big>(</big><em>width</em>, <em>height</em><big>)</big><a class="headerlink" href="#pyFAI.gui.utils.Event" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Dummy class for dummy things</p>
<dl class="method">
<dt id="pyFAI.gui.utils.Event.__init__">
<tt class="descname">__init__</tt><big>(</big><em>width</em>, <em>height</em><big>)</big><a class="headerlink" href="#pyFAI.gui.utils.Event.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.gui.utils.maximize_fig">
<tt class="descclassname">pyFAI.gui.utils.</tt><tt class="descname">maximize_fig</tt><big>(</big><em>fig=None</em><big>)</big><a class="headerlink" href="#pyFAI.gui.utils.maximize_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to set the figure fullscreen</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.gui.utils.update_fig">
<tt class="descclassname">pyFAI.gui.utils.</tt><tt class="descname">update_fig</tt><big>(</big><em>fig=None</em><big>)</big><a class="headerlink" href="#pyFAI.gui.utils.update_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>Update a matplotlib figure with a Qt4 backend</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fig</strong> &#8211; pylab figure</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="ext-bilinear-module">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">ext.bilinear</span></tt> Module<a class="headerlink" href="#ext-bilinear-module" title="Permalink to this headline">¶</a></h1>
<p>This extension makes a discrete 2D-array appear like a continuous function thanks
to bilinear interpolations.</p>
<span class="target" id="module-pyFAI.ext.bilinear"></span><dl class="class">
<dt id="pyFAI.ext.bilinear.Bilinear">
<em class="property">class </em><tt class="descclassname">pyFAI.ext.bilinear.</tt><tt class="descname">Bilinear</tt><a class="headerlink" href="#pyFAI.ext.bilinear.Bilinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Bilinear interpolator for finding max.</p>
<p>Instance attribute defined in pxd file</p>
<dl class="method">
<dt id="pyFAI.ext.bilinear.Bilinear.cp_local_maxi">
<tt class="descname">cp_local_maxi</tt><big>(</big><em>self</em>, <em>size_t x</em><big>)</big> &rarr; size_t<a class="headerlink" href="#pyFAI.ext.bilinear.Bilinear.cp_local_maxi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.bilinear.Bilinear.data">
<tt class="descname">data</tt><a class="headerlink" href="#pyFAI.ext.bilinear.Bilinear.data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.bilinear.Bilinear.f_cy">
<tt class="descname">f_cy</tt><big>(</big><em>self</em>, <em>x</em><big>)</big><a class="headerlink" href="#pyFAI.ext.bilinear.Bilinear.f_cy" title="Permalink to this definition">¶</a></dt>
<dd><p>Function f((y,x)) where f is a continuous function (y,x) are pixel coordinates
&#64;param x: 2-tuple of float
&#64;return: Interpolated signal from the image (negative for minimizer)</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.bilinear.Bilinear.height">
<tt class="descname">height</tt><a class="headerlink" href="#pyFAI.ext.bilinear.Bilinear.height" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.bilinear.Bilinear.local_maxi">
<tt class="descname">local_maxi</tt><big>(</big><em>self</em>, <em>x</em><big>)</big><a class="headerlink" href="#pyFAI.ext.bilinear.Bilinear.local_maxi" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the local maximum ... with sub-pixel refinement</p>
<p>&#64;param x: 2-tuple of integers
&#64;param w: half with of the window: 1 or 2 are advised
&#64;return: 2-tuple of float with the nearest local maximum</p>
<p>Sub-pixel refinement:
Second order Taylor expansion of the function; first derivative is null
delta = x-i = -Inverse[Hessian].gradient</p>
<p>if Hessian is singular or <a href="#id4"><span class="problematic" id="id5">|delta|</span></a>&gt;1: use a center of mass.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.bilinear.Bilinear.maxi">
<tt class="descname">maxi</tt><a class="headerlink" href="#pyFAI.ext.bilinear.Bilinear.maxi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.bilinear.Bilinear.mini">
<tt class="descname">mini</tt><a class="headerlink" href="#pyFAI.ext.bilinear.Bilinear.mini" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.bilinear.Bilinear.width">
<tt class="descname">width</tt><a class="headerlink" href="#pyFAI.ext.bilinear.Bilinear.width" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.bilinear.calc_cartesian_positions">
<tt class="descclassname">pyFAI.ext.bilinear.</tt><tt class="descname">calc_cartesian_positions</tt><a class="headerlink" href="#pyFAI.ext.bilinear.calc_cartesian_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>calc_cartesian_positions(signatures, args, kwargs, defaults)</p>
<p>Calculate the Cartesian position for array of position (d1, d2)
with pixel coordinated stored in array pos
This is bilinear interpolation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>d1</strong> &#8211; position in dim1</li>
<li><strong>d2</strong> &#8211; position in dim2</li>
<li><strong>pos</strong> &#8211; array with position of pixels corners</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return 3-tuple of position.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.bilinear.convert_corner_2D_to_4D">
<tt class="descclassname">pyFAI.ext.bilinear.</tt><tt class="descname">convert_corner_2D_to_4D</tt><a class="headerlink" href="#pyFAI.ext.bilinear.convert_corner_2D_to_4D" title="Permalink to this definition">¶</a></dt>
<dd><p>convert_corner_2D_to_4D(signatures, args, kwargs, defaults)</p>
<p>Convert 2 (or 3) arrays of corner position into a 4D array of pixel corner coordinates</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ndim</strong> &#8211; 2d or 3D output</li>
<li><strong>d1</strong> &#8211; 2D position in dim1 (shape +1)</li>
<li><strong>d2</strong> &#8211; 2D position in dim2 (shape +1)</li>
<li><strong>d3</strong> &#8211; 2D position in dim3 (z) (shape +1)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">pos 4D array with position of pixels corners</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="ext-bispev-module">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">ext._bispev</span></tt> Module<a class="headerlink" href="#ext-bispev-module" title="Permalink to this headline">¶</a></h1>
<p>This extension is a re-implementation of bi-cubic spline evaluation from scipy</p>
<span class="target" id="module-pyFAI.ext._bispev"></span><p>Spline evaluation function</p>
<p>Created on Nov 4, 2013</p>
<p>&#64;author: zubair, Jerome Kieffer</p>
<dl class="function">
<dt id="pyFAI.ext._bispev.bisplev">
<tt class="descclassname">pyFAI.ext._bispev.</tt><tt class="descname">bisplev</tt><big>(</big><em>x</em>, <em>y</em>, <em>tck</em>, <em>dx=0</em>, <em>dy=0</em><big>)</big><a class="headerlink" href="#pyFAI.ext._bispev.bisplev" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a bivariate B-spline and its derivatives.</p>
<p>Return a rank-2 array of spline function values (or spline derivative
values) at points given by the cross-product of the rank-1 arrays x and
y.  In special cases, return an array or just a float if either x or y or
both are floats.  Based on BISPEV from FITPACK.</p>
<dl class="docutils">
<dt>x, y <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Rank-1 arrays specifying the domain over which to evaluate the
spline or its derivative.</dd>
<dt>tck <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>A sequence of length 5 returned by <cite>bisplrep</cite> containing the knot
locations, the coefficients, and the degree of the spline:
[tx, ty, c, kx, ky].</dd>
<dt>dx, dy <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The orders of the partial derivatives in <cite>x</cite> and <cite>y</cite> respectively.
This version does bot implement derivatives.</dd>
</dl>
<dl class="docutils">
<dt>vals <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The B-spline or its derivative evaluated over the set formed by
the cross-product of <cite>x</cite> and <cite>y</cite>.</dd>
</dl>
<p>splprep, splrep, splint, sproot, splev
UnivariateSpline, BivariateSpline</p>
<blockquote>
<div>See <cite>bisplrep</cite> to generate the <cite>tck</cite> representation.</div></blockquote>
<table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Dierckx P. : An algorithm for surface fitting
with spline functions
Ima J. Numer. Anal. 1 (1981) 267-283.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Dierckx P. : An algorithm for surface fitting
with spline functions
report tw50, Dept. Computer Science,K.U.Leuven, 1980.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Dierckx P. : Curve and surface fitting with splines,
Monographs on Numerical Analysis, Oxford University Press, 1993.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="ext-blob-module">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">ext._blob</span></tt> Module<a class="headerlink" href="#ext-blob-module" title="Permalink to this headline">¶</a></h1>
<p>Blob detection is used to find peaks in images by performing subsequent blurs</p>
<span class="target" id="module-pyFAI.ext._blob"></span><p>Some Cythonized function for blob detection function</p>
<dl class="function">
<dt id="pyFAI.ext._blob.local_max">
<tt class="descclassname">pyFAI.ext._blob.</tt><tt class="descname">local_max</tt><big>(</big><em>__Pyx_memviewslice dogs</em>, <em>mask=None</em>, <em>bool n_5=False</em><big>)</big><a class="headerlink" href="#pyFAI.ext._blob.local_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate if a point is a maximum in a 3D space: (scale, y, x)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dogs</strong> &#8211; 3D array of difference of gaussian</li>
<li><strong>mask</strong> &#8211; mask with invalid pixels</li>
<li><strong>N_5</strong> &#8211; take a neighborhood of 5x5 pixel in plane</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">3d_array with 1 where is_max</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="ext-container-module">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">ext.container</span></tt> Module<a class="headerlink" href="#ext-container-module" title="Permalink to this headline">¶</a></h1>
<p>Container are a new uniform storage, optimized for the creation of both LUT and CSR.
It has nothing to do with Docker.</p>
</div>
<div class="section" id="ext-convolution-module">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">ext._convolution</span></tt> Module<a class="headerlink" href="#ext-convolution-module" title="Permalink to this headline">¶</a></h1>
<p>Convolutions in real space are used to blurs images, used in blob-detection algorithm</p>
<span class="target" id="module-pyFAI.ext._convolution"></span><p>Implementation of a separable 2D convolution</p>
<dl class="function">
<dt id="pyFAI.ext._convolution.gaussian">
<tt class="descclassname">pyFAI.ext._convolution.</tt><tt class="descname">gaussian</tt><big>(</big><em>sigma</em>, <em>width=None</em><big>)</big><a class="headerlink" href="#pyFAI.ext._convolution.gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Gaussian window of length &#8220;width&#8221; with standard-deviation &#8220;sigma&#8221;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sigma</strong> &#8211; standard deviation sigma</li>
<li><strong>width</strong> &#8211; length of the windows (int) By default 8*sigma+1,</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Width should be odd.</p>
<p>The FWHM is 2*sqrt(2 * pi)*sigma</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext._convolution.gaussian_filter">
<tt class="descclassname">pyFAI.ext._convolution.</tt><tt class="descname">gaussian_filter</tt><big>(</big><em>img</em>, <em>sigma</em><big>)</big><a class="headerlink" href="#pyFAI.ext._convolution.gaussian_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a gaussian bluring using a gaussian kernel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>img</strong> &#8211; input image</li>
<li><strong>sigma</strong> &#8211; width parameter of the gaussian</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext._convolution.horizontal_convolution">
<tt class="descclassname">pyFAI.ext._convolution.</tt><tt class="descname">horizontal_convolution</tt><big>(</big><em>__Pyx_memviewslice img</em>, <em>__Pyx_memviewslice filter</em><big>)</big><a class="headerlink" href="#pyFAI.ext._convolution.horizontal_convolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements a 1D horizontal convolution with a filter.
The only implemented mode is &#8220;reflect&#8221; (default in scipy.ndimage.filter)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>img</strong> &#8211; input image</li>
<li><strong>filter</strong> &#8211; 1D array with the coefficients of the array</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">array of the same shape as image with</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext._convolution.vertical_convolution">
<tt class="descclassname">pyFAI.ext._convolution.</tt><tt class="descname">vertical_convolution</tt><big>(</big><em>__Pyx_memviewslice img</em>, <em>__Pyx_memviewslice filter</em><big>)</big><a class="headerlink" href="#pyFAI.ext._convolution.vertical_convolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements a 1D vertical convolution with a filter.
The only implemented mode is &#8220;reflect&#8221; (default in scipy.ndimage.filter)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>img</strong> &#8211; input image</li>
<li><strong>filter</strong> &#8211; 1D array with the coefficients of the array</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">array of the same shape as image with</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="ext-distortion-module">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">ext._distortion</span></tt> Module<a class="headerlink" href="#ext-distortion-module" title="Permalink to this headline">¶</a></h1>
<p>Distortion correction are correction are applied by Look-up table (or CSR)</p>
<span class="target" id="module-pyFAI.ext._distortion"></span><p>Common Look-Up table datatypes</p>
<dl class="class">
<dt id="pyFAI.ext._distortion.Distortion">
<em class="property">class </em><tt class="descclassname">pyFAI.ext._distortion.</tt><tt class="descname">Distortion</tt><big>(</big><em>self</em>, <em>detector='detector'</em>, <em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.ext._distortion.Distortion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class applies a distortion correction on an image.</p>
<p>It is also able to apply an inversion of the correction.</p>
<dl class="method">
<dt id="pyFAI.ext._distortion.Distortion.__init__">
<tt class="descname">__init__</tt><big>(</big><em>self</em>, <em>detector='detector'</em>, <em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.ext._distortion.Distortion.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>detector</strong> &#8211; detector instance or detector name</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ext._distortion.Distortion.calc_LUT">
<tt class="descname">calc_LUT</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext._distortion.Distortion.calc_LUT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext._distortion.Distortion.calc_LUT_size">
<tt class="descname">calc_LUT_size</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext._distortion.Distortion.calc_LUT_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Considering the &#8220;half-CCD&#8221; spline from ID11 which describes a (1025,2048) detector,
the physical location of pixels should go from:
[-17.48634 : 1027.0543, -22.768829 : 2028.3689]
We chose to discard pixels falling outside the [0:1025,0:2048] range with a lose of intensity</p>
<p>We keep self.pos: pos_corners will not be compatible with systems showing non adjacent pixels (like some xpads)</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ext._distortion.Distortion.calc_pos">
<tt class="descname">calc_pos</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext._distortion.Distortion.calc_pos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext._distortion.Distortion.correct">
<tt class="descname">correct</tt><big>(</big><em>self</em>, <em>image</em><big>)</big><a class="headerlink" href="#pyFAI.ext._distortion.Distortion.correct" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct an image based on the look-up table calculated ...</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image</strong> &#8211; 2D-array with the image</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">corrected 2D image</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ext._distortion.Distortion.uncorrect">
<tt class="descname">uncorrect</tt><big>(</big><em>self</em>, <em>image</em><big>)</big><a class="headerlink" href="#pyFAI.ext._distortion.Distortion.uncorrect" title="Permalink to this definition">¶</a></dt>
<dd><p>Take an image which has been corrected and transform it into it&#8217;s raw (with loss of information)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image</strong> &#8211; 2D-array with the image</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">uncorrected 2D image and a mask (pixels in raw image</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.ext._distortion.calc_CSR">
<tt class="descclassname">pyFAI.ext._distortion.</tt><tt class="descname">calc_CSR</tt><big>(</big><em>__Pyx_memviewslice pos</em>, <em>shape</em>, <em>bin_size</em>, <em>max_pixel_size</em>, <em>__Pyx_memviewslice mask=None</em><big>)</big><a class="headerlink" href="#pyFAI.ext._distortion.calc_CSR" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Look-up table as CSR format</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pos</strong> &#8211; 4D position array</li>
<li><strong>shape</strong> &#8211; output shape</li>
<li><strong>bin_size</strong> &#8211; number of input element per output element (as numpy array)</li>
<li><strong>max_pixel_size</strong> &#8211; (2-tuple of int) size of a buffer covering the largest pixel</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">look-up table in CSR format: 3-tuple of array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext._distortion.calc_LUT">
<tt class="descclassname">pyFAI.ext._distortion.</tt><tt class="descname">calc_LUT</tt><big>(</big><em>__Pyx_memviewslice pos</em>, <em>shape</em>, <em>bin_size</em>, <em>max_pixel_size</em>, <em>__Pyx_memviewslice mask=None</em><big>)</big><a class="headerlink" href="#pyFAI.ext._distortion.calc_LUT" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pos</strong> &#8211; 4D position array</li>
<li><strong>shape</strong> &#8211; output shape</li>
<li><strong>bin_size</strong> &#8211; number of input element per output element (numpy array)</li>
<li><strong>max_pixel_size</strong> &#8211; (2-tuple of int) size of a buffer covering the largest pixel</li>
<li><strong>mask</strong> &#8211; arry with bad pixels marked as True</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">look-up table</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext._distortion.calc_area">
<tt class="descclassname">pyFAI.ext._distortion.</tt><tt class="descname">calc_area</tt><big>(</big><em>float I1</em>, <em>float I2</em>, <em>float slope</em>, <em>float intercept</em><big>)</big> &rarr; float<a class="headerlink" href="#pyFAI.ext._distortion.calc_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the area between I1 and I2 of a line with a given slope &amp; intercept</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext._distortion.calc_openmp">
<tt class="descclassname">pyFAI.ext._distortion.</tt><tt class="descname">calc_openmp</tt><big>(</big><em>__Pyx_memviewslice pos</em>, <em>shape</em>, <em>max_pixel_size=(8</em>, <em>8)</em>, <em>__Pyx_memviewslice mask=None</em>, <em>format='csr'</em>, <em>int bins_per_pixel=8</em><big>)</big><a class="headerlink" href="#pyFAI.ext._distortion.calc_openmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the look-up table (or CSR) using OpenMP</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pos</strong> &#8211; 4D position array</li>
<li><strong>shape</strong> &#8211; output shape</li>
<li><strong>max_pixel_size</strong> &#8211; (2-tuple of int) size of a buffer covering the largest pixel</li>
<li><strong>format</strong> &#8211; can be &#8220;CSR&#8221; or &#8220;LUT&#8221;</li>
<li><strong>bins_per_pixel</strong> &#8211; average splitting factor (number of pixels per bin)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">look-up table in CSR/LUT format</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext._distortion.calc_pos">
<tt class="descclassname">pyFAI.ext._distortion.</tt><tt class="descname">calc_pos</tt><a class="headerlink" href="#pyFAI.ext._distortion.calc_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>calc_pos(signatures, args, kwargs, defaults)
Calculate the pixel boundary position on the regular grid</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param pixel_corners:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">pixel corner coordinate as detector.get_pixel_corner()</td>
</tr>
<tr class="field-even field"><th class="field-name">param shape:</th><td class="field-body">requested output shape. If None, it is calculated</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param pixel1, pixel2:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">pixel size along row and column coordinates</td>
</tr>
<tr class="field-even field"><th class="field-name">return:</th><td class="field-body">pos, delta1, delta2, shape_out, offset</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext._distortion.calc_size">
<tt class="descclassname">pyFAI.ext._distortion.</tt><tt class="descname">calc_size</tt><a class="headerlink" href="#pyFAI.ext._distortion.calc_size" title="Permalink to this definition">¶</a></dt>
<dd><p>calc_size(signatures, args, kwargs, defaults)
Calculate the number of items per output pixel</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param pos:</th><td class="field-body">4D array with position in space</td>
</tr>
<tr class="field-even field"><th class="field-name">param shape:</th><td class="field-body">shape of the output array</td>
</tr>
<tr class="field-odd field"><th class="field-name">param mask:</th><td class="field-body">input data mask</td>
</tr>
<tr class="field-even field"><th class="field-name">param offset:</th><td class="field-body">2-tuple of float with the minimal index of</td>
</tr>
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body">number of input element per output elements</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext._distortion.clip">
<tt class="descclassname">pyFAI.ext._distortion.</tt><tt class="descname">clip</tt><big>(</big><em>int value</em>, <em>int min_val</em>, <em>int max_val</em><big>)</big> &rarr; int<a class="headerlink" href="#pyFAI.ext._distortion.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Limits the value to bounds</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext._distortion.correct_CSR">
<tt class="descclassname">pyFAI.ext._distortion.</tt><tt class="descname">correct_CSR</tt><big>(</big><em>image</em>, <em>shape_in</em>, <em>shape_out</em>, <em>LUT</em>, <em>dummy=None</em>, <em>delta_dummy=None</em><big>)</big><a class="headerlink" href="#pyFAI.ext._distortion.correct_CSR" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct an image based on the look-up table calculated ...</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>image</strong> &#8211; 2D-array with the image</li>
<li><strong>shape_in</strong> &#8211; shape of input image</li>
<li><strong>shape_out</strong> &#8211; shape of output image</li>
<li><strong>LUT</strong> &#8211; Look up table, here a 3-tuple array of ndarray</li>
<li><strong>dummy</strong> &#8211; value for invalid pixels</li>
<li><strong>delta_dummy</strong> &#8211; precision for invalid pixels</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">corrected 2D image</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext._distortion.correct_LUT">
<tt class="descclassname">pyFAI.ext._distortion.</tt><tt class="descname">correct_LUT</tt><big>(</big><em>image</em>, <em>shape_in</em>, <em>shape_out</em>, <em>__Pyx_memviewslice LUT</em>, <em>dummy=None</em>, <em>delta_dummy=None</em><big>)</big><a class="headerlink" href="#pyFAI.ext._distortion.correct_LUT" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct an image based on the look-up table calculated ...</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>image</strong> &#8211; 2D-array with the image</li>
<li><strong>shape_in</strong> &#8211; shape of input image</li>
<li><strong>shape_out</strong> &#8211; shape of output image</li>
<li><strong>LUT</strong> &#8211; Look up table, here a 2D-array of struct</li>
<li><strong>dummy</strong> &#8211; value for invalid pixels</li>
<li><strong>delta_dummy</strong> &#8211; precision for invalid pixels</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">corrected 2D image</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext._distortion.uncorrect_CSR">
<tt class="descclassname">pyFAI.ext._distortion.</tt><tt class="descname">uncorrect_CSR</tt><big>(</big><em>image</em>, <em>shape</em>, <em>LUT</em><big>)</big><a class="headerlink" href="#pyFAI.ext._distortion.uncorrect_CSR" title="Permalink to this definition">¶</a></dt>
<dd><p>Take an image which has been corrected and transform it into it&#8217;s raw (with loss of information)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>image</strong> &#8211; 2D-array with the image</li>
<li><strong>shape</strong> &#8211; shape of output image</li>
<li><strong>LUT</strong> &#8211; Look up table, here a 3-tuple of ndarray</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">uncorrected 2D image and a mask (pixels in raw image not existing)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext._distortion.uncorrect_LUT">
<tt class="descclassname">pyFAI.ext._distortion.</tt><tt class="descname">uncorrect_LUT</tt><big>(</big><em>image</em>, <em>shape</em>, <em>__Pyx_memviewslice LUT</em><big>)</big><a class="headerlink" href="#pyFAI.ext._distortion.uncorrect_LUT" title="Permalink to this definition">¶</a></dt>
<dd><p>Take an image which has been corrected and transform it into it&#8217;s raw (with loss of information)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>image</strong> &#8211; 2D-array with the image</li>
<li><strong>shape</strong> &#8211; shape of output image</li>
<li><strong>LUT</strong> &#8211; Look up table, here a 2D-array of struct</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">uncorrected 2D image and a mask (pixels in raw image not existing)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="ext-geometry-module">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">ext._geometry</span></tt> Module<a class="headerlink" href="#ext-geometry-module" title="Permalink to this headline">¶</a></h1>
<p>This extension is a fast-implementation for calculating the geometry, i.e. where
every pixel of an array stays in space (x,y,z) or its (r, chi) coordinates.</p>
<span class="target" id="module-pyFAI.ext._geometry"></span><dl class="function">
<dt id="pyFAI.ext._geometry.calc_chi">
<tt class="descclassname">pyFAI.ext._geometry.</tt><tt class="descname">calc_chi</tt><big>(</big><em>double L</em>, <em>double rot1</em>, <em>double rot2</em>, <em>double rot3</em>, <em>ndarray pos1</em>, <em>ndarray pos2</em>, <em>ndarray pos3=None</em><big>)</big><a class="headerlink" href="#pyFAI.ext._geometry.calc_chi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the chi array (azimuthal angles) using OpenMP</p>
<p>X1 = p1*cos(rot2)*cos(rot3) + p2*(cos(rot3)*sin(rot1)*sin(rot2) - cos(rot1)*sin(rot3)) -  L*(cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3))
X2 = p1*cos(rot2)*sin(rot3) - L*(-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3)) +  p2*(cos(rot1)*cos(rot3) + sin(rot1)*sin(rot2)*sin(rot3))
X3 = -(L*cos(rot1)*cos(rot2)) + p2*cos(rot2)*sin(rot1) - p1*sin(rot2)
tan(Chi) =  X2 / X1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>L</strong> &#8211; distance sample - PONI</li>
<li><strong>rot1</strong> &#8211; angle1</li>
<li><strong>rot2</strong> &#8211; angle2</li>
<li><strong>rot3</strong> &#8211; angle3</li>
<li><strong>pos1</strong> &#8211; numpy array with distances in meter along dim1 from PONI (Y)</li>
<li><strong>pos2</strong> &#8211; numpy array with distances in meter along dim2 from PONI (X)</li>
<li><strong>pos3</strong> &#8211; numpy array with distances in meter along Sample-&gt;PONI (Z), positive behind the detector</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">ndarray of double with same shape and size as pos1</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext._geometry.calc_cosa">
<tt class="descclassname">pyFAI.ext._geometry.</tt><tt class="descname">calc_cosa</tt><big>(</big><em>double L</em>, <em>ndarray pos1</em>, <em>ndarray pos2</em>, <em>ndarray pos3=None</em><big>)</big><a class="headerlink" href="#pyFAI.ext._geometry.calc_cosa" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the cosine of the incidence angle using OpenMP. 
Used for sensors thickness effect corrections</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>L</strong> &#8211; distance sample - PONI</li>
<li><strong>pos1</strong> &#8211; numpy array with distances in meter along dim1 from PONI (Y)</li>
<li><strong>pos2</strong> &#8211; numpy array with distances in meter along dim2 from PONI (X)</li>
<li><strong>pos3</strong> &#8211; numpy array with distances in meter along Sample-&gt;PONI (Z), positive behind the detector</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">ndarray of double with same shape and size as pos1</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext._geometry.calc_pos_zyx">
<tt class="descclassname">pyFAI.ext._geometry.</tt><tt class="descname">calc_pos_zyx</tt><big>(</big><em>double L</em>, <em>double poni1</em>, <em>double poni2</em>, <em>double rot1</em>, <em>double rot2</em>, <em>double rot3</em>, <em>ndarray pos1</em>, <em>ndarray pos2</em>, <em>ndarray pos3=None</em><big>)</big><a class="headerlink" href="#pyFAI.ext._geometry.calc_pos_zyx" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the 3D coordinates in the sample&#8217;s referential</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>L</strong> &#8211; distance sample - PONI</li>
<li><strong>poni1</strong> &#8211; PONI coordinate along y axis</li>
<li><strong>poni2</strong> &#8211; PONI coordinate along x axis</li>
<li><strong>rot1</strong> &#8211; angle1</li>
<li><strong>rot2</strong> &#8211; angle2</li>
<li><strong>rot3</strong> &#8211; angle3</li>
<li><strong>pos1</strong> &#8211; numpy array with distances in meter along dim1 from PONI (Y)</li>
<li><strong>pos2</strong> &#8211; numpy array with distances in meter along dim2 from PONI (X)</li>
<li><strong>pos3</strong> &#8211; numpy array with distances in meter along Sample-&gt;PONI (Z), positive behind the detector</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">3-tuple of ndarray of double with same shape and size as pos1</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext._geometry.calc_q">
<tt class="descclassname">pyFAI.ext._geometry.</tt><tt class="descname">calc_q</tt><big>(</big><em>double L</em>, <em>double rot1</em>, <em>double rot2</em>, <em>double rot3</em>, <em>ndarray pos1</em>, <em>ndarray pos2</em>, <em>double wavelength</em>, <em>pos3=None</em><big>)</big><a class="headerlink" href="#pyFAI.ext._geometry.calc_q" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the q (scattering vector) array using OpenMP</p>
<p>X1 = p1*cos(rot2)*cos(rot3) + p2*(cos(rot3)*sin(rot1)*sin(rot2) - cos(rot1)*sin(rot3)) -  L*(cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3))
X2 = p1*cos(rot2)*sin(rot3) - L*(-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3)) +  p2*(cos(rot1)*cos(rot3) + sin(rot1)*sin(rot2)*sin(rot3))
X3 = -(L*cos(rot1)*cos(rot2)) + p2*cos(rot2)*sin(rot1) - p1*sin(rot2)
tan(Chi) =  X2 / X1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>L</strong> &#8211; distance sample - PONI</li>
<li><strong>rot1</strong> &#8211; angle1</li>
<li><strong>rot2</strong> &#8211; angle2</li>
<li><strong>rot3</strong> &#8211; angle3</li>
<li><strong>pos1</strong> &#8211; numpy array with distances in meter along dim1 from PONI (Y)</li>
<li><strong>pos2</strong> &#8211; numpy array with distances in meter along dim2 from PONI (X)</li>
<li><strong>pos3</strong> &#8211; numpy array with distances in meter along Sample-&gt;PONI (Z), positive behind the detector</li>
<li><strong>wavelength</strong> &#8211; in meter to get q in nm-1</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">ndarray of double with same shape and size as pos1</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext._geometry.calc_r">
<tt class="descclassname">pyFAI.ext._geometry.</tt><tt class="descname">calc_r</tt><big>(</big><em>double L</em>, <em>double rot1</em>, <em>double rot2</em>, <em>double rot3</em>, <em>ndarray pos1</em>, <em>ndarray pos2</em>, <em>ndarray pos3=None</em><big>)</big><a class="headerlink" href="#pyFAI.ext._geometry.calc_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the radius array (radial direction) in parallel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>L</strong> &#8211; distance sample - PONI</li>
<li><strong>rot1</strong> &#8211; angle1</li>
<li><strong>rot2</strong> &#8211; angle2</li>
<li><strong>rot3</strong> &#8211; angle3</li>
<li><strong>pos1</strong> &#8211; numpy array with distances in meter along dim1 from PONI (Y)</li>
<li><strong>pos2</strong> &#8211; numpy array with distances in meter along dim2 from PONI (X)</li>
<li><strong>pos3</strong> &#8211; numpy array with distances in meter along Sample-&gt;PONI (Z), positive behind the detector</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">ndarray of double with same shape and size as pos1</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext._geometry.calc_rad_azim">
<tt class="descclassname">pyFAI.ext._geometry.</tt><tt class="descname">calc_rad_azim</tt><big>(</big><em>double L</em>, <em>double poni1</em>, <em>double poni2</em>, <em>double rot1</em>, <em>double rot2</em>, <em>double rot3</em>, <em>ndarray pos1</em>, <em>ndarray pos2</em>, <em>ndarray pos3=None</em>, <em>space='2th'</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.ext._geometry.calc_rad_azim" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the radial &amp; azimutal position for each pixel from pos1, pos2, pos3.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>L</strong> &#8211; distance sample - PONI</li>
<li><strong>poni1</strong> &#8211; PONI coordinate along y axis</li>
<li><strong>poni2</strong> &#8211; PONI coordinate along x axis</li>
<li><strong>rot1</strong> &#8211; angle1</li>
<li><strong>rot2</strong> &#8211; angle2</li>
<li><strong>rot3</strong> &#8211; angle3</li>
<li><strong>pos1</strong> &#8211; numpy array with distances in meter along dim1 from PONI (Y)</li>
<li><strong>pos2</strong> &#8211; numpy array with distances in meter along dim2 from PONI (X)</li>
<li><strong>pos3</strong> &#8211; numpy array with distances in meter along Sample-&gt;PONI (Z), positive behind the detector</li>
<li><strong>space</strong> &#8211; can be &#8220;2th&#8221;, &#8220;q&#8221; or &#8220;r&#8221; for radial units. Azimuthal units are radians</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">ndarray of double with same shape and size as pos1 + (2,),</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raise:</th><td class="field-body"><p class="first last">KeyError when space is bad !
ValueError when wavelength is missing</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext._geometry.calc_tth">
<tt class="descclassname">pyFAI.ext._geometry.</tt><tt class="descname">calc_tth</tt><big>(</big><em>double L</em>, <em>double rot1</em>, <em>double rot2</em>, <em>double rot3</em>, <em>ndarray pos1</em>, <em>ndarray pos2</em>, <em>ndarray pos3=None</em><big>)</big><a class="headerlink" href="#pyFAI.ext._geometry.calc_tth" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the 2theta array (radial angle) in parallel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>L</strong> &#8211; distance sample - PONI</li>
<li><strong>rot1</strong> &#8211; angle1</li>
<li><strong>rot2</strong> &#8211; angle2</li>
<li><strong>rot3</strong> &#8211; angle3</li>
<li><strong>pos1</strong> &#8211; numpy array with distances in meter along dim1 from PONI (Y)</li>
<li><strong>pos2</strong> &#8211; numpy array with distances in meter along dim2 from PONI (X)</li>
<li><strong>pos3</strong> &#8211; numpy array with distances in meter along Sample-&gt;PONI (Z), positive behind the detector</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">ndarray of double with same shape and size as pos1</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="ext-histogram-module">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">ext.histogram</span></tt> Module<a class="headerlink" href="#ext-histogram-module" title="Permalink to this headline">¶</a></h1>
<p>Re-implementation of the numpy.histogram, optimized for azimuthal integration.
Deprecated, will be replaced by silx.math.histogramnd</p>
<span class="target" id="module-pyFAI.ext.histogram"></span><p>Re-implementation of numpy histograms using OpenMP</p>
<dl class="function">
<dt id="pyFAI.ext.histogram.histogram">
<tt class="descclassname">pyFAI.ext.histogram.</tt><tt class="descname">histogram</tt><big>(</big><em>ndarray pos</em>, <em>ndarray weights</em>, <em>int bins=100</em>, <em>bin_range=None</em>, <em>pixelSize_in_Pos=None</em>, <em>nthread=None</em>, <em>double empty=0.0</em>, <em>double normalization_factor=1.0</em><big>)</big><a class="headerlink" href="#pyFAI.ext.histogram.histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates histogram of pos weighted by weights</p>
<p>&#64;param pos: 2Theta array
&#64;param weights: array with intensities
&#64;param bins: number of output bins
&#64;param pixelSize_in_Pos: size of a pixels in 2theta: DESACTIVATED
&#64;param nthread: OpenMP is disabled. unused
&#64;param empty: value given to empty bins
&#64;param normalization_factor: divide the result by this value</p>
<p>&#64;return 2theta, I, weighted histogram, raw histogram</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext.histogram.histogram2d">
<tt class="descclassname">pyFAI.ext.histogram.</tt><tt class="descname">histogram2d</tt><big>(</big><em>ndarray pos0</em>, <em>ndarray pos1</em>, <em>bins</em>, <em>ndarray weights</em>, <em>split=False</em>, <em>nthread=None</em>, <em>double empty=0.0</em>, <em>double normalization_factor=1.0</em><big>)</big><a class="headerlink" href="#pyFAI.ext.histogram.histogram2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate 2D histogram of pos0,pos1 weighted by weights</p>
<p>&#64;param pos0: 2Theta array
&#64;param pos1: Chi array
&#64;param weights: array with intensities
&#64;param bins: number of output bins int or 2-tuple of int
&#64;param split: pixel splitting is disabled in histogram
&#64;param nthread: maximum number of thread to use. By default: maximum available.
&#64;param empty: value given to empty bins
&#64;param normalization_factor: divide the result by this value</p>
<p>&#64;return  I, edges0, edges1, weighted histogram(2D), unweighted histogram (2D)</p>
<p>One can also limit this with OMP_NUM_THREADS environment variable</p>
</dd></dl>

</div>
<div class="section" id="ext-marchingsquares-module">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">ext.marchingsquares</span></tt> Module<a class="headerlink" href="#ext-marchingsquares-module" title="Permalink to this headline">¶</a></h1>
<p>The marchingsquares algorithm is used for calculating an iso-contour curve (displayed
on the screen while calibrating) but also to seed the points for the &#8220;massif&#8221; algoritm
during recalib.</p>
<span class="target" id="module-pyFAI.ext.marchingsquares"></span><p>Cythonized version of the marching square function for &#8220;isocontour&#8221; plot</p>
<dl class="function">
<dt id="pyFAI.ext.marchingsquares.isocontour">
<tt class="descclassname">pyFAI.ext.marchingsquares.</tt><tt class="descname">isocontour</tt><big>(</big><em>img</em>, <em>isovalue=None</em>, <em>sorted=False</em><big>)</big><a class="headerlink" href="#pyFAI.ext.marchingsquares.isocontour" title="Permalink to this definition">¶</a></dt>
<dd><p>isocontour(img, isovalue=None)</p>
<p>Calculate the iso contours for the given 2D image. If isovalue
is not given or None, a value between the min and max of the image
is used.</p>
<p>&#64;param img: 2D array representing the image
&#64;param isovalue: the value for which the iso_contour shall be calculated
&#64;param sorted: perform a sorting of the points to have them contiguous ?</p>
<p>Returns a pointset in which each two subsequent points form a line
piece. This van be best visualized using &#8220;vv.plot(result, ls=&#8217;+&#8217;)&#8221;.</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext.marchingsquares.marching_squares">
<tt class="descclassname">pyFAI.ext.marchingsquares.</tt><tt class="descname">marching_squares</tt><big>(</big><em>__Pyx_memviewslice img</em>, <em>double isovalue</em>, <em>__Pyx_memviewslice cellToEdge</em>, <em>__Pyx_memviewslice edgeToRelativePosX</em>, <em>__Pyx_memviewslice edgeToRelativePosY</em><big>)</big><a class="headerlink" href="#pyFAI.ext.marchingsquares.marching_squares" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyFAI.ext.marchingsquares.sort_edges">
<tt class="descclassname">pyFAI.ext.marchingsquares.</tt><tt class="descname">sort_edges</tt><big>(</big><em>edges</em><big>)</big><a class="headerlink" href="#pyFAI.ext.marchingsquares.sort_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorder edges in such a way they become contiguous</p>
</dd></dl>

</div>
<div class="section" id="ext-morphology-module">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">ext.morphology</span></tt> Module<a class="headerlink" href="#ext-morphology-module" title="Permalink to this headline">¶</a></h1>
<p>The morphology extension provides a couple of binary morphology operations on images.
They are also implemented in scipy.ndimage in the general case, but not as fast.</p>
<span class="target" id="module-pyFAI.ext.morphology"></span><p>A few binary morphology operation</p>
<dl class="function">
<dt id="pyFAI.ext.morphology.binary_dilation">
<tt class="descclassname">pyFAI.ext.morphology.</tt><tt class="descname">binary_dilation</tt><big>(</big><em>__Pyx_memviewslice image</em>, <em>float radius=1.0</em><big>)</big><a class="headerlink" href="#pyFAI.ext.morphology.binary_dilation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fast binary morphological dilation of an image.</p>
<p>Morphological dilation sets a pixel at (i,j) to the maximum over all pixels in the neighborhood centered at (i,j).
Dilation enlarges bright regions and shrinks dark regions.</p>
<p>:param image : ndarray
:param radius: float
:return: ndiamge</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.ext.morphology.binary_erosion">
<tt class="descclassname">pyFAI.ext.morphology.</tt><tt class="descname">binary_erosion</tt><big>(</big><em>__Pyx_memviewslice image</em>, <em>float radius=1.0</em><big>)</big><a class="headerlink" href="#pyFAI.ext.morphology.binary_erosion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fast binary morphological erosion of an image.</p>
<p>Morphological erosion sets a pixel at (i,j) to the minimum over all pixels 
in the neighborhood centered at (i,j).
Erosion shrinks bright regions and enlarges dark regions.</p>
<p>:param image : ndarray
:param radius: float
:return: ndiamge</p>
</dd></dl>

</div>
<div class="section" id="ext-reconstruct-module">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">ext.reconstruct</span></tt> Module<a class="headerlink" href="#ext-reconstruct-module" title="Permalink to this headline">¶</a></h1>
<p>Very simple inpainting module for reconstructing the missing part of an image (masked)
to be able to use more common algorithms.</p>
<span class="target" id="module-pyFAI.ext.reconstruct"></span><p>Cython module to reconstruct the masked values of an image</p>
<dl class="function">
<dt id="pyFAI.ext.reconstruct.reconstruct">
<tt class="descclassname">pyFAI.ext.reconstruct.</tt><tt class="descname">reconstruct</tt><big>(</big><em>ndarray data</em>, <em>ndarray mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em><big>)</big><a class="headerlink" href="#pyFAI.ext.reconstruct.reconstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>reconstruct missing part of an image (tries to be continuous)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> &#8211; the input image</li>
<li><strong>mask</strong> &#8211; where data should be reconstructed.</li>
<li><strong>dummy</strong> &#8211; value of the dummy (masked out) data</li>
<li><strong>delta_dummy</strong> &#8211; precision for dummy values</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">reconstructed image.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="ext-relabel-module">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">ext.relabel</span></tt> Module<a class="headerlink" href="#ext-relabel-module" title="Permalink to this headline">¶</a></h1>
<p>Relabel regions, used to flag from largest regions to the smallest</p>
<span class="target" id="module-pyFAI.ext.relabel"></span><p>A module to relabel regions</p>
<dl class="function">
<dt id="pyFAI.ext.relabel.countThem">
<tt class="descclassname">pyFAI.ext.relabel.</tt><tt class="descname">countThem</tt><big>(</big><em>ndarray label</em>, <em>ndarray data</em>, <em>ndarray blured</em><big>)</big><a class="headerlink" href="#pyFAI.ext.relabel.countThem" title="Permalink to this definition">¶</a></dt>
<dd><p>Count 
:param label: 2D array containing labeled zones
:param data: 2D array containing the raw data
:param blured: 2D array containing the blured data
:return: 2D arrays containing:</p>
<blockquote>
<div><ul class="simple">
<li>count pixels in labelled zone: label == index).sum()</li>
<li>max of data in that zone:      data[label == index].max()</li>
<li>max of blured in that zone:    blured[label == index].max()</li>
<li>data-blured where data is max.</li>
</ul>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="ext-preproc-module">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">ext.preproc</span></tt> Module<a class="headerlink" href="#ext-preproc-module" title="Permalink to this headline">¶</a></h1>
<p>Contains a preprocessing function in charge of the dark-current subtraction,
flat-field normalization, ... taking care of masked values and normalization.</p>
<span class="target" id="module-pyFAI.ext.preproc"></span><dl class="function">
<dt id="pyFAI.ext.preproc.preproc">
<tt class="descclassname">pyFAI.ext.preproc.</tt><tt class="descname">preproc</tt><big>(</big><em>data</em>, <em>dark=None</em>, <em>flat=None</em>, <em>solidangle=None</em>, <em>polarization=None</em>, <em>absorption=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>float normalization_factor=1.0</em>, <em>empty=None</em><big>)</big><a class="headerlink" href="#pyFAI.ext.preproc.preproc" title="Permalink to this definition">¶</a></dt>
<dd><p>Common preprocessing step for all</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; raw value, as a numpy array, 1D or 2D</li>
<li><strong>mask</strong> &#8211; array non null  where data should be ignored</li>
<li><strong>dummy</strong> &#8211; value of invalid data</li>
<li><strong>delta_dummy</strong> &#8211; precision for invalid data</li>
<li><strong>dark</strong> &#8211; array containing the value of the dark noise, to be subtracted</li>
<li><strong>flat</strong> &#8211; Array containing the flatfield image. It is also checked for dummies if relevant.</li>
<li><strong>solidangle</strong> &#8211; the value of the solid_angle. This processing may be performed during the rebinning instead. left for compatibility</li>
<li><strong>polarization</strong> &#8211; Correction for polarization of the incident beam</li>
<li><strong>absorption</strong> &#8211; Correction for absorption in the sensor volume</li>
<li><strong>normalization_factor</strong> &#8211; final value is divided by this</li>
<li><strong>empty</strong> &#8211; value to be given for empty bins</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>All calculation are performed in single precision floating point.</p>
<p>NaN are always considered as invalid</p>
<p>if neither empty nor dummy is provided, empty pixels are 0</p>
</dd></dl>

</div>
<div class="section" id="ext-tree-module">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">ext._tree</span></tt> Module<a class="headerlink" href="#ext-tree-module" title="Permalink to this headline">¶</a></h1>
<p>The tree is used in file hierarchy tree for the diff_map graphical user interface.</p>
<span class="target" id="module-pyFAI.ext._tree"></span><dl class="class">
<dt id="pyFAI.ext._tree.TreeItem">
<em class="property">class </em><tt class="descclassname">pyFAI.ext._tree.</tt><tt class="descname">TreeItem</tt><a class="headerlink" href="#pyFAI.ext._tree.TreeItem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>TreeItem(str label=None, TreeItem parent=None)</p>
<p>Node of a tree ...</p>
<p>Each node contains:</p>
<blockquote>
<div><ul class="simple">
<li>children: list</li>
<li>parent: TreeItem parent</li>
<li>label: str</li>
<li>order: int</li>
<li>type: str can be &#8220;dir&#8221;, &#8220;file&#8221;, &#8220;group&#8221; or &#8220;dataset&#8221;</li>
<li>extra: any object</li>
</ul>
</div></blockquote>
<dl class="attribute">
<dt id="pyFAI.ext._tree.TreeItem.__init__">
<tt class="descname">__init__</tt><a class="headerlink" href="#pyFAI.ext._tree.TreeItem.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ext._tree.TreeItem.add_child">
<tt class="descname">add_child</tt><big>(</big><em>self</em>, <em>TreeItem child</em><big>)</big><a class="headerlink" href="#pyFAI.ext._tree.TreeItem.add_child" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext._tree.TreeItem.children">
<tt class="descname">children</tt><a class="headerlink" href="#pyFAI.ext._tree.TreeItem.children" title="Permalink to this definition">¶</a></dt>
<dd><p>children: list</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext._tree.TreeItem.extra">
<tt class="descname">extra</tt><a class="headerlink" href="#pyFAI.ext._tree.TreeItem.extra" title="Permalink to this definition">¶</a></dt>
<dd><p>extra: object</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ext._tree.TreeItem.first">
<tt class="descname">first</tt><big>(</big><em>self</em><big>)</big> &rarr; TreeItem<a class="headerlink" href="#pyFAI.ext._tree.TreeItem.first" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext._tree.TreeItem.get">
<tt class="descname">get</tt><big>(</big><em>self</em>, <em>str label</em><big>)</big> &rarr; TreeItem<a class="headerlink" href="#pyFAI.ext._tree.TreeItem.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext._tree.TreeItem.has_child">
<tt class="descname">has_child</tt><big>(</big><em>self</em>, <em>str label</em><big>)</big> &rarr; bool<a class="headerlink" href="#pyFAI.ext._tree.TreeItem.has_child" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext._tree.TreeItem.label">
<tt class="descname">label</tt><a class="headerlink" href="#pyFAI.ext._tree.TreeItem.label" title="Permalink to this definition">¶</a></dt>
<dd><p>label: str</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ext._tree.TreeItem.last">
<tt class="descname">last</tt><big>(</big><em>self</em><big>)</big> &rarr; TreeItem<a class="headerlink" href="#pyFAI.ext._tree.TreeItem.last" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext._tree.TreeItem.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyFAI.ext._tree.TreeItem.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext._tree.TreeItem.next">
<tt class="descname">next</tt><big>(</big><em>self</em><big>)</big> &rarr; TreeItem<a class="headerlink" href="#pyFAI.ext._tree.TreeItem.next" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext._tree.TreeItem.order">
<tt class="descname">order</tt><a class="headerlink" href="#pyFAI.ext._tree.TreeItem.order" title="Permalink to this definition">¶</a></dt>
<dd><p>order: &#8216;int&#8217;</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext._tree.TreeItem.parent">
<tt class="descname">parent</tt><a class="headerlink" href="#pyFAI.ext._tree.TreeItem.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>parent: pyFAI.ext._tree.TreeItem</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ext._tree.TreeItem.previous">
<tt class="descname">previous</tt><big>(</big><em>self</em><big>)</big> &rarr; TreeItem<a class="headerlink" href="#pyFAI.ext._tree.TreeItem.previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext._tree.TreeItem.size">
<tt class="descname">size</tt><a class="headerlink" href="#pyFAI.ext._tree.TreeItem.size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext._tree.TreeItem.sort">
<tt class="descname">sort</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext._tree.TreeItem.sort" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext._tree.TreeItem.type">
<tt class="descname">type</tt><a class="headerlink" href="#pyFAI.ext._tree.TreeItem.type" title="Permalink to this definition">¶</a></dt>
<dd><p>type: str</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ext._tree.TreeItem.update">
<tt class="descname">update</tt><big>(</big><em>self</em>, <em>TreeItem new_root</em><big>)</big><a class="headerlink" href="#pyFAI.ext._tree.TreeItem.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Add new children in tree</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="ext-watershed-module">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">ext.watershed</span></tt> Module<a class="headerlink" href="#ext-watershed-module" title="Permalink to this headline">¶</a></h1>
<p>Peak peaking via inverse watershed for connecting region of high intensity</p>
<span class="target" id="module-pyFAI.ext.watershed"></span><p>Inverse watershed for connecting region of high intensity</p>
<dl class="class">
<dt id="pyFAI.ext.watershed.Bilinear">
<em class="property">class </em><tt class="descclassname">pyFAI.ext.watershed.</tt><tt class="descname">Bilinear</tt><a class="headerlink" href="#pyFAI.ext.watershed.Bilinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Bilinear interpolator for finding max.</p>
<p>Instance attribute defined in pxd file</p>
<dl class="method">
<dt id="pyFAI.ext.watershed.Bilinear.cp_local_maxi">
<tt class="descname">cp_local_maxi</tt><big>(</big><em>self</em>, <em>size_t x</em><big>)</big> &rarr; size_t<a class="headerlink" href="#pyFAI.ext.watershed.Bilinear.cp_local_maxi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.watershed.Bilinear.data">
<tt class="descname">data</tt><a class="headerlink" href="#pyFAI.ext.watershed.Bilinear.data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.Bilinear.f_cy">
<tt class="descname">f_cy</tt><big>(</big><em>self</em>, <em>x</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.Bilinear.f_cy" title="Permalink to this definition">¶</a></dt>
<dd><p>Function f((y,x)) where f is a continuous function (y,x) are pixel coordinates
&#64;param x: 2-tuple of float
&#64;return: Interpolated signal from the image (negative for minimizer)</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.watershed.Bilinear.height">
<tt class="descname">height</tt><a class="headerlink" href="#pyFAI.ext.watershed.Bilinear.height" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.Bilinear.local_maxi">
<tt class="descname">local_maxi</tt><big>(</big><em>self</em>, <em>x</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.Bilinear.local_maxi" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the local maximum ... with sub-pixel refinement</p>
<p>&#64;param x: 2-tuple of integers
&#64;param w: half with of the window: 1 or 2 are advised
&#64;return: 2-tuple of float with the nearest local maximum</p>
<p>Sub-pixel refinement:
Second order Taylor expansion of the function; first derivative is null
delta = x-i = -Inverse[Hessian].gradient</p>
<p>if Hessian is singular or <a href="#id6"><span class="problematic" id="id7">|delta|</span></a>&gt;1: use a center of mass.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.watershed.Bilinear.maxi">
<tt class="descname">maxi</tt><a class="headerlink" href="#pyFAI.ext.watershed.Bilinear.maxi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.watershed.Bilinear.mini">
<tt class="descname">mini</tt><a class="headerlink" href="#pyFAI.ext.watershed.Bilinear.mini" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.watershed.Bilinear.width">
<tt class="descname">width</tt><a class="headerlink" href="#pyFAI.ext.watershed.Bilinear.width" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.ext.watershed.InverseWatershed">
<em class="property">class </em><tt class="descclassname">pyFAI.ext.watershed.</tt><tt class="descname">InverseWatershed</tt><big>(</big><em>self</em>, <em>data</em>, <em>thres=1.0</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.InverseWatershed" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Idea:</p>
<ul class="simple">
<li>label all peaks</li>
<li>define region around those peaks which raise always to this peak</li>
<li>define the border of such region</li>
<li>search for the pass between two peaks</li>
<li>merge region with high pass between them</li>
</ul>
<dl class="attribute">
<dt id="pyFAI.ext.watershed.InverseWatershed.NAME">
<tt class="descname">NAME</tt><em class="property"> = 'Inverse watershed'</em><a class="headerlink" href="#pyFAI.ext.watershed.InverseWatershed.NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.watershed.InverseWatershed.VERSION">
<tt class="descname">VERSION</tt><em class="property"> = '1.0'</em><a class="headerlink" href="#pyFAI.ext.watershed.InverseWatershed.VERSION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.InverseWatershed.__init__">
<tt class="descname">__init__</tt><big>(</big><em>self</em>, <em>data</em>, <em>thres=1.0</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.InverseWatershed.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> &#8211; 2d image as numpy array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.InverseWatershed.init">
<tt class="descname">init</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.InverseWatershed.init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.InverseWatershed.init_borders">
<tt class="descname">init_borders</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.InverseWatershed.init_borders" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.InverseWatershed.init_labels">
<tt class="descname">init_labels</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.InverseWatershed.init_labels" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.InverseWatershed.init_pass">
<tt class="descname">init_pass</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.InverseWatershed.init_pass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.InverseWatershed.init_regions">
<tt class="descname">init_regions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.InverseWatershed.init_regions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pyFAI.ext.watershed.InverseWatershed.load">
<em class="property">classmethod </em><tt class="descname">load</tt><big>(</big><em>cls</em>, <em>fname</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.InverseWatershed.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load data from a HDF5 file</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.InverseWatershed.merge_intense">
<tt class="descname">merge_intense</tt><big>(</big><em>self</em>, <em>thres=1.0</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.InverseWatershed.merge_intense" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge groups then (pass-mini)/(maxi-mini) &gt;=thres</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.InverseWatershed.merge_singleton">
<tt class="descname">merge_singleton</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.InverseWatershed.merge_singleton" title="Permalink to this definition">¶</a></dt>
<dd><p>merge single pixel region</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.InverseWatershed.merge_twins">
<tt class="descname">merge_twins</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.InverseWatershed.merge_twins" title="Permalink to this definition">¶</a></dt>
<dd><p>Twins are two peak region which are best linked together:
A -&gt; B and B -&gt; A</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.InverseWatershed.peaks_from_area">
<tt class="descname">peaks_from_area</tt><big>(</big><em>self</em>, <em>mask</em>, <em>Imin=None</em>, <em>keep=None</em>, <em>bool refine=True</em>, <em>float dmin=0.0</em>, <em>**kwarg</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.InverseWatershed.peaks_from_area" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mask</strong> &#8211; mask of data points valid</li>
<li><strong>Imin</strong> &#8211; Minimum intensity for a peak</li>
<li><strong>keep</strong> &#8211; Number of  points to keep</li>
<li><strong>refine</strong> &#8211; refine sub-pixel position</li>
<li><strong>dmin</strong> &#8211; minimum distance from</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.InverseWatershed.save">
<tt class="descname">save</tt><big>(</big><em>self</em>, <em>fname</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.InverseWatershed.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save all regions into a HDF5 file</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.ext.watershed.Region">
<em class="property">class </em><tt class="descclassname">pyFAI.ext.watershed.</tt><tt class="descname">Region</tt><a class="headerlink" href="#pyFAI.ext.watershed.Region" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="attribute">
<dt id="pyFAI.ext.watershed.Region.border">
<tt class="descname">border</tt><a class="headerlink" href="#pyFAI.ext.watershed.Region.border" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.Region.get_borders">
<tt class="descname">get_borders</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.Region.get_borders" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.Region.get_highest_pass">
<tt class="descname">get_highest_pass</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.Region.get_highest_pass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.Region.get_index">
<tt class="descname">get_index</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.Region.get_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.Region.get_maxi">
<tt class="descname">get_maxi</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.Region.get_maxi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.Region.get_mini">
<tt class="descname">get_mini</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.Region.get_mini" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.Region.get_neighbors">
<tt class="descname">get_neighbors</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.Region.get_neighbors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.Region.get_pass_to">
<tt class="descname">get_pass_to</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.Region.get_pass_to" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.Region.get_size">
<tt class="descname">get_size</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.Region.get_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.watershed.Region.highest_pass">
<tt class="descname">highest_pass</tt><a class="headerlink" href="#pyFAI.ext.watershed.Region.highest_pass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.watershed.Region.index">
<tt class="descname">index</tt><a class="headerlink" href="#pyFAI.ext.watershed.Region.index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.Region.init_values">
<tt class="descname">init_values</tt><big>(</big><em>self</em>, <em>__Pyx_memviewslice flat</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.Region.init_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the values : maxi, mini and pass both height and so on
:param flat: flat view on the data (intensity)
:return: True if there is a problem and the region should be removed</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.watershed.Region.maxi">
<tt class="descname">maxi</tt><a class="headerlink" href="#pyFAI.ext.watershed.Region.maxi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ext.watershed.Region.merge">
<tt class="descname">merge</tt><big>(</big><em>self</em>, <em>Region other</em><big>)</big><a class="headerlink" href="#pyFAI.ext.watershed.Region.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>merge 2 regions</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.watershed.Region.mini">
<tt class="descname">mini</tt><a class="headerlink" href="#pyFAI.ext.watershed.Region.mini" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.watershed.Region.neighbors">
<tt class="descname">neighbors</tt><a class="headerlink" href="#pyFAI.ext.watershed.Region.neighbors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.watershed.Region.pass_to">
<tt class="descname">pass_to</tt><a class="headerlink" href="#pyFAI.ext.watershed.Region.pass_to" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.watershed.Region.peaks">
<tt class="descname">peaks</tt><a class="headerlink" href="#pyFAI.ext.watershed.Region.peaks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.ext.watershed.Region.size">
<tt class="descname">size</tt><a class="headerlink" href="#pyFAI.ext.watershed.Region.size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">pyFAI</span></tt> Package</a></li>
<li><a class="reference internal" href="#module-pyFAI.average"><tt class="docutils literal"><span class="pre">average</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.azimuthalIntegrator"><tt class="docutils literal"><span class="pre">azimuthalIntegrator</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.multi_geometry"><tt class="docutils literal"><span class="pre">multi_geometry</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.integrate_widget"><tt class="docutils literal"><span class="pre">integrate_widget</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.geometry"><tt class="docutils literal"><span class="pre">geometry</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.geometryRefinement"><tt class="docutils literal"><span class="pre">geometryRefinement</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.detectors"><tt class="docutils literal"><span class="pre">detectors</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.spline"><tt class="docutils literal"><span class="pre">spline</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.opencl"><tt class="docutils literal"><span class="pre">opencl</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.ocl_azim"><tt class="docutils literal"><span class="pre">ocl_azim</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.ocl_azim_lut"><tt class="docutils literal"><span class="pre">ocl_azim_lut</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.ocl_azim_csr"><tt class="docutils literal"><span class="pre">ocl_azim_csr</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.ocl_azim_csr_dis"><tt class="docutils literal"><span class="pre">ocl_azim_csr_dis</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.io"><tt class="docutils literal"><span class="pre">io</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.calibration"><tt class="docutils literal"><span class="pre">calibration</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.peak_picker"><tt class="docutils literal"><span class="pre">peak_picker</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.massif"><tt class="docutils literal"><span class="pre">massif</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.blob_detection"><tt class="docutils literal"><span class="pre">blob_detection</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.calibrant"><tt class="docutils literal"><span class="pre">calibrant</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.distortion"><tt class="docutils literal"><span class="pre">distortion</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.worker"><tt class="docutils literal"><span class="pre">worker</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.units"><tt class="docutils literal"><span class="pre">units</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.utils"><tt class="docutils literal"><span class="pre">utils</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.gui.utils"><tt class="docutils literal"><span class="pre">gui.gui_utils</span></tt> Module</a></li>
<li><a class="reference internal" href="#ext-bilinear-module"><tt class="docutils literal"><span class="pre">ext.bilinear</span></tt> Module</a></li>
<li><a class="reference internal" href="#ext-bispev-module"><tt class="docutils literal"><span class="pre">ext._bispev</span></tt> Module</a></li>
<li><a class="reference internal" href="#ext-blob-module"><tt class="docutils literal"><span class="pre">ext._blob</span></tt> Module</a></li>
<li><a class="reference internal" href="#ext-container-module"><tt class="docutils literal"><span class="pre">ext.container</span></tt> Module</a></li>
<li><a class="reference internal" href="#ext-convolution-module"><tt class="docutils literal"><span class="pre">ext._convolution</span></tt> Module</a></li>
<li><a class="reference internal" href="#ext-distortion-module"><tt class="docutils literal"><span class="pre">ext._distortion</span></tt> Module</a></li>
<li><a class="reference internal" href="#ext-geometry-module"><tt class="docutils literal"><span class="pre">ext._geometry</span></tt> Module</a></li>
<li><a class="reference internal" href="#ext-histogram-module"><tt class="docutils literal"><span class="pre">ext.histogram</span></tt> Module</a></li>
<li><a class="reference internal" href="#ext-marchingsquares-module"><tt class="docutils literal"><span class="pre">ext.marchingsquares</span></tt> Module</a></li>
<li><a class="reference internal" href="#ext-morphology-module"><tt class="docutils literal"><span class="pre">ext.morphology</span></tt> Module</a></li>
<li><a class="reference internal" href="#ext-reconstruct-module"><tt class="docutils literal"><span class="pre">ext.reconstruct</span></tt> Module</a></li>
<li><a class="reference internal" href="#ext-relabel-module"><tt class="docutils literal"><span class="pre">ext.relabel</span></tt> Module</a></li>
<li><a class="reference internal" href="#ext-preproc-module"><tt class="docutils literal"><span class="pre">ext.preproc</span></tt> Module</a></li>
<li><a class="reference internal" href="#ext-tree-module"><tt class="docutils literal"><span class="pre">ext._tree</span></tt> Module</a></li>
<li><a class="reference internal" href="#ext-watershed-module"><tt class="docutils literal"><span class="pre">ext.watershed</span></tt> Module</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="modules.html"
                        title="previous chapter">pyFAI API</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../operations/index.html"
                        title="next chapter">Installation of Python Fast Azimuthal Integration library</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/api/pyFAI.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../operations/index.html" title="Installation of Python Fast Azimuthal Integration library"
             >next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="pyFAI API"
             >previous</a> |</li>
        <li><a href="../index.html">pyFAI 0.13.0 documentation</a> &raquo;</li>
          <li><a href="modules.html" >pyFAI API</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2016, Jerome Kieffer.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>
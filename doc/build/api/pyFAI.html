<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyFAI Package &mdash; pyFAI 0.12.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.12.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pyFAI 0.12.0 documentation" href="../index.html" />
    <link rel="up" title="pyFAI API" href="modules.html" />
    <link rel="next" title="Installation of Python Fast Azimuthal Integration library" href="../operations/index.html" />
    <link rel="prev" title="pyFAI API" href="modules.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../operations/index.html" title="Installation of Python Fast Azimuthal Integration library"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="pyFAI API"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">pyFAI 0.12.0 documentation</a> &raquo;</li>
          <li><a href="modules.html" accesskey="U">pyFAI API</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-pyFAI.__init__">
<span id="pyfai-package"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">pyFAI</span></tt> Package<a class="headerlink" href="#module-pyFAI.__init__" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="pyFAI.__init__.benchmarks">
<tt class="descclassname">pyFAI.__init__.</tt><tt class="descname">benchmarks</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.__init__.benchmarks" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the benchmarks</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.__init__.tests">
<tt class="descclassname">pyFAI.__init__.</tt><tt class="descname">tests</tt><big>(</big><em>deprecation=False</em><big>)</big><a class="headerlink" href="#pyFAI.__init__.tests" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the test suite of the installed version</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>deprecation</strong> &#8211; enable/disables deprecation warning in the tests</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pyFAI.azimuthalIntegrator">
<span id="azimuthalintegrator-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">azimuthalIntegrator</span></tt> Module<a class="headerlink" href="#module-pyFAI.azimuthalIntegrator" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator">
<em class="property">class </em><tt class="descclassname">pyFAI.azimuthalIntegrator.</tt><tt class="descname">AzimuthalIntegrator</tt><big>(</big><em>dist=1</em>, <em>poni1=0</em>, <em>poni2=0</em>, <em>rot1=0</em>, <em>rot2=0</em>, <em>rot3=0</em>, <em>pixel1=None</em>, <em>pixel2=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.geometry.Geometry" title="pyFAI.geometry.Geometry"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.geometry.Geometry</span></tt></a></p>
<p>This class is an azimuthal integrator based on P. Boesecke&#8217;s
geometry and histogram algorithm by Manolo S. del Rio and V.A Sole</p>
<p>All geometry calculation are done in the Geometry class</p>
<p>main methods are:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tth</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">ai</span><span class="o">.</span><span class="n">integrate1d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">npt</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s">&quot;2th_deg&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">ai</span><span class="o">.</span><span class="n">integrate1d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">npt</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s">&quot;q_nm^-1&quot;</span><span class="p">,</span> <span class="n">error_model</span><span class="o">=</span><span class="s">&quot;poisson&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regrouped</span> <span class="o">=</span> <span class="n">ai</span><span class="o">.</span><span class="n">integrate2d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">npt_rad</span><span class="p">,</span> <span class="n">npt_azim</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s">&quot;q_nm^-1&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.DEFAULT_METHOD">
<tt class="descname">DEFAULT_METHOD</tt><em class="property"> = 'splitbbox'</em><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.DEFAULT_METHOD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.create_mask">
<tt class="descname">create_mask</tt><big>(</big><em>data</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>mode='normal'</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.create_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines various masks into another one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; input array of data</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; input mask (if none, self.mask is used)</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value of dead pixels</li>
<li><strong>delta_dumy</strong> &#8211; precision of dummy pixels</li>
<li><strong>mode</strong> (<em>str</em>) &#8211; can be &#8220;normal&#8221; or &#8220;numpy&#8221; (inverted) or &#8220;where&#8221; applied to the mask</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the new mask</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray of bool</p>
</td>
</tr>
</tbody>
</table>
<p>This method combine two masks (dynamic mask from <em>data &amp;
dummy</em> and <em>mask</em>) to generate a new one with the &#8216;or&#8217; binary
operation.  One can adjust the level, with the <em>dummy</em> and
the <em>delta_dummy</em> parameter, when you consider the <em>data</em>
values needs to be masked out.</p>
<p>This method can work in two different <em>mode</em>:</p>
<blockquote>
<div><ul class="simple">
<li>&#8220;normal&#8221;: False for valid pixels, True for bad pixels</li>
<li>&#8220;numpy&#8221;: True for valid pixels, false for others</li>
</ul>
</div></blockquote>
<p>This method tries to accomodate various types of masks (like
valid=0 &amp; masked=-1, ...) and guesses if an input mask needs
to be inverted.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.dark_correction">
<tt class="descname">dark_correction</tt><big>(</big><em>data</em>, <em>dark=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.dark_correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct for Dark-current effects.
If dark is not defined, correct for a dark set by &#8220;set_darkfiles&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> &#8211; input ndarray with the image</li>
<li><strong>dark</strong> &#8211; ndarray with dark noise or None</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2tuple: corrected_data, dark_actually used (or None)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.darkcurrent">
<tt class="descname">darkcurrent</tt><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.darkcurrent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.empty">
<tt class="descname">empty</tt><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.empty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.flat_correction">
<tt class="descname">flat_correction</tt><big>(</big><em>data</em>, <em>flat=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.flat_correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct for flat field.
If flat is not defined, correct for a flat set by &#8220;set_flatfiles&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> &#8211; input ndarray with the image</li>
<li><strong>dark</strong> &#8211; ndarray with dark noise or None</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2tuple: corrected_data, flat_actually used (or None)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.flatfield">
<tt class="descname">flatfield</tt><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.flatfield" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_darkcurrent">
<tt class="descname">get_darkcurrent</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_darkcurrent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_empty">
<tt class="descname">get_empty</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_empty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_flatfield">
<tt class="descname">get_flatfield</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.get_flatfield" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.integrate1d">
<tt class="descname">integrate1d</tt><big>(</big><em>data</em>, <em>npt</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>variance=None</em>, <em>error_model=None</em>, <em>radial_range=None</em>, <em>azimuth_range=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>polarization_factor=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>method='csr'</em>, <em>unit=q_nm^-1</em>, <em>safe=True</em>, <em>normalization_factor=1.0</em>, <em>block_size=32</em>, <em>profile=False</em>, <em>all=False</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.integrate1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the azimuthal integrated Saxs curve in q(nm^-1) by default</p>
<p>Multi algorithm implementation (tries to be bullet proof), suitable for SAXS, WAXS, ... and much more</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the Detector/CCD camera</li>
<li><strong>npt</strong> (<em>int</em>) &#8211; number of points in the output pattern</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; output filename in 2/3 column ascii format</li>
<li><strong>correctSolidAngle</strong> (<em>bool</em>) &#8211; correct for solid angle of each pixel if True</li>
<li><strong>variance</strong> (<em>ndarray</em>) &#8211; array containing the variance of the data. If not available, no error propagation is done</li>
<li><strong>error_model</strong> (<em>str</em>) &#8211; When the variance is unknown, an error model can be given: &#8220;poisson&#8221; (variance = I), &#8220;azimuthal&#8221; (variance = (I-&lt;I&gt;)^2)</li>
<li><strong>radial_range</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the radial unit. If not provided, range is simply (data.min(), data.max()). Values outside the range are ignored.</li>
<li><strong>azimuth_range</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the azimuthal angle in degree. If not provided, range is simply (data.min(), data.max()). Values outside the range are ignored.</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array (same size as image) with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; polarization factor between -1 (vertical) and +1 (horizontal). 0 for circular polarization or random, None for no correction</li>
<li><strong>dark</strong> (<em>ndarray</em>) &#8211; dark noise image</li>
<li><strong>flat</strong> (<em>ndarray</em>) &#8211; flat field image</li>
<li><strong>method</strong> (<em>str</em>) &#8211; can be &#8220;numpy&#8221;, &#8220;cython&#8221;, &#8220;BBox&#8221; or &#8220;splitpixel&#8221;, &#8220;lut&#8221;, &#8220;csr&#8221;, &#8220;nosplit_csr&#8221;, &#8220;full_csr&#8221;, &#8220;lut_ocl&#8221; and &#8220;csr_ocl&#8221; if you want to go on GPU. To Specify the device: &#8220;csr_ocl_1,2&#8221;</li>
<li><strong>unit</strong> (<a class="reference internal" href="#pyFAI.units.Enum" title="pyFAI.units.Enum"><em>pyFAI.units.Enum</em></a>) &#8211; Output units, can be &#8220;q_nm^-1&#8221;, &#8220;q_A^-1&#8221;, &#8220;2th_deg&#8221;, &#8220;2th_rad&#8221;, &#8220;r_mm&#8221; for now</li>
<li><strong>safe</strong> (<em>bool</em>) &#8211; Do some extra checks to ensure LUT/CSR is still valid. False is faster.</li>
<li><strong>normalization_factor</strong> (<em>float</em>) &#8211; Value of a normalization monitor</li>
<li><strong>block_size</strong> &#8211; size of the block for OpenCL integration (unused?)</li>
<li><strong>profile</strong> &#8211; set to True to enable profiling in OpenCL</li>
<li><strong>all</strong> &#8211; if true return a dictionary with many more parameters</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">q/2th/r bins center positions and regrouped intensity (and error array if variance or variance model provided), uneless all==True.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2 or 3-tuple of ndarrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.integrate2d">
<tt class="descname">integrate2d</tt><big>(</big><em>data</em>, <em>npt_rad</em>, <em>npt_azim=360</em>, <em>filename=None</em>, <em>correctSolidAngle=True</em>, <em>variance=None</em>, <em>error_model=None</em>, <em>radial_range=None</em>, <em>azimuth_range=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>polarization_factor=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>method='bbox'</em>, <em>unit=q_nm^-1</em>, <em>safe=True</em>, <em>normalization_factor=1.0</em>, <em>all=False</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.integrate2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the azimuthal regrouped 2d image in q(nm^-1)/chi(deg) by default</p>
<p>Multi algorithm implementation (tries to be bullet proof)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; 2D array from the Detector/CCD camera</li>
<li><strong>npt_rad</strong> (<em>int</em>) &#8211; number of points in the radial direction</li>
<li><strong>npt_azim</strong> (<em>int</em>) &#8211; number of points in the azimuthal direction</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; output image (as edf format)</li>
<li><strong>correctSolidAngle</strong> (<em>bool</em>) &#8211; correct for solid angle of each pixel if True</li>
<li><strong>variance</strong> (<em>ndarray</em>) &#8211; array containing the variance of the data. If not available, no error propagation is done</li>
<li><strong>error_model</strong> (<em>str</em>) &#8211; When the variance is unknown, an error model can be given: &#8220;poisson&#8221; (variance = I), &#8220;azimuthal&#8221; (variance = (I-&lt;I&gt;)^2)</li>
<li><strong>radial_range</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the radial unit. If not provided, range is simply (data.min(), data.max()). Values outside the range are ignored.</li>
<li><strong>azimuth_range</strong> (<em>(float, float), optional</em>) &#8211; The lower and upper range of the azimuthal angle in degree. If not provided, range is simply (data.min(), data.max()). Values outside the range are ignored.</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array (same size as image) with 1 for masked pixels, and 0 for valid pixels</li>
<li><strong>dummy</strong> (<em>float</em>) &#8211; value for dead/masked pixels</li>
<li><strong>delta_dummy</strong> (<em>float</em>) &#8211; precision for dummy value</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; polarization factor between -1 (vertical) and +1 (horizontal). 0 for circular polarization or random, None for no correction</li>
<li><strong>dark</strong> (<em>ndarray</em>) &#8211; dark noise image</li>
<li><strong>flat</strong> (<em>ndarray</em>) &#8211; flat field image</li>
<li><strong>method</strong> (<em>str</em>) &#8211; can be &#8220;numpy&#8221;, &#8220;cython&#8221;, &#8220;BBox&#8221; or &#8220;splitpixel&#8221;, &#8220;lut&#8221;, &#8220;csr; &#8220;lut_ocl&#8221; and &#8220;csr_ocl&#8221; if you want to go on GPU. To Specify the device: &#8220;csr_ocl_1,2&#8221;</li>
<li><strong>unit</strong> (<a class="reference internal" href="#pyFAI.units.Enum" title="pyFAI.units.Enum"><em>pyFAI.units.Enum</em></a>) &#8211; Output units, can be &#8220;q_nm^-1&#8221;, &#8220;q_A^-1&#8221;, &#8220;2th_deg&#8221;, &#8220;2th_rad&#8221;, &#8220;r_mm&#8221; for now</li>
<li><strong>safe</strong> (<em>bool</em>) &#8211; Do some extra checks to ensure LUT is still valid. False is faster.</li>
<li><strong>normalization_factor</strong> (<em>float</em>) &#8211; Value of a normalization monitor</li>
<li><strong>all</strong> &#8211; if true, return many more intermediate results as a dict.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">azimuthaly regrouped intensity, q/2theta/r pos. and chi pos.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">3-tuple of ndarrays (2d, 1d, 1d)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.makeHeaders">
<tt class="descname">makeHeaders</tt><big>(</big><em>hdr='#'</em>, <em>dark=None</em>, <em>flat=None</em>, <em>polarization_factor=None</em>, <em>normalization_factor=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.makeHeaders" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>hdr</strong> (<em>str</em>) &#8211; string used as comment in the header</li>
<li><strong>dark</strong> &#8211; save the darks filenames (default: no)</li>
<li><strong>flat</strong> &#8211; save the flat filenames (default: no)</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; the polarization factor</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the header</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">str</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset azimuthal integrator in addition to other arrays.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.save1D">
<tt class="descname">save1D</tt><big>(</big><em>filename</em>, <em>dim1</em>, <em>I</em>, <em>error=None</em>, <em>dim1_unit=2th_deg</em>, <em>dark=None</em>, <em>flat=None</em>, <em>polarization_factor=None</em>, <em>normalization_factor=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.save1D" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; the filename used to save the 1D integration</li>
<li><strong>dim1</strong> (<em>numpy.ndarray</em>) &#8211; the x coordinates of the integrated curve</li>
<li><strong>I</strong> (<em>numpy.mdarray</em>) &#8211; The integrated intensity</li>
<li><strong>error</strong> (<em>numpy.ndarray or None</em>) &#8211; the error bar for each intensity</li>
<li><strong>dim1_unit</strong> (<em>pyFAI.units.Unit</em>) &#8211; the unit of the dim1 array</li>
<li><strong>dark</strong> &#8211; save the darks filenames (default: no)</li>
<li><strong>flat</strong> &#8211; save the flat filenames (default: no)</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; the polarization factor</li>
<li><strong>normalization_factor</strong> (<em>float</em>) &#8211; the monitor value</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This method save the result of a 1D integration.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.save2D">
<tt class="descname">save2D</tt><big>(</big><em>filename</em>, <em>I</em>, <em>dim1</em>, <em>dim2</em>, <em>error=None</em>, <em>dim1_unit=2th_deg</em>, <em>dark=None</em>, <em>flat=None</em>, <em>polarization_factor=None</em>, <em>normalization_factor=None</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.save2D" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; the filename used to save the 2D histogram</li>
<li><strong>dim1</strong> (<em>numpy.ndarray</em>) &#8211; the 1st coordinates of the histogram</li>
<li><strong>dim1</strong> &#8211; the 2nd coordinates of the histogram</li>
<li><strong>I</strong> (<em>numpy.mdarray</em>) &#8211; The integrated intensity</li>
<li><strong>error</strong> (<em>numpy.ndarray or None</em>) &#8211; the error bar for each intensity</li>
<li><strong>dim1_unit</strong> (<em>pyFAI.units.Unit</em>) &#8211; the unit of the dim1 array</li>
<li><strong>dark</strong> &#8211; save the darks filenames (default: no)</li>
<li><strong>flat</strong> &#8211; save the flat filenames (default: no)</li>
<li><strong>polarization_factor</strong> (<em>float</em>) &#8211; the polarization factor</li>
<li><strong>normalization_factor</strong> (<em>float</em>) &#8211; the monitor value</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This method save the result of a 2D integration.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.saxs">
<tt class="descname">saxs</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.saxs" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.separate">
<tt class="descname">separate</tt><big>(</big><em>data</em>, <em>npt_rad=1024</em>, <em>npt_azim=512</em>, <em>unit='2th_deg'</em>, <em>method='splitpixel'</em>, <em>percentile=50</em>, <em>mask=None</em>, <em>restore_mask=True</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.separate" title="Permalink to this definition">¶</a></dt>
<dd><p>Separate bragg signal from powder/amorphous signal using azimuthal integration,
median filering and projected back before subtraction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> &#8211; input image as numpy array</li>
<li><strong>npt_rad</strong> &#8211; number of radial points</li>
<li><strong>npt_azim</strong> &#8211; number of azimuthal points</li>
<li><strong>unit</strong> &#8211; unit to be used for integration</li>
<li><strong>method</strong> &#8211; pathway for integration and sort</li>
<li><strong>percentile</strong> &#8211; which percentile use for cutting out</li>
<li><strong>mask</strong> &#8211; masked out pixels array</li>
<li><strong>restore_mask</strong> &#8211; masked pixels have the same value as input data provided</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">bragg, amorphous</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_darkcurrent">
<tt class="descname">set_darkcurrent</tt><big>(</big><em>dark</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_darkcurrent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_darkfiles">
<tt class="descname">set_darkfiles</tt><big>(</big><em>files=None</em>, <em>method='mean'</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_darkfiles" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>files</strong> (<em>str or list(str) or None</em>) &#8211; file(s) used to compute the dark.</li>
<li><strong>method</strong> (<em>str</em>) &#8211; method used to compute the dark, &#8220;mean&#8221; or &#8220;median&#8221;</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Set the dark current from one or mutliple files, avaraged
according to the method provided</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_empty">
<tt class="descname">set_empty</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_empty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_flatfield">
<tt class="descname">set_flatfield</tt><big>(</big><em>flat</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_flatfield" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_flatfiles">
<tt class="descname">set_flatfiles</tt><big>(</big><em>files</em>, <em>method='mean'</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.set_flatfiles" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>files</strong> (<em>str or list(str) or None</em>) &#8211; file(s) used to compute the dark.</li>
<li><strong>method</strong> (<em>str</em>) &#8211; method used to compute the dark, &#8220;mean&#8221; or &#8220;median&#8221;</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Set the flat field from one or mutliple files, averaged
according to the method provided</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.setup_CSR">
<tt class="descname">setup_CSR</tt><big>(</big><em>shape</em>, <em>npt</em>, <em>mask=None</em>, <em>pos0_range=None</em>, <em>pos1_range=None</em>, <em>mask_checksum=None</em>, <em>unit=2th_deg</em>, <em>split='bbox'</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.setup_CSR" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare a look-up-table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shape</strong> (<em>(int, int)</em>) &#8211; shape of the dataset</li>
<li><strong>npt</strong> (<em>int or (int, int)</em>) &#8211; number of points in the the output pattern</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array with masked pixel (1=masked)</li>
<li><strong>pos0_range</strong> (<em>(float, float)</em>) &#8211; range in radial dimension</li>
<li><strong>pos1_range</strong> (<em>(float, float)</em>) &#8211; range in azimuthal dimension</li>
<li><strong>mask_checksum</strong> (<em>int (or anything else ...)</em>) &#8211; checksum of the mask buffer</li>
<li><strong>unit</strong> (<a class="reference internal" href="#pyFAI.units.Enum" title="pyFAI.units.Enum"><em>pyFAI.units.Enum</em></a>) &#8211; use to propagate the LUT object for further checkings</li>
<li><strong>split</strong> &#8211; Splitting scheme: valid options are &#8220;no&#8221;, &#8220;bbox&#8221;, &#8220;full&#8221;</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This method is called when a look-up table needs to be set-up.
The <em>shape</em> parameter, correspond to the shape of the original
datatset. It is possible to customize the number of point of
the output histogram with the <em>npt</em> parameter which can be
either an integer for an 1D integration or a 2-tuple of
integer in case of a 2D integration. The LUT will have a
different shape: (npt, lut_max_size), the later parameter
being calculated during the instanciation of the splitBBoxLUT
class.</p>
<p>It is possible to prepare the LUT with a predefine
<em>mask</em>. This operation can speedup the computation of the
later integrations. Instead of applying the patch on the
dataset, it is taken into account during the histogram
computation. If provided the <em>mask_checksum</em> prevent the
re-calculation of the mask. When the mask changes, its
checksum is used to reset (or not) the LUT (which is a very
time consuming operation !)</p>
<p>It is also possible to restrain the range of the 1D or 2D
pattern with the <em>pos1_range</em> and <em>pos2_range</em>.</p>
<p>The <em>unit</em> parameter is just propagated to the LUT integrator
for further checkings: The aim is to prevent an integration to
be performed in 2th-space when the LUT was setup in q space.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.setup_LUT">
<tt class="descname">setup_LUT</tt><big>(</big><em>shape</em>, <em>npt</em>, <em>mask=None</em>, <em>pos0_range=None</em>, <em>pos1_range=None</em>, <em>mask_checksum=None</em>, <em>unit=2th_deg</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.setup_LUT" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare a look-up-table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shape</strong> (<em>(int, int)</em>) &#8211; shape of the dataset</li>
<li><strong>npt</strong> (<em>int or (int, int)</em>) &#8211; number of points in the the output pattern</li>
<li><strong>mask</strong> (<em>ndarray</em>) &#8211; array with masked pixel (1=masked)</li>
<li><strong>pos0_range</strong> (<em>(float, float)</em>) &#8211; range in radial dimension</li>
<li><strong>pos1_range</strong> (<em>(float, float)</em>) &#8211; range in azimuthal dimension</li>
<li><strong>mask_checksum</strong> (<em>int (or anything else ...)</em>) &#8211; checksum of the mask buffer</li>
<li><strong>unit</strong> (<a class="reference internal" href="#pyFAI.units.Enum" title="pyFAI.units.Enum"><em>pyFAI.units.Enum</em></a>) &#8211; use to propagate the LUT object for further checkings</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This method is called when a look-up table needs to be set-up.
The <em>shape</em> parameter, correspond to the shape of the original
datatset. It is possible to customize the number of point of
the output histogram with the <em>npt</em> parameter which can be
either an integer for an 1D integration or a 2-tuple of
integer in case of a 2D integration. The LUT will have a
different shape: (npt, lut_max_size), the later parameter
being calculated during the instanciation of the splitBBoxLUT
class.</p>
<p>It is possible to prepare the LUT with a predefine
<em>mask</em>. This operation can speedup the computation of the
later integrations. Instead of applying the patch on the
dataset, it is taken into account during the histogram
computation. If provided the <em>mask_checksum</em> prevent the
re-calculation of the mask. When the mask changes, its
checksum is used to reset (or not) the LUT (which is a very
time consuming operation !)</p>
<p>It is also possible to restrain the range of the 1D or 2D
pattern with the <em>pos1_range</em> and <em>pos2_range</em>.</p>
<p>The <em>unit</em> parameter is just propagated to the LUT integrator
for further checkings: The aim is to prevent an integration to
be performed in 2th-space when the LUT was setup in q space.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd">
<tt class="descname">xrpd</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2">
<tt class="descname">xrpd2</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_histogram">
<tt class="descname">xrpd2_histogram</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_numpy">
<tt class="descname">xrpd2_numpy</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_splitBBox">
<tt class="descname">xrpd2_splitBBox</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_splitBBox" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_splitPixel">
<tt class="descname">xrpd2_splitPixel</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd2_splitPixel" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_CSR_OCL">
<tt class="descname">xrpd_CSR_OCL</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_CSR_OCL" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_LUT">
<tt class="descname">xrpd_LUT</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_LUT" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_LUT_OCL">
<tt class="descname">xrpd_LUT_OCL</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_LUT_OCL" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_OpenCL">
<tt class="descname">xrpd_OpenCL</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_OpenCL" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_cython">
<tt class="descname">xrpd_cython</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_cython" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_numpy">
<tt class="descname">xrpd_numpy</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_splitBBox">
<tt class="descname">xrpd_splitBBox</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_splitBBox" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_splitPixel">
<tt class="descname">xrpd_splitPixel</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator.xrpd_splitPixel" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.integrate_widget">
<span id="integrate-widget-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">integrate_widget</span></tt> Module<a class="headerlink" href="#module-pyFAI.integrate_widget" title="Permalink to this headline">¶</a></h1>
<p>pyFAI-integrate</p>
<p>A graphical tool (based on PyQt4) for performing azimuthal integration on series of files.</p>
<dl class="class">
<dt id="pyFAI.integrate_widget.AIWidget">
<em class="property">class </em><tt class="descclassname">pyFAI.integrate_widget.</tt><tt class="descname">AIWidget</tt><big>(</big><em>input_data=None</em>, <em>output_path=None</em>, <em>output_format=None</em>, <em>slow_dim=None</em>, <em>fast_dim=None</em>, <em>json_file='.azimint.json'</em><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">PyQt4.QtGui.QWidget</span></tt></p>
<dl class="attribute">
<dt id="pyFAI.integrate_widget.AIWidget.URL">
<tt class="descname">URL</tt><em class="property"> = 'http://pyfai.readthedocs.org/en/latest/man/pyFAI-integrate.html'</em><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.URL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.assign_unit">
<tt class="descname">assign_unit</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.assign_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>assign unit to the corresponding widget</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.detector_changed">
<tt class="descname">detector_changed</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.detector_changed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.die">
<tt class="descname">die</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.die" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.dump">
<tt class="descname">dump</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump the status of the current widget to a file in JSON</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; path where to save the config</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict with configuration</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.get_config">
<tt class="descname">get_config</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.get_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the configuration of the plugin and returns it as a dictionary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict with all information.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.get_method">
<tt class="descname">get_method</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.get_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the method name for azimuthal intgration</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.help">
<tt class="descname">help</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.help" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.openCL_changed">
<tt class="descname">openCL_changed</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.openCL_changed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.platform_changed">
<tt class="descname">platform_changed</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.platform_changed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.proceed">
<tt class="descname">proceed</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.proceed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.restore">
<tt class="descname">restore</tt><big>(</big><em>filename='.azimint.json'</em><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.restore" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore from JSON file the status of the current widget</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>str</em>) &#8211; path where the config was saved</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.save_config">
<tt class="descname">save_config</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.save_config" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.select_darkcurrent">
<tt class="descname">select_darkcurrent</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.select_darkcurrent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.select_flatfield">
<tt class="descname">select_flatfield</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.select_flatfield" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.select_maskfile">
<tt class="descname">select_maskfile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.select_maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.select_ponifile">
<tt class="descname">select_ponifile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.select_ponifile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.select_splinefile">
<tt class="descname">select_splinefile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.select_splinefile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.setStackDataObject">
<tt class="descname">setStackDataObject</tt><big>(</big><em>stack</em>, <em>stack_name=None</em><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.setStackDataObject" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.set_config">
<tt class="descname">set_config</tt><big>(</big><em>dico</em><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.set_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the widget from its description</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dico</strong> (<em>dict</em>) &#8211; dictionary with description of the widget</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.set_input_data">
<tt class="descname">set_input_data</tt><big>(</big><em>stack</em>, <em>stack_name=None</em><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.set_input_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.set_ponifile">
<tt class="descname">set_ponifile</tt><big>(</big><em>ponifile=None</em><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.set_ponifile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.integrate_widget.AIWidget.set_validators">
<tt class="descname">set_validators</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.AIWidget.set_validators" title="Permalink to this definition">¶</a></dt>
<dd><p>Set all validators for text entries</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.integrate_widget.Browser">
<em class="property">class </em><tt class="descclassname">pyFAI.integrate_widget.</tt><tt class="descname">Browser</tt><big>(</big><em>default_url='http://google.com'</em><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.Browser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">PyQt4.QtGui.QMainWindow</span></tt></p>
<dl class="method">
<dt id="pyFAI.integrate_widget.Browser.browse">
<tt class="descname">browse</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.integrate_widget.Browser.browse" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a web browse on a specific url and show the page on the
Webview widget.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.geometry">
<span id="geometry-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">geometry</span></tt> Module<a class="headerlink" href="#module-pyFAI.geometry" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.geometry.Geometry">
<em class="property">class </em><tt class="descclassname">pyFAI.geometry.</tt><tt class="descname">Geometry</tt><big>(</big><em>dist=1</em>, <em>poni1=0</em>, <em>poni2=0</em>, <em>rot1=0</em>, <em>rot2=0</em>, <em>rot3=0</em>, <em>pixel1=None</em>, <em>pixel2=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class is an azimuthal integrator based on P. Boesecke&#8217;s geometry and
histogram algorithm by Manolo S. del Rio and V.A Sole</p>
<p>Detector is assumed to be corrected from &#8220;raster orientation&#8221; effect.
It is not addressed here but rather in the Detector object or at read time.
Considering there is no tilt:</p>
<ul class="simple">
<li>Detector fast dimension (dim2) is supposed to be horizontal
(dimension X of the image)</li>
<li>Detector slow dimension (dim1) is supposed to be vertical, upwards
(dimension Y of the image)</li>
<li>The third dimension is chose such as the referential is
orthonormal, so dim3 is along incoming X-ray beam</li>
</ul>
<p>Axis 1 is along first dimension of detector (when not tilted),
this is the slow dimension of the image array in C or Y
x1={1,0,0}</p>
<p>Axis 2 is along second dimension of detector (when not tilted),
this is the fast dimension of the image in C or X
x2={0,1,0}</p>
<p>Axis 3 is along the incident X-Ray beam
x3={0,0,1}</p>
<p>We define the 3 rotation around axis 1, 2 and 3:</p>
<p>rotM1 = RotationMatrix[rot1,x1] =  {{1,0,0},{0,cos[rot1],-sin[rot1]},{0,sin[rot1],cos[rot1]}}
rotM2 =  RotationMatrix[rot2,x2] = {{cos[rot2],0,sin[rot2]},{0,1,0},{-sin[rot2],0,cos[rot2]}}
rotM3 =  RotationMatrix[rot3,x3] = {{cos[rot3],-sin[rot3],0},{sin[rot3],cos[rot3],0},{0,0,1}}</p>
<p>Rotations of the detector are applied first Rot around axis 1,
then axis 2 and finally around axis 3:</p>
<p>R = rotM3.rotM2.rotM1</p>
<dl class="docutils">
<dt>R = {{cos[rot2] cos[rot3],cos[rot3] sin[rot1] sin[rot2]-cos[rot1] sin[rot3],cos[rot1] cos[rot3] sin[rot2]+sin[rot1] sin[rot3]},</dt>
<dd>{cos[rot2] sin[rot3],cos[rot1] cos[rot3]+sin[rot1] sin[rot2] sin[rot3],-cos[rot3] sin[rot1]+cos[rot1] sin[rot2] sin[rot3]},
{-sin[rot2],cos[rot2] sin[rot1],cos[rot1] cos[rot2]}}</dd>
</dl>
<p>In Python notation:</p>
<p>R.x1 = [cos(rot2)*cos(rot3),cos(rot2)*sin(rot3),-sin(rot2)]</p>
<p>R.x2 = [cos(rot3)*sin(rot1)*sin(rot2) - cos(rot1)*sin(rot3),cos(rot1)*cos(rot3) + sin(rot1)*sin(rot2)*sin(rot3), cos(rot2)*sin(rot1)]</p>
<p>R.x3 = [cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3),-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3), cos(rot1)*cos(rot2)]</p>
<ul>
<li><p class="first">Coordinates of the Point of Normal Incidence:</p>
<p>PONI = R.{0,0,L}</p>
<dl class="docutils">
<dt>PONI = [L*(cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3)),</dt>
<dd><p class="first last">L*(-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3)),L*cos(rot1)*cos(rot2)]</p>
</dd>
</dl>
</li>
<li><p class="first">Any pixel on detector plan at coordinate (d1, d2) in
meters. Detector is at z=L</p>
<p>P={d1,d2,L}</p>
<p>R.P = [t1, t2, t3]
t1 = R.P.x1 = d1*cos(rot2)*cos(rot3) + d2*(cos(rot3)*sin(rot1)*sin(rot2) - cos(rot1)*sin(rot3)) + L*(cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3))
t2 = R.P.x2 = d1*cos(rot2)*sin(rot3)  + d2*(cos(rot1)*cos(rot3) + sin(rot1)*sin(rot2)*sin(rot3)) + L*(-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3))
t3 = R.P.x3 = d2*cos(rot2)*sin(rot1) - d1*sin(rot2) + L*cos(rot1)*cos(rot2)</p>
</li>
<li><p class="first">Distance sample (origin) to detector point (d1,d2)</p>
<dl class="docutils">
<dt><a href="#id12"><span class="problematic" id="id13">|R.P|</span></a> = sqrt(pow(Abs(L*cos(rot1)*cos(rot2) + d2*cos(rot2)*sin(rot1) - d1*sin(rot2)),2) +</dt>
<dd><p class="first last">pow(Abs(d1*cos(rot2)*cos(rot3) + d2*(cos(rot3)*sin(rot1)*sin(rot2) - cos(rot1)*sin(rot3)) +
L*(cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3))),2) +
pow(Abs(d1*cos(rot2)*sin(rot3) + L*(-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3)) +
d2*(cos(rot1)*cos(rot3) + sin(rot1)*sin(rot2)*sin(rot3))),2))</p>
</dd>
</dl>
</li>
<li><p class="first">cos(2theta) is defined as (R.P component along x3) over the distance from origin to data point <a href="#id14"><span class="problematic" id="id15">|R.P|</span></a></p>
</li>
</ul>
<p>tth = ArcCos [-(R.P).x3/<a href="#id16"><span class="problematic" id="id17">|R.P|</span></a>]</p>
<dl class="docutils">
<dt>tth = Arccos((-(L*cos(rot1)*cos(rot2)) - d2*cos(rot2)*sin(rot1) + d1*sin(rot2))/</dt>
<dd><dl class="first last docutils">
<dt>sqrt(pow(Abs(L*cos(rot1)*cos(rot2) + d2*cos(rot2)*sin(rot1) - d1*sin(rot2)),2) +</dt>
<dd><blockquote class="first">
<div>pow(Abs(d1*cos(rot2)*cos(rot3) + d2*(cos(rot3)*sin(rot1)*sin(rot2) - cos(rot1)*sin(rot3)) +</div></blockquote>
<dl class="docutils">
<dt>L*(cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3))),2) +</dt>
<dd>pow(Abs(d1*cos(rot2)*sin(rot3) + L*(-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3)) +</dd>
</dl>
<p class="last">d2*(cos(rot1)*cos(rot3) + sin(rot1)*sin(rot2)*sin(rot3))),2)))</p>
</dd>
</dl>
</dd>
</dl>
<ul class="simple">
<li>tan(2theta) is defined as sqrt(t1**2 + t2**2) / t3</li>
</ul>
<p>tth = ArcTan2 [sqrt(t1**2 + t2**2) , t3 ]</p>
<p>Getting 2theta from it&#8217;s tangeant seems both more precise (around
beam stop very far from sample) and faster by about 25% Currently
there is a swich in the method to follow one path or the other.</p>
<ul class="simple">
<li>Tangeant of angle chi is defined as (R.P component along x1)
over (R.P component along x2). Arctan2 should be used in actual
calculation</li>
</ul>
<blockquote>
<div><p>chi = ArcTan[((R.P).x1) / ((R.P).x2)]</p>
<dl class="docutils">
<dt>chi = ArcTan2(d1*cos(rot2)*cos(rot3) + d2*(cos(rot3)*sin(rot1)*sin(rot2) - cos(rot1)*sin(rot3)) +</dt>
<dd><blockquote class="first">
<div>L*(cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3)),</div></blockquote>
<dl class="last docutils">
<dt>d1*cos(rot2)*sin(rot3) + L*(-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3)) +</dt>
<dd>d2*(cos(rot1)*cos(rot3) + sin(rot1)*sin(rot2)*sin(rot3)))</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl class="method">
<dt id="pyFAI.geometry.Geometry.array_from_unit">
<tt class="descname">array_from_unit</tt><big>(</big><em>shape=None</em>, <em>typ='center'</em>, <em>unit=2th_deg</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.array_from_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array of position in different dimentions (R, Q,
2Theta)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>shape</strong> (<em>ndarray.shape</em>) &#8211; shape of the expected array</li>
<li><strong>typ</strong> (<em>str</em>) &#8211; &#8220;center&#8221;, &#8220;corner&#8221; or &#8220;delta&#8221;</li>
<li><strong>unit</strong> (<a class="reference internal" href="#pyFAI.units.Enum" title="pyFAI.units.Enum"><em>pyFAI.units.Enum</em></a>) &#8211; can be Q, TTH, R for now</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">R, Q or 2Theta array depending on unit</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.calc_pos_zyx">
<tt class="descname">calc_pos_zyx</tt><big>(</big><em>d0=None</em>, <em>d1=None</em>, <em>d2=None</em>, <em>param=None</em>, <em>corners=False</em>, <em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.calc_pos_zyx" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of a set of points in space in the sample&#8217;s centers referential.</p>
<p>This is usually used for calculating the pixel position in space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>d0</strong> &#8211; altitude on the point compared to the detector (i.e. z), may be None</li>
<li><strong>d1</strong> &#8211; position on the detector along the slow dimention (i.e. y)</li>
<li><strong>d2</strong> &#8211; position on the detector along the fastest dimention (i.e. x)</li>
<li><strong>corners</strong> &#8211; return positions on the corners (instead of center)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return 3-tuple of nd-array,  with  dim0=along the beam,</dt>
<dd>dim1=along slowest dimension
dim2=along fastest dimension</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.calc_transmission">
<tt class="descname">calc_transmission</tt><big>(</big><em>t0</em>, <em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.calc_transmission" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the absorption correction for a phosphor screen or a scintillator
from t0, the normal transmission of the screen.</p>
<dl class="docutils">
<dt>Icor = Iobs(1-t0)/(1-exp(ln(t0)/cos(incidence)))</dt>
<dd>1-exp(ln(t0)/cos(incidence)</dd>
<dt>let t = &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</dt>
<dd>1 - t0</dd>
</dl>
<p>See reference on:
J. Appl. Cryst. (2002). 35, 356–359 G. Wu et al.  CCD phosphor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>t0</strong> &#8211; value of the normal transmission (from 0 to 1)</li>
<li><strong>shape</strong> &#8211; shape of the array</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">actual</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.calcfrom1d">
<tt class="descname">calcfrom1d</tt><big>(</big><em>tth</em>, <em>I</em>, <em>shape=None</em>, <em>mask=None</em>, <em>dim1_unit=2th_deg</em>, <em>correctSolidAngle=True</em>, <em>dummy=0.0</em>, <em>polarization_factor=None</em>, <em>dark=None</em>, <em>flat=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.calcfrom1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a 2D image from a 1D integrated profile</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tth</strong> &#8211; 1D array with radial unit</li>
<li><strong>I</strong> &#8211; scattering intensity</li>
<li><strong>shape</strong> &#8211; shape of the image (if not defined by the detector)</li>
<li><strong>dim1_unit</strong> &#8211; unit for the &#8220;tth&#8221; array</li>
<li><strong>correctSolidAngle</strong> &#8211; </li>
<li><strong>dummy</strong> &#8211; value for masked pixels</li>
<li><strong>polarization_factor</strong> &#8211; set to true to use previously used value</li>
<li><strong>dark</strong> &#8211; dark current correction</li>
<li><strong>flat</strong> &#8211; flatfield corrction</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2D image reconstructed</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.center_array">
<tt class="descname">center_array</tt><big>(</big><em>shape=None</em>, <em>unit='2th'</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.center_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 2D array of the given shape with (i,j) (radial
angle ) for all elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> (<em>2-tuple of integer</em>) &#8211; expected shape</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">3d array with shape=(<a href="#id1"><span class="problematic" id="id2">*</span></a>shape,4,2) the two elements are:
* dim3[0]: radial angle 2th, q, r, ...
* dim3[1]: azimuthal angle chi</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.chi">
<tt class="descname">chi</tt><big>(</big><em>d1</em>, <em>d2</em>, <em>path='cython'</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.chi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the chi (azimuthal angle) for the centre of a pixel
at coordinate d1,d2 which in the lab ref has coordinate:</p>
<p>X1 = p1*cos(rot2)*cos(rot3) + p2*(cos(rot3)*sin(rot1)*sin(rot2) - cos(rot1)*sin(rot3)) -  L*(cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3))
X2 = p1*cos(rot2)*sin(rot3) - L*(-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3)) +  p2*(cos(rot1)*cos(rot3) + sin(rot1)*sin(rot2)*sin(rot3))
X3 = -(L*cos(rot1)*cos(rot2)) + p2*cos(rot2)*sin(rot1) - p1*sin(rot2)
hence tan(Chi) =  X2 / X1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>float or array of them</em>) &#8211; pixel coordinate along the 1st dimention (C convention)</li>
<li><strong>d2</strong> (<em>float or array of them</em>) &#8211; pixel coordinate along the 2nd dimention (C convention)</li>
<li><strong>path</strong> &#8211; can be &#8220;tan&#8221; (i.e via numpy) or &#8220;cython&#8221;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">chi, the azimuthal angle in rad</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.chiArray">
<tt class="descname">chiArray</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.chiArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array of azimuthal angle chi(i,j) for all elements in the detector.</p>
<p>Azimuthal angles are in radians</p>
<p>Nota: Refers to the pixel centers !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; the shape of the chi array</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the chi array as numpy.ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.chi_corner">
<tt class="descname">chi_corner</tt><big>(</big><em>d1</em>, <em>d2</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.chi_corner" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the chi (azimuthal angle) for the corner of a pixel
at coordinate d1,d2 which in the lab ref has coordinate:</p>
<p>X1 = p1*cos(rot2)*cos(rot3) + p2*(cos(rot3)*sin(rot1)*sin(rot2) - cos(rot1)*sin(rot3)) -  L*(cos(rot1)*cos(rot3)*sin(rot2) + sin(rot1)*sin(rot3))
X2 = p1*cos(rot2)*sin(rot3) - L*(-(cos(rot3)*sin(rot1)) + cos(rot1)*sin(rot2)*sin(rot3)) +  p2*(cos(rot1)*cos(rot3) + sin(rot1)*sin(rot2)*sin(rot3))
X3 = -(L*cos(rot1)*cos(rot2)) + p2*cos(rot2)*sin(rot1) - p1*sin(rot2)
hence tan(Chi) =  X2 / X1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>float or array of them</em>) &#8211; pixel coordinate along the 1st dimention (C convention)</li>
<li><strong>d2</strong> (<em>float or array of them</em>) &#8211; pixel coordinate along the 2nd dimention (C convention)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">chi, the azimuthal angle in rad</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.chia">
<tt class="descname">chia</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.chia" title="Permalink to this definition">¶</a></dt>
<dd><p>chi array in cache</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.cornerArray">
<tt class="descname">cornerArray</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.cornerArray" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.cornerQArray">
<tt class="descname">cornerQArray</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.cornerQArray" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.cornerRArray">
<tt class="descname">cornerRArray</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.cornerRArray" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.cornerRd2Array">
<tt class="descname">cornerRd2Array</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.cornerRd2Array" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.corner_array">
<tt class="descname">corner_array</tt><big>(</big><em>shape=None</em>, <em>unit='2th'</em>, <em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.corner_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 3D array of the given shape with (i,j) (radial
angle 2th, azimuthal angle chi ) for all elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> (<em>2-tuple of integer</em>) &#8211; expected shape</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">3d array with shape=(<a href="#id3"><span class="problematic" id="id4">*</span></a>shape,4,2) the two elements are:
* dim3[0]: radial angle 2th, q, r, ...
* dim3[1]: azimuthal angle chi</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.correct_SA_spline">
<tt class="descname">correct_SA_spline</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.correct_SA_spline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.cosIncidance">
<tt class="descname">cosIncidance</tt><big>(</big><em>d1</em>, <em>d2</em>, <em>path='cython'</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.cosIncidance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the incidence angle (alpha) for current pixels (P).
The poni being the point of normal incidence,
it&#8217;s incidence angle is ${alpha} = 0$ hence $cos({alpha}) = 1$</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> &#8211; 1d or 2d set of points in pixel coord</li>
<li><strong>d2</strong> &#8211; 1d or 2d set of points in pixel coord</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">cosine of the incidence angle</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.del_chia">
<tt class="descname">del_chia</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.del_chia" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.del_dssa">
<tt class="descname">del_dssa</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.del_dssa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.del_qa">
<tt class="descname">del_qa</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.del_qa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.del_ra">
<tt class="descname">del_ra</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.del_ra" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.del_ttha">
<tt class="descname">del_ttha</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.del_ttha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.delta2Theta">
<tt class="descname">delta2Theta</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.delta2Theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 3D array of the given shape with (i,j) with the max
distance between the center and any corner in 2 theta</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; The shape of the detector array: 2-tuple of integer</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">2D-array containing the max delta angle between a pixel center and any corner in 2theta-angle (rad)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.deltaChi">
<tt class="descname">deltaChi</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.deltaChi" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 3D array of the given shape with (i,j) with the max
distance between the center and any corner in chi-angle (rad)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; The shape of the detector array: 2-tuple of integer</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">2D-array  containing the max delta angle between a pixel center and any corner in chi-angle (rad)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.deltaQ">
<tt class="descname">deltaQ</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.deltaQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 2D array of the given shape with (i,j) with the max
distance between the center and any corner in q_vector unit
(nm^-1)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; The shape of the detector array: 2-tuple of integer</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">array 2D containing the max delta Q between a pixel center and any corner in q_vector unit (nm^-1)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.deltaR">
<tt class="descname">deltaR</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.deltaR" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 2D array of the given shape with (i,j) with the max
distance between the center and any corner in radius unit (mm)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; The shape of the detector array: 2-tuple of integer</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">array 2D containing the max delta Q between a pixel center and any corner in q_vector unit (nm^-1)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.deltaRd2">
<tt class="descname">deltaRd2</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.deltaRd2" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 2D array of the given shape with (i,j) with the max
distance between the center and any corner in unit: reciprocal spacing squarred (1/nm^2)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; The shape of the detector array: 2-tuple of integer</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">array 2D containing the max delta (d*)^2 between a pixel center and any corner in reciprocal spacing squarred (1/nm^2)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.delta_array">
<tt class="descname">delta_array</tt><big>(</big><em>shape=None</em>, <em>unit='2th'</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.delta_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 2D array of the given shape with (i,j) (delta-radial
angle) for all elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> (<em>2-tuple of integer</em>) &#8211; expected shape</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">3d array with shape=(<a href="#id5"><span class="problematic" id="id6">*</span></a>shape,4,2) the two elements are:
* dim3[0]: radial angle 2th, q, r, ...
* dim3[1]: azimuthal angle chi</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.diffSolidAngle">
<tt class="descname">diffSolidAngle</tt><big>(</big><em>d1</em>, <em>d2</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.diffSolidAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the solid angle of the current pixels (P) versus the PONI (C)</p>
<blockquote>
<div>Omega(P)    A cos(a)     SC^2         3       SC^3</div></blockquote>
<dl class="docutils">
<dt>dOmega = &#8212;&#8212;&#8212; = &#8212;&#8212;&#8212; x &#8212;&#8212;&#8212; = cos (a) = &#8212;&#8212;</dt>
<dd>Omega(C)    SP^2        A cos(0)              SP^3</dd>
</dl>
<p>cos(a) = SC/SP</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> &#8211; 1d or 2d set of points</li>
<li><strong>d2</strong> &#8211; 1d or 2d set of points (same size&amp;shape as d1)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">solid angle correction array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.dist">
<tt class="descname">dist</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.dist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.dssa">
<tt class="descname">dssa</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.dssa" title="Permalink to this definition">¶</a></dt>
<dd><p>solid angle array in cache</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.getFit2D">
<tt class="descname">getFit2D</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.getFit2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Export geometry setup with the geometry of Fit2D</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict with parameters compatible with fit2D geometry</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.getPyFAI">
<tt class="descname">getPyFAI</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.getPyFAI" title="Permalink to this definition">¶</a></dt>
<dd><p>Export geometry setup with the geometry of PyFAI</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict with the parameter-set of the PyFAI geometry</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.getSPD">
<tt class="descname">getSPD</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.getSPD" title="Permalink to this definition">¶</a></dt>
<dd><p>get the SPD like parameter set: For geometry description see
Peter Boesecke J.Appl.Cryst.(2007).40, s423–s427</p>
<p>Basically the main difference with pyFAI is the order of the axis which are flipped</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dictionnary with those parameters:
SampleDistance: distance from sample to detector at the PONI (orthogonal projection)
Center_1, pixel position of the PONI along fastest axis
Center_2: pixel position of the PONI along slowest axis
Rot_1: rotation around the fastest axis (x)
Rot_2: rotation around the slowest axis (y)
Rot_3: rotation around the axis ORTHOGONAL to the detector plan
PSize_1: pixel size in meter along the fastest dimention
PSize_2: pixel size in meter along the slowst dimention
splineFile: name of the file containing the spline
BSize_1: pixel binning factor along the fastest dimention
BSize_2: pixel binning factor along the slowst dimention
WaveLength: wavelength used in meter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_chia">
<tt class="descname">get_chia</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_chia" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_correct_solid_angle_for_spline">
<tt class="descname">get_correct_solid_angle_for_spline</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_correct_solid_angle_for_spline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_dist">
<tt class="descname">get_dist</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_dist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_dssa">
<tt class="descname">get_dssa</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_dssa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_mask">
<tt class="descname">get_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_maskfile">
<tt class="descname">get_maskfile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_pixel1">
<tt class="descname">get_pixel1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_pixel1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_pixel2">
<tt class="descname">get_pixel2</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_pixel2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_poni1">
<tt class="descname">get_poni1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_poni1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_poni2">
<tt class="descname">get_poni2</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_poni2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_qa">
<tt class="descname">get_qa</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_qa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_ra">
<tt class="descname">get_ra</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_ra" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_rot1">
<tt class="descname">get_rot1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_rot1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_rot2">
<tt class="descname">get_rot2</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_rot2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_rot3">
<tt class="descname">get_rot3</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_rot3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_shape">
<tt class="descname">get_shape</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Guess what is the best shape ....
:param shape: force this value (2-tuple of int)
:return: 2-tuple of int</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_spline">
<tt class="descname">get_spline</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_spline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_splineFile">
<tt class="descname">get_splineFile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_ttha">
<tt class="descname">get_ttha</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_ttha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.get_wavelength">
<tt class="descname">get_wavelength</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.get_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.load">
<tt class="descname">load</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the refined parameters from a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; name of the file to load</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.mask">
<tt class="descname">mask</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.maskfile">
<tt class="descname">maskfile</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.oversampleArray">
<tt class="descname">oversampleArray</tt><big>(</big><em>myarray</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.oversampleArray" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.pixel1">
<tt class="descname">pixel1</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.pixel1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.pixel2">
<tt class="descname">pixel2</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.pixel2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.polarization">
<tt class="descname">polarization</tt><big>(</big><em>shape=None</em>, <em>factor=None</em>, <em>axis_offset=0</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.polarization" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the polarization correction accoding to the
polarization factor:</p>
<ul class="simple">
<li>If the polarization factor is None, the correction is not applied (returns 1)</li>
<li>If the polarization factor is 0 (circular polarization), the correction correspond to (1+(cos2θ)^2)/2</li>
<li>If the polarization factor is 1 (linear horizontal polarization), there is no correction in the vertical plane  and a node at 2th=90, chi=0</li>
<li>If the polarization factor is -1 (linear vertical polarization), there is no correction in the horizontal plane and a node at 2th=90, chi=90</li>
<li>If the polarization is elliptical, the polarization factor varies between -1 and +1.</li>
</ul>
<p>The axis_offset parameter allows correction for the misalignement of the polarization plane (or ellipse main axis) and the the detector&#8217;s X axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>factor</strong> &#8211; (Ih-Iv)/(Ih+Iv): varies between 0 (no polarization) and 1 (where division by 0 could occure at 2th=90, chi=0)</li>
<li><strong>axis_offset</strong> &#8211; Angle between the polarization main axis and detector X direction (in radians !!!)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2D array with polarization correction array (intensity/polarisation)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.poni1">
<tt class="descname">poni1</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.poni1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.poni2">
<tt class="descname">poni2</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.poni2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.positionArray">
<tt class="descname">positionArray</tt><big>(</big><em>shape=None</em>, <em>corners=False</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.positionArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array for the pixel position given the shape of the detector.</p>
<p>if corners is False, the coordinates of the center of the pixel
is returned in an array of shape: (shape[0], shape[1], 3)
where the 3 coordinates are:
* z: along incident beam,
* y: to the top/sky,
* x: towards the center of the ring</p>
<p>If is True, the corner of each pixels are then returned.
the output shape is then (shape[0], shape[1], 4, 3)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>shape</strong> &#8211; shape of the array expected</li>
<li><strong>corners</strong> &#8211; set to true to receive a (...,4,3) array of corner positions</li>
<li><strong>dtype</strong> &#8211; output format requested</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">3D coodinates as nd-array of size (...,3) or (...,3) (default)</p>
</td>
</tr>
</tbody>
</table>
<p>Nota: this value is not cached and actually generated on demand (costly)</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.qArray">
<tt class="descname">qArray</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.qArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array of the given shape with q(i,j) for all
elements.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.qCornerFunct">
<tt class="descname">qCornerFunct</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.qCornerFunct" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.qFunction">
<tt class="descname">qFunction</tt><big>(</big><em>d1</em>, <em>d2</em>, <em>param=None</em>, <em>path='cython'</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.qFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the q value for the center of a given pixel (or set
of pixels) in nm-1</p>
<p>q = 4pi/lambda sin( 2theta / 2 )</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in first dimension (c order)</li>
<li><strong>d2</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in second dimension (c order)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">q in in nm^(-1)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float or array of floats.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.qa">
<tt class="descname">qa</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.qa" title="Permalink to this definition">¶</a></dt>
<dd><p>Q array in cache</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.rArray">
<tt class="descname">rArray</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.rArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array of the given shape with r(i,j) for all elements;
The radius r being  in meters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; expected shape of the detector</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">2d array of the given shape with radius in m from beam center on detector.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.rCornerFunct">
<tt class="descname">rCornerFunct</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.rCornerFunct" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.rFunction">
<tt class="descname">rFunction</tt><big>(</big><em>d1</em>, <em>d2</em>, <em>param=None</em>, <em>path='cython'</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.rFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the radius value for the center of a given pixel
(or set of pixels) in m</p>
<blockquote>
<div>r = distance to the incident beam</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in first dimension (c order)</li>
<li><strong>d2</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in second dimension (c order)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">r in in m</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float or array of floats.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.ra">
<tt class="descname">ra</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.ra" title="Permalink to this definition">¶</a></dt>
<dd><p>R array in cache</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.rd2Array">
<tt class="descname">rd2Array</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.rd2Array" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array of the given shape with (d*(i,j))^2 for all pixels.</p>
<p>d*^2 is the reciprocal spacing squared in inverse nm squared</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; expected shape of the detector</td>
</tr>
</tbody>
</table>
<p>:return:2d array of the given shape with reciprocal spacing squared</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.read">
<tt class="descname">read</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the refined parameters from a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; name of the file to load</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset most arrays that are cached: used when a parameter
changes.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.rot1">
<tt class="descname">rot1</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.rot1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.rot2">
<tt class="descname">rot2</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.rot2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.rot3">
<tt class="descname">rot3</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.rot3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.save">
<tt class="descname">save</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the geometry parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; name of the file where to save the parameters</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.setChiDiscAtPi">
<tt class="descname">setChiDiscAtPi</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.setChiDiscAtPi" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the position of the discontinuity of the chi axis between
-pi and +pi.  This is the default behavour</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.setChiDiscAtZero">
<tt class="descname">setChiDiscAtZero</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.setChiDiscAtZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the position of the discontinuity of the chi axis between
0 and 2pi.  By default it is between pi and -pi</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.setFit2D">
<tt class="descname">setFit2D</tt><big>(</big><em>directDist</em>, <em>centerX</em>, <em>centerY</em>, <em>tilt=0.0</em>, <em>tiltPlanRotation=0.0</em>, <em>pixelX=None</em>, <em>pixelY=None</em>, <em>splineFile=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.setFit2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the Fit2D-like parameter set: For geometry description see
HPR 1996 (14) pp-240</p>
<p>Warning: Fit2D flips automatically images depending on their file-format.
By reverse engineering we noticed this behavour for Tiff and Mar345 images (at least).
To obtaine correct result you will have to flip images using numpy.flipud.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>direct</strong> &#8211; direct distance from sample to detector along the incident beam (in millimeter as in fit2d)</li>
<li><strong>tilt</strong> &#8211; tilt in degrees</li>
<li><strong>tiltPlanRotation</strong> &#8211; Rotation (in degrees) of the tilt plan arround the Z-detector axis
* 0deg -&gt; Y does not move, +X goes to Z&lt;0
* 90deg -&gt; X does not move, +Y goes to Z&lt;0
* 180deg -&gt; Y does not move, +X goes to Z&gt;0
* 270deg -&gt; X does not move, +Y goes to Z&gt;0</li>
<li><strong>pixelX,pixelY</strong> &#8211; as in fit2d they ar given in micron, not in meter</li>
<li><strong>centerY</strong> (<em>centerX,</em>) &#8211; pixel position of the beam center</li>
<li><strong>splineFile</strong> &#8211; name of the file containing the spline</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.setOversampling">
<tt class="descname">setOversampling</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.setOversampling" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.setPyFAI">
<tt class="descname">setPyFAI</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.setPyFAI" title="Permalink to this definition">¶</a></dt>
<dd><p>set the geometry from a pyFAI-like dict</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.setSPD">
<tt class="descname">setSPD</tt><big>(</big><em>SampleDistance</em>, <em>Center_1</em>, <em>Center_2</em>, <em>Rot_1=0</em>, <em>Rot_2=0</em>, <em>Rot_3=0</em>, <em>PSize_1=None</em>, <em>PSize_2=None</em>, <em>splineFile=None</em>, <em>BSize_1=1</em>, <em>BSize_2=1</em>, <em>WaveLength=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.setSPD" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the SPD like parameter set: For geometry description see
Peter Boesecke J.Appl.Cryst.(2007).40, s423–s427</p>
<p>Basically the main difference with pyFAI is the order of the axis which are flipped</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>SampleDistance</strong> &#8211; distance from sample to detector at the PONI (orthogonal projection)</td>
</tr>
</tbody>
</table>
<p>:param Center_1, pixel position of the PONI along fastest axis
:param Center_2: pixel position of the PONI along slowest axis
:param Rot_1: rotation around the fastest axis (x)
:param Rot_2: rotation around the slowest axis (y)
:param Rot_3: rotation around the axis ORTHOGONAL to the detector plan
:param PSize_1: pixel size in meter along the fastest dimention
:param PSize_2: pixel size in meter along the slowst dimention
:param splineFile: name of the file containing the spline
:param BSize_1: pixel binning factor along the fastest dimention
:param BSize_2: pixel binning factor along the slowst dimention
:param WaveLength: wavelength used</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_chia">
<tt class="descname">set_chia</tt><big>(</big><em>_</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_chia" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_correct_solid_angle_for_spline">
<tt class="descname">set_correct_solid_angle_for_spline</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_correct_solid_angle_for_spline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_dist">
<tt class="descname">set_dist</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_dist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_dssa">
<tt class="descname">set_dssa</tt><big>(</big><em>_</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_dssa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_mask">
<tt class="descname">set_mask</tt><big>(</big><em>mask</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_maskfile">
<tt class="descname">set_maskfile</tt><big>(</big><em>maskfile</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_pixel1">
<tt class="descname">set_pixel1</tt><big>(</big><em>pixel1</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_pixel1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_pixel2">
<tt class="descname">set_pixel2</tt><big>(</big><em>pixel2</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_pixel2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_poni1">
<tt class="descname">set_poni1</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_poni1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_poni2">
<tt class="descname">set_poni2</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_poni2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_qa">
<tt class="descname">set_qa</tt><big>(</big><em>_</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_qa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_ra">
<tt class="descname">set_ra</tt><big>(</big><em>_</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_ra" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_rot1">
<tt class="descname">set_rot1</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_rot1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_rot2">
<tt class="descname">set_rot2</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_rot2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_rot3">
<tt class="descname">set_rot3</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_rot3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_spline">
<tt class="descname">set_spline</tt><big>(</big><em>spline</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_spline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_splineFile">
<tt class="descname">set_splineFile</tt><big>(</big><em>splineFile</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_ttha">
<tt class="descname">set_ttha</tt><big>(</big><em>_</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_ttha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.set_wavelength">
<tt class="descname">set_wavelength</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.set_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pyFAI.geometry.Geometry.sload">
<em class="property">classmethod </em><tt class="descname">sload</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.sload" title="Permalink to this definition">¶</a></dt>
<dd><p>A static method combining the constructor and the loader from
a file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; name of the file to load</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">instance of Gerometry of AzimuthalIntegrator set-up with the parameter from the file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.solidAngleArray">
<tt class="descname">solidAngleArray</tt><big>(</big><em>shape=None</em>, <em>order=3</em>, <em>absolute=False</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.solidAngleArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array for the solid angle correction
given the shape of the detector.</p>
<p>solid_angle = cos(incidence)^3</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shape</strong> &#8211; shape of the array expected</li>
<li><strong>order</strong> &#8211; should be 3, power of the formula just obove</li>
<li><strong>absolute</strong> &#8211; the absolute solid angle is calculated as:</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>SA = pix1*pix2/dist^2 * cos(incidence)^3</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.spline">
<tt class="descname">spline</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.spline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.splineFile">
<tt class="descname">splineFile</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.tth">
<tt class="descname">tth</tt><big>(</big><em>d1</em>, <em>d2</em>, <em>param=None</em>, <em>path='cython'</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.tth" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the 2theta value for the center of a given pixel
(or set of pixels)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in first dimension (c order)</li>
<li><strong>d2</strong> (<em>scalar or array of scalar</em>) &#8211; position(s) in pixel in second dimension (c order)</li>
<li><strong>path</strong> &#8211; can be &#8220;cos&#8221;, &#8220;tan&#8221; or &#8220;cython&#8221;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">2theta in radians</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float or array of floats.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.tth_corner">
<tt class="descname">tth_corner</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.tth_corner" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator that deprecates the use of a function</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.ttha">
<tt class="descname">ttha</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.ttha" title="Permalink to this definition">¶</a></dt>
<dd><p>2theta array in cache</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.twoThetaArray">
<tt class="descname">twoThetaArray</tt><big>(</big><em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.twoThetaArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an array of two-theta(i,j) in radians for each pixel in detector</p>
<p>the 2theta array values are in radians</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> &#8211; shape of the detector</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">array of 2theta position in radians</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometry.Geometry.wavelength">
<tt class="descname">wavelength</tt><a class="headerlink" href="#pyFAI.geometry.Geometry.wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometry.Geometry.write">
<tt class="descname">write</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.geometry.Geometry.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the geometry parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; name of the file where to save the parameters</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.geometryRefinement">
<span id="geometryrefinement-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">geometryRefinement</span></tt> Module<a class="headerlink" href="#module-pyFAI.geometryRefinement" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.geometryRefinement.GeometryRefinement">
<em class="property">class </em><tt class="descclassname">pyFAI.geometryRefinement.</tt><tt class="descname">GeometryRefinement</tt><big>(</big><em>data</em>, <em>dist=1</em>, <em>poni1=None</em>, <em>poni2=None</em>, <em>rot1=0</em>, <em>rot2=0</em>, <em>rot3=0</em>, <em>pixel1=None</em>, <em>pixel2=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>wavelength=None</em>, <em>calibrant=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.azimuthalIntegrator.AzimuthalIntegrator" title="pyFAI.azimuthalIntegrator.AzimuthalIntegrator"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.azimuthalIntegrator.AzimuthalIntegrator</span></tt></a></p>
<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.anneal">
<tt class="descname">anneal</tt><big>(</big><em>maxiter=1000000</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.anneal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.calc_2th">
<tt class="descname">calc_2th</tt><big>(</big><em>rings</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.calc_2th" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rings</strong> &#8211; indices of the rings. starts at 0 and self.dSpacing should be long enough !!!</li>
<li><strong>wavelength</strong> &#8211; wavelength in meter</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.chi2">
<tt class="descname">chi2</tt><big>(</big><em>param=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.chi2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.chi2_wavelength">
<tt class="descname">chi2_wavelength</tt><big>(</big><em>param=None</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.chi2_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.confidence">
<tt class="descname">confidence</tt><big>(</big><em>with_rot=True</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.confidence" title="Permalink to this definition">¶</a></dt>
<dd><p>Confidence interval obtained from the second derivative of the error function
next to its minimum value.</p>
<p>Note the confidence interval increases with the number of points which is &#8220;surprizing&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>with_rot</strong> &#8211; if true include rot1 &amp; rot2 in the parameter set.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">std_dev, confidence</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.curve_fit">
<tt class="descname">curve_fit</tt><big>(</big><em>with_rot=True</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.curve_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Refine the geometry and provide confidence interval
Use curve_fit from scipy.optimize to not only refine the geometry (unconstrained fit)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>with_rot</strong> &#8211; include rotation intro error measurment</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">std_dev, confidence</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.dist_max">
<tt class="descname">dist_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.dist_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.dist_min">
<tt class="descname">dist_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.dist_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_dist_max">
<tt class="descname">get_dist_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_dist_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_dist_min">
<tt class="descname">get_dist_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_dist_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_poni1_max">
<tt class="descname">get_poni1_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_poni1_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_poni1_min">
<tt class="descname">get_poni1_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_poni1_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_poni2_max">
<tt class="descname">get_poni2_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_poni2_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_poni2_min">
<tt class="descname">get_poni2_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_poni2_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_rot1_max">
<tt class="descname">get_rot1_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_rot1_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_rot1_min">
<tt class="descname">get_rot1_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_rot1_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_rot2_max">
<tt class="descname">get_rot2_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_rot2_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_rot2_min">
<tt class="descname">get_rot2_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_rot2_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_rot3_max">
<tt class="descname">get_rot3_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_rot3_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_rot3_min">
<tt class="descname">get_rot3_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_rot3_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_wavelength_max">
<tt class="descname">get_wavelength_max</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_wavelength_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.get_wavelength_min">
<tt class="descname">get_wavelength_min</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.get_wavelength_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.guess_poni">
<tt class="descname">guess_poni</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.guess_poni" title="Permalink to this definition">¶</a></dt>
<dd><p>Poni can be guessed by the centroid of the ring with lowest 2Theta</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.poni1_max">
<tt class="descname">poni1_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.poni1_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.poni1_min">
<tt class="descname">poni1_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.poni1_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.poni2_max">
<tt class="descname">poni2_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.poni2_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.poni2_min">
<tt class="descname">poni2_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.poni2_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.refine1">
<tt class="descname">refine1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.refine1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.refine2">
<tt class="descname">refine2</tt><big>(</big><em>maxiter=1000000, fix=['wavelength']</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.refine2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.refine2_wavelength">
<tt class="descname">refine2_wavelength</tt><big>(</big><em>maxiter=1000000, fix=['wavelength']</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.refine2_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.residu1">
<tt class="descname">residu1</tt><big>(</big><em>param</em>, <em>d1</em>, <em>d2</em>, <em>rings</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.residu1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.residu1_wavelength">
<tt class="descname">residu1_wavelength</tt><big>(</big><em>param</em>, <em>d1</em>, <em>d2</em>, <em>rings</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.residu1_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.residu2">
<tt class="descname">residu2</tt><big>(</big><em>param</em>, <em>d1</em>, <em>d2</em>, <em>rings</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.residu2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.residu2_wavelength">
<tt class="descname">residu2_wavelength</tt><big>(</big><em>param</em>, <em>d1</em>, <em>d2</em>, <em>rings</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.residu2_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.residu2_wavelength_weighted">
<tt class="descname">residu2_wavelength_weighted</tt><big>(</big><em>param</em>, <em>d1</em>, <em>d2</em>, <em>rings</em>, <em>weight</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.residu2_wavelength_weighted" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.residu2_weighted">
<tt class="descname">residu2_weighted</tt><big>(</big><em>param</em>, <em>d1</em>, <em>d2</em>, <em>rings</em>, <em>weight</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.residu2_weighted" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.roca">
<tt class="descname">roca</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.roca" title="Permalink to this definition">¶</a></dt>
<dd><p>run roca to optimise the parameter set</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.rot1_max">
<tt class="descname">rot1_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.rot1_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.rot1_min">
<tt class="descname">rot1_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.rot1_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.rot2_max">
<tt class="descname">rot2_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.rot2_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.rot2_min">
<tt class="descname">rot2_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.rot2_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.rot3_max">
<tt class="descname">rot3_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.rot3_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.rot3_min">
<tt class="descname">rot3_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.rot3_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_dist_max">
<tt class="descname">set_dist_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_dist_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_dist_min">
<tt class="descname">set_dist_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_dist_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_poni1_max">
<tt class="descname">set_poni1_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_poni1_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_poni1_min">
<tt class="descname">set_poni1_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_poni1_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_poni2_max">
<tt class="descname">set_poni2_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_poni2_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_poni2_min">
<tt class="descname">set_poni2_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_poni2_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_rot1_max">
<tt class="descname">set_rot1_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_rot1_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_rot1_min">
<tt class="descname">set_rot1_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_rot1_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_rot2_max">
<tt class="descname">set_rot2_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_rot2_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_rot2_min">
<tt class="descname">set_rot2_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_rot2_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_rot3_max">
<tt class="descname">set_rot3_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_rot3_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_rot3_min">
<tt class="descname">set_rot3_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_rot3_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_tolerance">
<tt class="descname">set_tolerance</tt><big>(</big><em>value=10</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_tolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the tolerance for a refinement of the geometry; in percent of the original value</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>value</strong> &#8211; Tolerance as a percentage</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_wavelength_max">
<tt class="descname">set_wavelength_max</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_wavelength_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.set_wavelength_min">
<tt class="descname">set_wavelength_min</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.set_wavelength_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.simplex">
<tt class="descname">simplex</tt><big>(</big><em>maxiter=1000000</em><big>)</big><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.simplex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.wavelength_max">
<tt class="descname">wavelength_max</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.wavelength_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.geometryRefinement.GeometryRefinement.wavelength_min">
<tt class="descname">wavelength_min</tt><a class="headerlink" href="#pyFAI.geometryRefinement.GeometryRefinement.wavelength_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.detectors">
<span id="detectors-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">detectors</span></tt> Module<a class="headerlink" href="#module-pyFAI.detectors" title="Permalink to this headline">¶</a></h1>
<p>Description of all detectors with a factory to instantiate them</p>
<dl class="class">
<dt id="pyFAI.detectors.ADSC_Q210">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">ADSC_Q210</tt><big>(</big><em>pixel1=5.1e-05</em>, <em>pixel2=5.1e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ADSC_Q210" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC Quantum 210r detector, 2x2 chips</p>
<p>Informations from
<a class="reference external" href="http://www.adsc-xray.com/products/ccd-detectors/q210r-ccd-detector/">http://www.adsc-xray.com/products/ccd-detectors/q210r-ccd-detector/</a></p>
<p>Question: how are the gaps handled ?</p>
<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q210.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (4096, 4096)</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q210.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q210.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Quantum 210']</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q210.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q210.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q210.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.ADSC_Q270">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">ADSC_Q270</tt><big>(</big><em>pixel1=6.48e-05</em>, <em>pixel2=6.48e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ADSC_Q270" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC Quantum 270r detector, 2x2 chips</p>
<p>Informations from
<a class="reference external" href="http://www.adsc-xray.com/products/ccd-detectors/q270-ccd-detector/">http://www.adsc-xray.com/products/ccd-detectors/q270-ccd-detector/</a></p>
<p>Question: how are the gaps handled ?</p>
<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q270.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (4168, 4168)</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q270.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q270.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Quantum 270']</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q270.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q270.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q270.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.ADSC_Q315">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">ADSC_Q315</tt><big>(</big><em>pixel1=5.1e-05</em>, <em>pixel2=5.1e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ADSC_Q315" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC Quantum 315r detector, 3x3 chips</p>
<p>Informations from
<a class="reference external" href="http://www.adsc-xray.com/products/ccd-detectors/q315r-ccd-detector/">http://www.adsc-xray.com/products/ccd-detectors/q315r-ccd-detector/</a></p>
<p>Question: how are the gaps handled ?</p>
<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q315.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (6144, 6144)</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q315.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q315.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Quantum 315']</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q315.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q315.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q315.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.ADSC_Q4">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">ADSC_Q4</tt><big>(</big><em>pixel1=8.2e-05</em>, <em>pixel2=8.2e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ADSC_Q4" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC Quantum 4r detector, 2x2 chips</p>
<p>Informations from
<a class="reference external" href="http://proteincrystallography.org/detectors/adsc.php">http://proteincrystallography.org/detectors/adsc.php</a></p>
<p>Question: how are the gaps handled ?</p>
<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q4.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (2304, 2304)</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q4.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q4.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Quantum 4']</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q4.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ADSC_Q4.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.ADSC_Q4.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Aarhus">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Aarhus</tt><big>(</big><em>pixel1=2.5e-05</em>, <em>pixel2=2.5e-05</em>, <em>radius=0.3</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Aarhus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Cylindrical detector made of a bent imaging-plate.
Developped at the Danish university of Aarhus
r = 1.2m or 0.3m</p>
<p>The image has to be laid-out horizontally</p>
<p>Nota: the detector is bending towards the sample, hence reducing the sample-detector distance.
This is why z&lt;0 (or p3&lt;0)</p>
<p>TODO: update cython code for 3d detectors
use expand2d instead of outer product with ones</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Aarhus.IS_FLAT">
<tt class="descname">IS_FLAT</tt><em class="property"> = False</em><a class="headerlink" href="#pyFAI.detectors.Aarhus.IS_FLAT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Aarhus.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1000, 16000)</em><a class="headerlink" href="#pyFAI.detectors.Aarhus.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Aarhus.calc_cartesian_positions">
<tt class="descname">calc_cartesian_positions</tt><big>(</big><em>d1=None</em>, <em>d2=None</em>, <em>center=True</em>, <em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Aarhus.calc_cartesian_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of each pixel center in cartesian coordinate
and in meter of a couple of coordinates.
The half pixel offset is taken into account here !!!
Adapted to Nexus detector definition</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the Y pixel positions (slow dimension)</li>
<li><strong>d2</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the X pixel positions (fast dimension)</li>
<li><strong>center</strong> &#8211; retrieve the coordinate of the center of the pixel</li>
<li><strong>use_cython</strong> &#8211; set to False to test Python implementeation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">position in meter of the center of each pixels.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
<p>d1 and d2 must have the same shape, returned array will have
the same shape.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Aarhus.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Aarhus.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Aarhus.get_pixel_corners">
<tt class="descname">get_pixel_corners</tt><big>(</big><em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Aarhus.get_pixel_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of the corner of the pixels</p>
<p>This should be overwritten by class representing non-contiguous detector (Xpad, ...)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">4D array containing:
pixel index (slow dimension)
pixel index (fast dimension)
corner index (A, B, C or D), triangles or hexagons can be handled the same way
vertex position (z,y,x)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Apex2">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Apex2</tt><big>(</big><em>pixel1=0.00012</em>, <em>pixel2=0.00012</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Apex2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>BrukerApex2 detector</p>
<p>Actually a derivative from the Fairchild detector with higher binning</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Apex2.DEFAULT_PIXEL1">
<tt class="descname">DEFAULT_PIXEL1</tt><em class="property"> = 6e-05</em><a class="headerlink" href="#pyFAI.detectors.Apex2.DEFAULT_PIXEL1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Apex2.DEFAULT_PIXEL2">
<tt class="descname">DEFAULT_PIXEL2</tt><em class="property"> = 6e-05</em><a class="headerlink" href="#pyFAI.detectors.Apex2.DEFAULT_PIXEL2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Apex2.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1024, 1024)</em><a class="headerlink" href="#pyFAI.detectors.Apex2.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Apex2.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['ApexII', 'Bruker']</em><a class="headerlink" href="#pyFAI.detectors.Apex2.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Apex2.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Apex2.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Basler">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Basler</tt><big>(</big><em>pixel=3.75e-06</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Basler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Basler camera are simple CCD camara over GigaE</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Basler.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (966, 1296)</em><a class="headerlink" href="#pyFAI.detectors.Basler.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Basler.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['aca1300']</em><a class="headerlink" href="#pyFAI.detectors.Basler.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Basler.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Basler.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Detector">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Detector</tt><big>(</big><em>pixel1=None</em>, <em>pixel2=None</em>, <em>splineFile=None</em>, <em>max_shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Generic class representing a 2D detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Detector.API_VERSION">
<tt class="descname">API_VERSION</tt><em class="property"> = '1.0'</em><a class="headerlink" href="#pyFAI.detectors.Detector.API_VERSION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.IS_CONTIGUOUS">
<tt class="descname">IS_CONTIGUOUS</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Detector.IS_CONTIGUOUS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.IS_FLAT">
<tt class="descname">IS_FLAT</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Detector.IS_FLAT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.aliases">
<tt class="descname">aliases</tt><em class="property"> = []</em><a class="headerlink" href="#pyFAI.detectors.Detector.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.binning">
<tt class="descname">binning</tt><a class="headerlink" href="#pyFAI.detectors.Detector.binning" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.calc_cartesian_positions">
<tt class="descname">calc_cartesian_positions</tt><big>(</big><em>d1=None</em>, <em>d2=None</em>, <em>center=True</em>, <em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.calc_cartesian_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of each pixel center in cartesian coordinate
and in meter of a couple of coordinates.
The half pixel offset is taken into account here !!!
Adapted to Nexus detector definition</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the Y pixel positions (slow dimension)</li>
<li><strong>d2</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the X pixel positions (fast dimension)</li>
<li><strong>center</strong> &#8211; retrieve the coordinate of the center of the pixel, unless gives one corner</li>
<li><strong>use_cython</strong> &#8211; set to False to test Python implementation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">position in meter of the center of each pixels.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">3xndarray, the later being None if IS_FLAT</p>
</td>
</tr>
</tbody>
</table>
<p>d1 and d2 must have the same shape, returned array will have
the same shape.</p>
<p>pos_z is None for flat detectors</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Method calculating the mask for a given detector</p>
<p>Detectors with gaps should overwrite this method with
something actually calculating the mask!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the mask with valid pixel to 0</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">numpy ndarray of int8 or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pyFAI.detectors.Detector.factory">
<em class="property">classmethod </em><tt class="descname">factory</tt><big>(</big><em>name</em>, <em>config=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A kind of factory...</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of a detector</li>
<li><strong>config</strong> (<em>dict or JSON representation of it.</em>) &#8211; configuration of the detector</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">an instance of the right detector, set-up if possible</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">pyFAI.detectors.Detector</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = False</em><a class="headerlink" href="#pyFAI.detectors.Detector.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.getFit2D">
<tt class="descname">getFit2D</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.getFit2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to serialize the description of a detector using the Fit2d units</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">representation of the detector easy to serialize</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.getPyFAI">
<tt class="descname">getPyFAI</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.getPyFAI" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to serialize the description of a detector using the pyFAI way
with everything in S.I units.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">representation of the detector easy to serialize</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_binning">
<tt class="descname">get_binning</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_binning" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_mask">
<tt class="descname">get_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_maskfile">
<tt class="descname">get_maskfile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_name">
<tt class="descname">get_name</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a meaningful name for detector</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_pixel1">
<tt class="descname">get_pixel1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_pixel1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_pixel2">
<tt class="descname">get_pixel2</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_pixel2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_pixel_corners">
<tt class="descname">get_pixel_corners</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_pixel_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of the corner of the pixels</p>
<p>This should be overwritten by class representing non-contiguous detector (Xpad, ...)</p>
<p>Precision float32 is ok: precision of 1µm for a detector size of 1m</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">4D array containing:
pixel index (slow dimension)
pixel index (fast dimension)
corner index (A, B, C or D), triangles or hexagons can be handled the same way
vertex position (z,y,x)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.get_splineFile">
<tt class="descname">get_splineFile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.get_splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.guess_binning">
<tt class="descname">guess_binning</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.guess_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Guess the binning/mode depending on the image shape
:param data: 2-tuple with the shape of the image or the image with a .shape attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.mask">
<tt class="descname">mask</tt><a class="headerlink" href="#pyFAI.detectors.Detector.mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.maskfile">
<tt class="descname">maskfile</tt><a class="headerlink" href="#pyFAI.detectors.Detector.maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyFAI.detectors.Detector.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a meaningful name for detector</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.pixel1">
<tt class="descname">pixel1</tt><a class="headerlink" href="#pyFAI.detectors.Detector.pixel1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.pixel2">
<tt class="descname">pixel2</tt><a class="headerlink" href="#pyFAI.detectors.Detector.pixel2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.registry">
<tt class="descname">registry</tt><em class="property"> = {'imxpads10': &lt;class 'pyFAI.detectors.ImXPadS10'&gt;, 'rayonix_mx225hs': &lt;class 'pyFAI.detectors.RayonixMx225hs'&gt;, 'd5': &lt;class 'pyFAI.detectors.Xpad_flat'&gt;, 'thaleselectronics': &lt;class 'pyFAI.detectors.Pixium'&gt;, 'imxpad_s10': &lt;class 'pyFAI.detectors.ImXPadS10'&gt;, 'rayonix_mx340hs': &lt;class 'pyFAI.detectors.RayonixMx340hs'&gt;, 'condor': &lt;class 'pyFAI.detectors.Fairchild'&gt;, 'pilatuscdte2m': &lt;class 'pyFAI.detectors.PilatusCdTe2M'&gt;, 'oxd_titan': &lt;class 'pyFAI.detectors.Titan'&gt;, 'dexela_2923': &lt;class 'pyFAI.detectors.Dexela2923'&gt;, 'pilatus6m': &lt;class 'pyFAI.detectors.Pilatus6M'&gt;, 'titan_2k_x_2k': &lt;class 'pyFAI.detectors.Titan'&gt;, 'hf_262k': &lt;class 'pyFAI.detectors.HF_262k'&gt;, 'rayonixmx225': &lt;class 'pyFAI.detectors.RayonixMx225'&gt;, 'rayonixsx200': &lt;class 'pyFAI.detectors.RayonixSx200'&gt;, 'eiger4m': &lt;class 'pyFAI.detectors.Eiger4M'&gt;, 'rayonix_lx170': &lt;class 'pyFAI.detectors.RayonixLx170'&gt;, 'pilatuscdte300kw': &lt;class 'pyFAI.detectors.PilatusCdTe300kw'&gt;, 'pilatus300k': &lt;class 'pyFAI.detectors.Pilatus300k'&gt;, 'quantum_270': &lt;class 'pyFAI.detectors.ADSC_Q270'&gt;, 'rayonixmx300': &lt;class 'pyFAI.detectors.RayonixMx300'&gt;, 'pilatuscdte1m': &lt;class 'pyFAI.detectors.PilatusCdTe1M'&gt;, 'perkin': &lt;class 'pyFAI.detectors.Perkin'&gt;, 'rayonixmx340hs': &lt;class 'pyFAI.detectors.RayonixMx340hs'&gt;, 'rayonix_mx325': &lt;class 'pyFAI.detectors.RayonixMx325'&gt;, 'adsc_q270': &lt;class 'pyFAI.detectors.ADSC_Q270'&gt;, 'oxdtitan': &lt;class 'pyFAI.detectors.Titan'&gt;, 'dexela2923': &lt;class 'pyFAI.detectors.Dexela2923'&gt;, 'xpads540flat': &lt;class 'pyFAI.detectors.Xpad_flat'&gt;, 'titan': &lt;class 'pyFAI.detectors.Titan'&gt;, 'aarhus': &lt;class 'pyFAI.detectors.Aarhus'&gt;, 'rayonix_mx425hs': &lt;class 'pyFAI.detectors.RayonixMx425hs'&gt;, 'hf_4m': &lt;class 'pyFAI.detectors.HF_4M'&gt;, 'pilatuscdte300k': &lt;class 'pyFAI.detectors.PilatusCdTe300k'&gt;, 'thales_electronics': &lt;class 'pyFAI.detectors.Pixium'&gt;, 'rayonixmx300hs': &lt;class 'pyFAI.detectors.RayonixMx300hs'&gt;, 'pixium4700detector': &lt;class 'pyFAI.detectors.Pixium'&gt;, 'agilenttitan': &lt;class 'pyFAI.detectors.Titan'&gt;, 'rayonixsx165': &lt;class 'pyFAI.detectors.RayonixSx165'&gt;, 'pilatus100k': &lt;class 'pyFAI.detectors.Pilatus100k'&gt;, 'perkin_elmer': &lt;class 'pyFAI.detectors.Perkin'&gt;, 'aca1300': &lt;class 'pyFAI.detectors.Basler'&gt;, 'quantum315': &lt;class 'pyFAI.detectors.ADSC_Q315'&gt;, 'rayonixsx85hs': &lt;class 'pyFAI.detectors.RayonixSx85hs'&gt;, 'imxpads140': &lt;class 'pyFAI.detectors.ImXPadS140'&gt;, 'rayonix_mx170': &lt;class 'pyFAI.detectors.RayonixMx170'&gt;, 'pilatus300kw': &lt;class 'pyFAI.detectors.Pilatus300kw'&gt;, 'hf-130k': &lt;class 'pyFAI.detectors.HF_130K'&gt;, 'rayonixsx30hs': &lt;class 'pyFAI.detectors.RayonixSx30hs'&gt;, 'mar345': &lt;class 'pyFAI.detectors.Mar345'&gt;, 'perkindetector': &lt;class 'pyFAI.detectors.Perkin'&gt;, 'rayonix_lx255hs': &lt;class 'pyFAI.detectors.RayonixLx255'&gt;, 'rayonix_mx225': &lt;class 'pyFAI.detectors.RayonixMx225'&gt;, 'eiger1m': &lt;class 'pyFAI.detectors.Eiger1M'&gt;, 'mar_345': &lt;class 'pyFAI.detectors.Mar345'&gt;, 'pilatus2m': &lt;class 'pyFAI.detectors.Pilatus2M'&gt;, 'hf-1m': &lt;class 'pyFAI.detectors.HF_1M'&gt;, 'fairchildcondor486:90': &lt;class 'pyFAI.detectors.Fairchild'&gt;, 'rayonixmx170': &lt;class 'pyFAI.detectors.RayonixMx170'&gt;, 'mar165': &lt;class 'pyFAI.detectors.RayonixSx165'&gt;, 'hf_2m': &lt;class 'pyFAI.detectors.HF_2M'&gt;, 'titan2kx2k': &lt;class 'pyFAI.detectors.Titan'&gt;, 'rayonix_mx300hs': &lt;class 'pyFAI.detectors.RayonixMx300hs'&gt;, 'hf-9.4m': &lt;class 'pyFAI.detectors.HF_9M'&gt;, 'fairchild_condor_486:90': &lt;class 'pyFAI.detectors.Fairchild'&gt;, 'hf-262k': &lt;class 'pyFAI.detectors.HF_262k'&gt;, 'xpad_flat': &lt;class 'pyFAI.detectors.Xpad_flat'&gt;, 'quantum_315': &lt;class 'pyFAI.detectors.ADSC_Q315'&gt;, 'pi': &lt;class 'pyFAI.detectors.RaspberryPi'&gt;, 'pilatus1m': &lt;class 'pyFAI.detectors.Pilatus1M'&gt;, 'xpad_s540_flat': &lt;class 'pyFAI.detectors.Xpad_flat'&gt;, 'pixium_4700_detector': &lt;class 'pyFAI.detectors.Pixium'&gt;, 'basler': &lt;class 'pyFAI.detectors.Basler'&gt;, 'rayonix_sx200': &lt;class 'pyFAI.detectors.RayonixSx200'&gt;, 'quantum270': &lt;class 'pyFAI.detectors.ADSC_Q270'&gt;, 'perkin_detector': &lt;class 'pyFAI.detectors.Perkin'&gt;, 'mar3450': &lt;class 'pyFAI.detectors.Mar345'&gt;, 'pixium': &lt;class 'pyFAI.detectors.Pixium'&gt;, 'fairchild': &lt;class 'pyFAI.detectors.Fairchild'&gt;, 'raspberry': &lt;class 'pyFAI.detectors.RaspberryPi'&gt;, 'rayonixmx225hs': &lt;class 'pyFAI.detectors.RayonixMx225hs'&gt;, 'apexii': &lt;class 'pyFAI.detectors.Apex2'&gt;, 'quantum_210': &lt;class 'pyFAI.detectors.ADSC_Q210'&gt;, 'bruker': &lt;class 'pyFAI.detectors.Apex2'&gt;, 'raspberrypi': &lt;class 'pyFAI.detectors.RaspberryPi'&gt;, 'rayonixmx425hs': &lt;class 'pyFAI.detectors.RayonixMx425hs'&gt;, 'eiger16m': &lt;class 'pyFAI.detectors.Eiger16M'&gt;, 'imxpads70': &lt;class 'pyFAI.detectors.ImXPadS70'&gt;, 'rayonix_sx30hs': &lt;class 'pyFAI.detectors.RayonixSx30hs'&gt;, 'hf_130k': &lt;class 'pyFAI.detectors.HF_130K'&gt;, 'agilent_titan': &lt;class 'pyFAI.detectors.Titan'&gt;, 'rayonixlx255hs': &lt;class 'pyFAI.detectors.RayonixLx255'&gt;, 'rayonix133': &lt;class 'pyFAI.detectors.Rayonix133'&gt;, 'rayonix_lx255': &lt;class 'pyFAI.detectors.RayonixLx255'&gt;, 'perkinelmer': &lt;class 'pyFAI.detectors.Perkin'&gt;, 'rayonix': &lt;class 'pyFAI.detectors.Rayonix'&gt;, 'rayonix_sx165': &lt;class 'pyFAI.detectors.RayonixSx165'&gt;, 'adsc_q4': &lt;class 'pyFAI.detectors.ADSC_Q4'&gt;, 'rayonixlx255': &lt;class 'pyFAI.detectors.RayonixLx255'&gt;, 'apex2': &lt;class 'pyFAI.detectors.Apex2'&gt;, 'hf-2.4m': &lt;class 'pyFAI.detectors.HF_2M'&gt;, 'detector': &lt;class 'pyFAI.detectors.Detector'&gt;, 'imxpad_s140': &lt;class 'pyFAI.detectors.ImXPadS140'&gt;, 'adsc_q210': &lt;class 'pyFAI.detectors.ADSC_Q210'&gt;, 'quantum4': &lt;class 'pyFAI.detectors.ADSC_Q4'&gt;, 'rayonixlx170': &lt;class 'pyFAI.detectors.RayonixLx170'&gt;, 'hf_9m': &lt;class 'pyFAI.detectors.HF_9M'&gt;, 'quantum210': &lt;class 'pyFAI.detectors.ADSC_Q210'&gt;, 'hf_1m': &lt;class 'pyFAI.detectors.HF_1M'&gt;, 'mar133': &lt;class 'pyFAI.detectors.Rayonix133'&gt;, 'pilatus200k': &lt;class 'pyFAI.detectors.Pilatus200k'&gt;, 'imxpad_s70': &lt;class 'pyFAI.detectors.ImXPadS70'&gt;, 'adsc_q315': &lt;class 'pyFAI.detectors.ADSC_Q315'&gt;, 'rayonixmx325': &lt;class 'pyFAI.detectors.RayonixMx325'&gt;, 'rayonix_sx85hs': &lt;class 'pyFAI.detectors.RayonixSx85hs'&gt;, 'eiger9m': &lt;class 'pyFAI.detectors.Eiger9M'&gt;, 'hf-4m': &lt;class 'pyFAI.detectors.HF_4M'&gt;, 'rayonix_mx300': &lt;class 'pyFAI.detectors.RayonixMx300'&gt;, 'quantum_4': &lt;class 'pyFAI.detectors.ADSC_Q4'&gt;}</em><a class="headerlink" href="#pyFAI.detectors.Detector.registry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.save">
<tt class="descname">save</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves the detector description into a NeXus file, adapted from:
<a class="reference external" href="http://download.nexusformat.org/sphinx/classes/base_classes/NXdetector.html">http://download.nexusformat.org/sphinx/classes/base_classes/NXdetector.html</a>
Main differences:</p>
<blockquote>
<div><ul class="simple">
<li>differentiate pixel center from pixel corner offsets</li>
<li>store all offsets are ndarray according to slow/fast dimension (not x, y)</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; name of the file on the disc</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.setFit2D">
<tt class="descname">setFit2D</tt><big>(</big><em>**kwarg</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.setFit2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Twin method of getFit2D: setup a detector instance according to a description</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kwarg</strong> &#8211; dictionary containing pixel1, pixel2 and splineFile</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.setPyFAI">
<tt class="descname">setPyFAI</tt><big>(</big><em>**kwarg</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.setPyFAI" title="Permalink to this definition">¶</a></dt>
<dd><p>Twin method of getPyFAI: setup a detector instance according to a description</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kwarg</strong> &#8211; dictionary containing detector, pixel1, pixel2 and splineFile</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_binning">
<tt class="descname">set_binning</tt><big>(</big><em>bin_size=(1</em>, <em>1)</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the &#8220;binning&#8221; of the detector,</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bin_size</strong> (<em>(int, int)</em>) &#8211; binning as integer or tuple of integers.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_config">
<tt class="descname">set_config</tt><big>(</big><em>config</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the configuration of the detector. This implies:
- Orientation: integers
- Binning
- ROI</p>
<p>The configuration is either a python dictionary or a JSON string or a file containing this JSON configuration</p>
<p>keys in that dictionary are :
&#8220;orientation&#8221;: integers from 0 to 7
&#8220;binning&#8221;: integer or 2-tuple of integers. If only one integer is provided,
&#8220;offset&#8221;: coordinate (in pixels) of the start of the detector</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_dx">
<tt class="descname">set_dx</tt><big>(</big><em>dx=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_dx" title="Permalink to this definition">¶</a></dt>
<dd><p>set the pixel-wise displacement along X (dim2):</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_dy">
<tt class="descname">set_dy</tt><big>(</big><em>dy=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_dy" title="Permalink to this definition">¶</a></dt>
<dd><p>set the pixel-wise displacement along Y (dim1):</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_mask">
<tt class="descname">set_mask</tt><big>(</big><em>mask</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_maskfile">
<tt class="descname">set_maskfile</tt><big>(</big><em>maskfile</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_maskfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_pixel1">
<tt class="descname">set_pixel1</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_pixel1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_pixel2">
<tt class="descname">set_pixel2</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_pixel2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Detector.set_splineFile">
<tt class="descname">set_splineFile</tt><big>(</big><em>splineFile</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Detector.set_splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.splineFile">
<tt class="descname">splineFile</tt><a class="headerlink" href="#pyFAI.detectors.Detector.splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Detector.uniform_pixel">
<tt class="descname">uniform_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Detector.uniform_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.DetectorMeta">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">DetectorMeta</tt><big>(</big><em>name</em>, <em>bases</em>, <em>dct</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.DetectorMeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">type</span></tt></p>
<p>Metaclass used to register all detector classes inheriting from Detector</p>
</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Dexela2923">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Dexela2923</tt><big>(</big><em>pixel1=7.5e-05</em>, <em>pixel2=7.5e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Dexela2923" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Dexela CMOS family detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Dexela2923.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (3888, 3072)</em><a class="headerlink" href="#pyFAI.detectors.Dexela2923.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Dexela2923.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Dexela 2923']</em><a class="headerlink" href="#pyFAI.detectors.Dexela2923.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Dexela2923.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Dexela2923.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Eiger">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Eiger</tt><big>(</big><em>pixel1=7.5e-05</em>, <em>pixel2=7.5e-05</em>, <em>max_shape=None</em>, <em>module_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Eiger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Eiger detector: generic description containing mask algorithm</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Eiger.MODULE_GAP">
<tt class="descname">MODULE_GAP</tt><em class="property"> = (37, 10)</em><a class="headerlink" href="#pyFAI.detectors.Eiger.MODULE_GAP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Eiger.MODULE_SIZE">
<tt class="descname">MODULE_SIZE</tt><em class="property"> = (514, 1030)</em><a class="headerlink" href="#pyFAI.detectors.Eiger.MODULE_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Eiger.calc_cartesian_positions">
<tt class="descname">calc_cartesian_positions</tt><big>(</big><em>d1=None</em>, <em>d2=None</em>, <em>center=True</em>, <em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Eiger.calc_cartesian_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of each pixel center in cartesian coordinate
and in meter of a couple of coordinates.
The half pixel offset is taken into account here !!!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the Y pixel positions (slow dimension)</li>
<li><strong>d2</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the X pixel positions (fast dimension)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">p1, p2 position in meter of the center of each pixels.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2-tuple of numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
<p>d1 and d2 must have the same shape, returned array will have
the same shape.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Eiger.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Eiger.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a generic mask for Pilatus detectors...</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Eiger.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Eiger.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Eiger16M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Eiger16M</tt><big>(</big><em>pixel1=7.5e-05</em>, <em>pixel2=7.5e-05</em>, <em>max_shape=None</em>, <em>module_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Eiger16M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Eiger" title="pyFAI.detectors.Eiger"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Eiger</span></tt></a></p>
<p>Eiger 16M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Eiger16M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (4371, 4150)</em><a class="headerlink" href="#pyFAI.detectors.Eiger16M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Eiger1M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Eiger1M</tt><big>(</big><em>pixel1=7.5e-05</em>, <em>pixel2=7.5e-05</em>, <em>max_shape=None</em>, <em>module_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Eiger1M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Eiger" title="pyFAI.detectors.Eiger"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Eiger</span></tt></a></p>
<p>Eiger 1M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Eiger1M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1065, 1030)</em><a class="headerlink" href="#pyFAI.detectors.Eiger1M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Eiger4M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Eiger4M</tt><big>(</big><em>pixel1=7.5e-05</em>, <em>pixel2=7.5e-05</em>, <em>max_shape=None</em>, <em>module_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Eiger4M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Eiger" title="pyFAI.detectors.Eiger"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Eiger</span></tt></a></p>
<p>Eiger 4M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Eiger4M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (2167, 2070)</em><a class="headerlink" href="#pyFAI.detectors.Eiger4M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Eiger9M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Eiger9M</tt><big>(</big><em>pixel1=7.5e-05</em>, <em>pixel2=7.5e-05</em>, <em>max_shape=None</em>, <em>module_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Eiger9M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Eiger" title="pyFAI.detectors.Eiger"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Eiger</span></tt></a></p>
<p>Eiger 9M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Eiger9M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (3269, 3110)</em><a class="headerlink" href="#pyFAI.detectors.Eiger9M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.FReLoN">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">FReLoN</tt><big>(</big><em>splineFile=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.FReLoN" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>FReLoN detector:
The spline is mandatory to correct for geometric distortion of the taper</p>
<p>TODO: create automatically a mask that removes pixels out of the &#8220;valid reagion&#8221;</p>
<dl class="method">
<dt id="pyFAI.detectors.FReLoN.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.FReLoN.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a generic mask for Frelon detectors...
All pixels which (center) turns to be out of the valid region are by default discarded</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Fairchild">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Fairchild</tt><big>(</big><em>pixel1=1.5e-05</em>, <em>pixel2=1.5e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Fairchild" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Fairchild Condor 486:90 detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Fairchild.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (4096, 4096)</em><a class="headerlink" href="#pyFAI.detectors.Fairchild.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Fairchild.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Fairchild', 'Condor', 'Fairchild Condor 486:90']</em><a class="headerlink" href="#pyFAI.detectors.Fairchild.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Fairchild.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Fairchild.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Fairchild.uniform_pixel">
<tt class="descname">uniform_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Fairchild.uniform_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.HF_130K">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">HF_130K</tt><big>(</big><em>pixel1=0.00015</em>, <em>pixel2=0.00015</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.HF_130K" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC HF-130K 1 module</p>
<p>Informations from
<a class="reference external" href="http://www.adsc-xray.com/products/pixel-array-detectors/hf-130k/">http://www.adsc-xray.com/products/pixel-array-detectors/hf-130k/</a></p>
<dl class="attribute">
<dt id="pyFAI.detectors.HF_130K.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (256, 512)</em><a class="headerlink" href="#pyFAI.detectors.HF_130K.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_130K.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['HF-130k']</em><a class="headerlink" href="#pyFAI.detectors.HF_130K.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_130K.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.HF_130K.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.HF_1M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">HF_1M</tt><big>(</big><em>pixel1=0.00015</em>, <em>pixel2=0.00015</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.HF_1M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC HF-1M 2x4 modules</p>
<p>Informations from
<a class="reference external" href="http://www.adsc-xray.com/products/pixel-array-detectors/hf-1m/">http://www.adsc-xray.com/products/pixel-array-detectors/hf-1m/</a></p>
<p>Nota: gaps between modules is not known/described</p>
<dl class="attribute">
<dt id="pyFAI.detectors.HF_1M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1024, 1024)</em><a class="headerlink" href="#pyFAI.detectors.HF_1M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_1M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['HF-1M']</em><a class="headerlink" href="#pyFAI.detectors.HF_1M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_1M.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.HF_1M.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.HF_262k">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">HF_262k</tt><big>(</big><em>pixel1=0.00015</em>, <em>pixel2=0.00015</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.HF_262k" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC HF-262k 2 module</p>
<p>Informations from
<a class="reference external" href="http://www.adsc-xray.com/products/pixel-array-detectors/hf-262k/">http://www.adsc-xray.com/products/pixel-array-detectors/hf-262k/</a></p>
<p>Nota: gaps between modules is not known/described</p>
<dl class="attribute">
<dt id="pyFAI.detectors.HF_262k.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (512, 512)</em><a class="headerlink" href="#pyFAI.detectors.HF_262k.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_262k.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['HF-262k']</em><a class="headerlink" href="#pyFAI.detectors.HF_262k.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_262k.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.HF_262k.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.HF_2M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">HF_2M</tt><big>(</big><em>pixel1=0.00015</em>, <em>pixel2=0.00015</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.HF_2M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC HF-1M 3x6 modules</p>
<p>Informations from
<a class="reference external" href="http://www.adsc-xray.com/products/pixel-array-detectors/hf-2.4m/">http://www.adsc-xray.com/products/pixel-array-detectors/hf-2.4m/</a></p>
<p>Nota: gaps between modules is not known/described</p>
<dl class="attribute">
<dt id="pyFAI.detectors.HF_2M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1536, 1536)</em><a class="headerlink" href="#pyFAI.detectors.HF_2M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_2M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['HF-2.4M']</em><a class="headerlink" href="#pyFAI.detectors.HF_2M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_2M.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.HF_2M.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.HF_4M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">HF_4M</tt><big>(</big><em>pixel1=0.00015</em>, <em>pixel2=0.00015</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.HF_4M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC HF-4M 4x8 modules</p>
<p>Informations from
<a class="reference external" href="http://www.adsc-xray.com/products/pixel-array-detectors/hf-4m/">http://www.adsc-xray.com/products/pixel-array-detectors/hf-4m/</a></p>
<dl class="attribute">
<dt id="pyFAI.detectors.HF_4M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (2048, 2048)</em><a class="headerlink" href="#pyFAI.detectors.HF_4M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_4M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['HF-4M']</em><a class="headerlink" href="#pyFAI.detectors.HF_4M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_4M.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.HF_4M.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.HF_9M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">HF_9M</tt><big>(</big><em>pixel1=0.00015</em>, <em>pixel2=0.00015</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.HF_9M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ADSC HF-130K 1 module</p>
<p>Informations from
<a class="reference external" href="http://www.adsc-xray.com/products/pixel-array-detectors/hf-9-4m/">http://www.adsc-xray.com/products/pixel-array-detectors/hf-9-4m/</a></p>
<dl class="attribute">
<dt id="pyFAI.detectors.HF_9M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (3072, 3072)</em><a class="headerlink" href="#pyFAI.detectors.HF_9M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_9M.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['HF-9.4M']</em><a class="headerlink" href="#pyFAI.detectors.HF_9M.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.HF_9M.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.HF_9M.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.ImXPadS10">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">ImXPadS10</tt><big>(</big><em>pixel1=0.00013</em>, <em>pixel2=0.00013</em>, <em>max_shape=None</em>, <em>module_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ImXPadS10" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>ImXPad detector: ImXPad s10 detector with 1x1modules</p>
<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS10.BORDER_SIZE_RELATIVE">
<tt class="descname">BORDER_SIZE_RELATIVE</tt><em class="property"> = 2.5</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.BORDER_SIZE_RELATIVE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS10.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (120, 80)</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS10.MODULE_SIZE">
<tt class="descname">MODULE_SIZE</tt><em class="property"> = (120, 80)</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.MODULE_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS10.PIXEL_SIZE">
<tt class="descname">PIXEL_SIZE</tt><em class="property"> = (0.00013, 0.00013)</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS10.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Imxpad S10']</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.ImXPadS10.calc_cartesian_positions">
<tt class="descname">calc_cartesian_positions</tt><big>(</big><em>d1=None</em>, <em>d2=None</em>, <em>center=True</em>, <em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.calc_cartesian_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of each pixel center in cartesian coordinate
and in meter of a couple of coordinates.
The half pixel offset is taken into account here !!!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the Y pixel positions (slow dimension)</li>
<li><strong>d2</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the X pixel positions (fast dimension)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">position in meter of the center of each pixels.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
<p>d1 and d2 must have the same shape, returned array will have
the same shape.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.ImXPadS10.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the mask</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.ImXPadS10.calc_pixels_edges">
<tt class="descname">calc_pixels_edges</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.calc_pixels_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of the pixel edges</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS10.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.ImXPadS10.get_pixel_corners">
<tt class="descname">get_pixel_corners</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.get_pixel_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of the corner of the pixels</p>
<p>This should be overwritten by class representing non-contiguous detector (Xpad, ...)</p>
<p>Precision float32 is ok: precision of 1µm for a detector size of 1m</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">4D array containing:
pixel index (slow dimension)
pixel index (fast dimension)
corner index (A, B, C or D), triangles or hexagons can be handled the same way
vertex position (z,y,x)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS10.uniform_pixel">
<tt class="descname">uniform_pixel</tt><em class="property"> = False</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS10.uniform_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.ImXPadS140">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">ImXPadS140</tt><big>(</big><em>pixel1=0.00013</em>, <em>pixel2=0.00013</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ImXPadS140" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.ImXPadS10" title="pyFAI.detectors.ImXPadS10"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.ImXPadS10</span></tt></a></p>
<p>ImXPad detector: ImXPad s140 detector with 2x7modules</p>
<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS140.BORDER_PIXEL_SIZE_RELATIVE">
<tt class="descname">BORDER_PIXEL_SIZE_RELATIVE</tt><em class="property"> = 2.5</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS140.BORDER_PIXEL_SIZE_RELATIVE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS140.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (240, 560)</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS140.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS140.MODULE_SIZE">
<tt class="descname">MODULE_SIZE</tt><em class="property"> = (120, 80)</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS140.MODULE_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS140.PIXEL_SIZE">
<tt class="descname">PIXEL_SIZE</tt><em class="property"> = (0.00013, 0.00013)</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS140.PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS140.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Imxpad S140']</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS140.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS140.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS140.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.ImXPadS70">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">ImXPadS70</tt><big>(</big><em>pixel1=0.00013</em>, <em>pixel2=0.00013</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.ImXPadS70" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.ImXPadS10" title="pyFAI.detectors.ImXPadS10"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.ImXPadS10</span></tt></a></p>
<p>ImXPad detector: ImXPad s70 detector with 1x7modules</p>
<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS70.BORDER_SIZE_RELATIVE">
<tt class="descname">BORDER_SIZE_RELATIVE</tt><em class="property"> = 2.5</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS70.BORDER_SIZE_RELATIVE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS70.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (120, 560)</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS70.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS70.MODULE_SIZE">
<tt class="descname">MODULE_SIZE</tt><em class="property"> = (120, 80)</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS70.MODULE_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS70.PIXEL_EDGES">
<tt class="descname">PIXEL_EDGES</tt><em class="property"> = None</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS70.PIXEL_EDGES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS70.PIXEL_SIZE">
<tt class="descname">PIXEL_SIZE</tt><em class="property"> = (0.00013, 0.00013)</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS70.PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS70.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Imxpad S70']</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS70.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.ImXPadS70.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.ImXPadS70.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Mar345">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Mar345</tt><big>(</big><em>pixel1=0.0001</em>, <em>pixel2=0.0001</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Mar345" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Mar345 Imaging plate detector</p>
<p>In this detector, pixels are always square
The valid image size are 2300, 2000, 1600, 1200, 3450, 3000, 2400, 1800</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Mar345.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (3450, 3450)</em><a class="headerlink" href="#pyFAI.detectors.Mar345.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Mar345.VALID_SIZE">
<tt class="descname">VALID_SIZE</tt><em class="property"> = {2000: 0.00015, 1600: 0.00015, 3000: 0.0001, 2400: 0.0001, 3450: 0.0001, 1200: 0.00015, 2300: 0.00015, 1800: 0.0001}</em><a class="headerlink" href="#pyFAI.detectors.Mar345.VALID_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Mar345.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['MAR 345', 'Mar3450']</em><a class="headerlink" href="#pyFAI.detectors.Mar345.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Mar345.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Mar345.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Mar345.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Mar345.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Mar345.guess_binning">
<tt class="descname">guess_binning</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Mar345.guess_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Guess the binning/mode depending on the image shape
:param data: 2-tuple with the shape of the image or the image with a .shape attribute.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.NexusDetector">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">NexusDetector</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.NexusDetector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Class representing a 2D detector loaded from a NeXus file</p>
<dl class="method">
<dt id="pyFAI.detectors.NexusDetector.getFit2D">
<tt class="descname">getFit2D</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.NexusDetector.getFit2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to serialize the description of a detector using the Fit2d units</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">representation of the detector easy to serialize</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.NexusDetector.getPyFAI">
<tt class="descname">getPyFAI</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.NexusDetector.getPyFAI" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to serialize the description of a detector using the pyFAI way
with everything in S.I units.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">representation of the detector easy to serialize</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.NexusDetector.load">
<tt class="descname">load</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.NexusDetector.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the detector description from a NeXus file, adapted from:
<a class="reference external" href="http://download.nexusformat.org/sphinx/classes/base_classes/NXdetector.html">http://download.nexusformat.org/sphinx/classes/base_classes/NXdetector.html</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; name of the file on the disk</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pyFAI.detectors.NexusDetector.sload">
<em class="property">classmethod </em><tt class="descname">sload</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.NexusDetector.sload" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate the detector description from a NeXus file, adapted from:
<a class="reference external" href="http://download.nexusformat.org/sphinx/classes/base_classes/NXdetector.html">http://download.nexusformat.org/sphinx/classes/base_classes/NXdetector.html</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; name of the file on the disk</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Detector instance</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Perkin">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Perkin</tt><big>(</big><em>pixel1=0.0002</em>, <em>pixel2=0.0002</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Perkin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Perkin detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Perkin.DEFAULT_PIXEL1">
<tt class="descname">DEFAULT_PIXEL1</tt><em class="property"> = 0.0002</em><a class="headerlink" href="#pyFAI.detectors.Perkin.DEFAULT_PIXEL1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Perkin.DEFAULT_PIXEL2">
<tt class="descname">DEFAULT_PIXEL2</tt><em class="property"> = 0.0002</em><a class="headerlink" href="#pyFAI.detectors.Perkin.DEFAULT_PIXEL2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Perkin.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (4096, 4096)</em><a class="headerlink" href="#pyFAI.detectors.Perkin.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Perkin.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Perkin detector', 'Perkin Elmer']</em><a class="headerlink" href="#pyFAI.detectors.Perkin.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Perkin.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Perkin.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Pilatus detector: generic description containing mask algorithm</p>
<p>Sub-classed by Pilatus1M, Pilatus2M and Pilatus6M</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus.MODULE_GAP">
<tt class="descname">MODULE_GAP</tt><em class="property"> = (17, 7)</em><a class="headerlink" href="#pyFAI.detectors.Pilatus.MODULE_GAP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus.MODULE_SIZE">
<tt class="descname">MODULE_SIZE</tt><em class="property"> = (195, 487)</em><a class="headerlink" href="#pyFAI.detectors.Pilatus.MODULE_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Pilatus.calc_cartesian_positions">
<tt class="descname">calc_cartesian_positions</tt><big>(</big><em>d1=None</em>, <em>d2=None</em>, <em>center=True</em>, <em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus.calc_cartesian_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of each pixel center in cartesian coordinate
and in meter of a couple of coordinates.
The half pixel offset is taken into account here !!!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the Y pixel positions (slow dimension)</li>
<li><strong>d2</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the X pixel positions (fast dimension)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">position in meter of the center of each pixels.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
<p>d1 and d2 must have the same shape, returned array will have
the same shape.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Pilatus.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a generic mask for Pilatus detectors...</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Pilatus.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Pilatus.get_splineFile">
<tt class="descname">get_splineFile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus.get_splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Pilatus.set_splineFile">
<tt class="descname">set_splineFile</tt><big>(</big><em>splineFile=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus.set_splineFile" title="Permalink to this definition">¶</a></dt>
<dd><p>In this case splinefile is a couple filenames</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus.splineFile">
<tt class="descname">splineFile</tt><a class="headerlink" href="#pyFAI.detectors.Pilatus.splineFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus100k">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus100k</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus100k" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus 100k detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus100k.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (195, 487)</em><a class="headerlink" href="#pyFAI.detectors.Pilatus100k.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus1M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus1M</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus1M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus 1M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus1M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1043, 981)</em><a class="headerlink" href="#pyFAI.detectors.Pilatus1M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus200k">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus200k</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus200k" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus 200k detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus200k.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (407, 487)</em><a class="headerlink" href="#pyFAI.detectors.Pilatus200k.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus2M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus2M</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus2M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus 2M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus2M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1679, 1475)</em><a class="headerlink" href="#pyFAI.detectors.Pilatus2M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus300k">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus300k</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus300k" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus 300k detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus300k.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (619, 487)</em><a class="headerlink" href="#pyFAI.detectors.Pilatus300k.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus300kw">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus300kw</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus300kw" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus 300k-wide detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus300kw.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (195, 1475)</em><a class="headerlink" href="#pyFAI.detectors.Pilatus300kw.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pilatus6M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pilatus6M</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pilatus6M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus 6M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Pilatus6M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (2527, 2463)</em><a class="headerlink" href="#pyFAI.detectors.Pilatus6M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.PilatusCdTe">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">PilatusCdTe</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Pilatus" title="pyFAI.detectors.Pilatus"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Pilatus</span></tt></a></p>
<p>Pilatus CdTe detector: Like the Pilatus with an extra 3 pixel in the middle
of every module (vertically)</p>
<dl class="method">
<dt id="pyFAI.detectors.PilatusCdTe.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a generic mask for Pilatus detectors...</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.PilatusCdTe1M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">PilatusCdTe1M</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe1M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.PilatusCdTe" title="pyFAI.detectors.PilatusCdTe"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.PilatusCdTe</span></tt></a></p>
<p>Pilatus CdTe 1M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.PilatusCdTe1M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1043, 981)</em><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe1M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.PilatusCdTe2M">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">PilatusCdTe2M</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe2M" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.PilatusCdTe" title="pyFAI.detectors.PilatusCdTe"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.PilatusCdTe</span></tt></a></p>
<p>Pilatus CdTe 2M detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.PilatusCdTe2M.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1679, 1475)</em><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe2M.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.PilatusCdTe300k">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">PilatusCdTe300k</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe300k" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.PilatusCdTe" title="pyFAI.detectors.PilatusCdTe"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.PilatusCdTe</span></tt></a></p>
<p>Pilatus CdTe 300k detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.PilatusCdTe300k.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (619, 487)</em><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe300k.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.PilatusCdTe300kw">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">PilatusCdTe300kw</tt><big>(</big><em>pixel1=0.000172</em>, <em>pixel2=0.000172</em>, <em>max_shape=None</em>, <em>module_size=None</em>, <em>x_offset_file=None</em>, <em>y_offset_file=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe300kw" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.PilatusCdTe" title="pyFAI.detectors.PilatusCdTe"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.PilatusCdTe</span></tt></a></p>
<p>Pilatus CdTe 300k-wide detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.PilatusCdTe300kw.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (195, 1475)</em><a class="headerlink" href="#pyFAI.detectors.PilatusCdTe300kw.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Pixium">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Pixium</tt><big>(</big><em>pixel1=0.000308</em>, <em>pixel2=0.000308</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Pixium" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>PIXIUM 4700 detector</p>
<p>High energy X ray diffraction using the Pixium 4700 flat panel detector
J E Daniels, M Drakopoulos, et al.; Journal of Synchrotron Radiation 16(Pt 4):463-8 · August 2009</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Pixium.DEFAULT_PIXEL1">
<tt class="descname">DEFAULT_PIXEL1</tt><em class="property"> = 0.000154</em><a class="headerlink" href="#pyFAI.detectors.Pixium.DEFAULT_PIXEL1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pixium.DEFAULT_PIXEL2">
<tt class="descname">DEFAULT_PIXEL2</tt><em class="property"> = 0.000154</em><a class="headerlink" href="#pyFAI.detectors.Pixium.DEFAULT_PIXEL2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pixium.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1910, 2480)</em><a class="headerlink" href="#pyFAI.detectors.Pixium.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pixium.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Pixium 4700 detector', 'Thales Electronics']</em><a class="headerlink" href="#pyFAI.detectors.Pixium.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Pixium.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Pixium.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RaspberryPi">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RaspberryPi</tt><big>(</big><em>pixel1=1.4e-06</em>, <em>pixel2=1.4e-06</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RaspberryPi" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>5 Mpix detector from Raspberry Pi</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RaspberryPi.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1944, 2592)</em><a class="headerlink" href="#pyFAI.detectors.RaspberryPi.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RaspberryPi.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Raspberry', 'Pi']</em><a class="headerlink" href="#pyFAI.detectors.RaspberryPi.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RaspberryPi.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.RaspberryPi.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Rayonix">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Rayonix</tt><big>(</big><em>pixel1=3.2e-05</em>, <em>pixel2=3.2e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Rayonix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<dl class="attribute">
<dt id="pyFAI.detectors.Rayonix.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 3.2e-05}</em><a class="headerlink" href="#pyFAI.detectors.Rayonix.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Rayonix.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (4096, 4096)</em><a class="headerlink" href="#pyFAI.detectors.Rayonix.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Rayonix.binning">
<tt class="descname">binning</tt><a class="headerlink" href="#pyFAI.detectors.Rayonix.binning" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Rayonix.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Rayonix.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Rayonix.get_binning">
<tt class="descname">get_binning</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Rayonix.get_binning" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Rayonix.guess_binning">
<tt class="descname">guess_binning</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Rayonix.guess_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Guess the binning/mode depending on the image shape
:param data: 2-tuple with the shape of the image or the image with a .shape attribute.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Rayonix.set_binning">
<tt class="descname">set_binning</tt><big>(</big><em>bin_size=(1</em>, <em>1)</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Rayonix.set_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the &#8220;binning&#8221; of the detector,</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bin_size</strong> (<em>int or (int, int)</em>) &#8211; set the binning of the detector</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Rayonix133">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Rayonix133</tt><big>(</big><em>pixel1=6.4e-05</em>, <em>pixel2=6.4e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Rayonix133" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix 133 2D CCD detector detector also known as mar133</p>
<p>Personnal communication from M. Blum</p>
<p>What should be the default binning factor for those cameras ?</p>
<p>Circular detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Rayonix133.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {8: 0.000256, 1: 3.2e-05, 2: 6.4e-05, 4: 0.000128}</em><a class="headerlink" href="#pyFAI.detectors.Rayonix133.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Rayonix133.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (4096, 4096)</em><a class="headerlink" href="#pyFAI.detectors.Rayonix133.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Rayonix133.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['MAR133']</em><a class="headerlink" href="#pyFAI.detectors.Rayonix133.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Rayonix133.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Rayonix133.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Circular mask</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Rayonix133.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Rayonix133.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixLx170">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixLx170</tt><big>(</big><em>pixel1=4.42708e-05</em>, <em>pixel2=4.42708e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixLx170" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix lx170 2d CCD Detector (2x1 CCDs).</p>
<p>Nota: this is the same for lx170hs</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixLx170.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 4.42708e-05, 2: 8.85417e-05, 3: 0.0001328125, 4: 0.0001770833, 5: 0.0002213542, 6: 0.000265625, 8: 0.0003541667, 10: 0.0004427083}</em><a class="headerlink" href="#pyFAI.detectors.RayonixLx170.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixLx170.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1920, 3840)</em><a class="headerlink" href="#pyFAI.detectors.RayonixLx170.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixLx170.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix lx170']</em><a class="headerlink" href="#pyFAI.detectors.RayonixLx170.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixLx170.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.RayonixLx170.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixLx255">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixLx255</tt><big>(</big><em>pixel1=4.42708e-05</em>, <em>pixel2=4.42708e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixLx255" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix lx255 2d Detector (3x1 CCDs)</p>
<p>Nota: this detector is also called lx255hs</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixLx255.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 4.42708e-05, 2: 8.85417e-05, 3: 0.0001328125, 4: 0.0001770833, 5: 0.0002213542, 6: 0.000265625, 8: 0.0003541667, 10: 0.0004427083}</em><a class="headerlink" href="#pyFAI.detectors.RayonixLx255.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixLx255.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1920, 5760)</em><a class="headerlink" href="#pyFAI.detectors.RayonixLx255.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixLx255.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix lx255', 'Rayonix lx255hs']</em><a class="headerlink" href="#pyFAI.detectors.RayonixLx255.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixMx170">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixMx170</tt><big>(</big><em>pixel1=4.42708e-05</em>, <em>pixel2=4.42708e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx170" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix mx170 2d CCD Detector (2x2 CCDs).</p>
<p>Nota: this is the same for mx170hs</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx170.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 4.42708e-05, 2: 8.85417e-05, 3: 0.0001328125, 4: 0.0001770833, 5: 0.0002213542, 6: 0.000265625, 8: 0.0003541667, 10: 0.0004427083}</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx170.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx170.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (3840, 3840)</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx170.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx170.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix mx170']</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx170.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixMx225">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixMx225</tt><big>(</big><em>pixel1=7.3242e-05</em>, <em>pixel2=7.3242e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx225" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix mx225 2D CCD detector detector</p>
<p>Nota: this is the same definition for mx225he
Personnal communication from M. Blum</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx225.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {8: 0.000292969, 1: 3.6621e-05, 2: 7.3242e-05, 3: 0.000109971, 4: 0.000146484}</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx225.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx225.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (6144, 6144)</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx225.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx225.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix mx225']</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx225.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx225.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx225.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixMx225hs">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixMx225hs</tt><big>(</big><em>pixel1=7.8125e-05</em>, <em>pixel2=7.8125e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx225hs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix mx225hs 2D CCD detector detector</p>
<p>Pixel size from a personnal communication from M. Blum</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx225hs.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 3.90625e-05, 2: 7.8125e-05, 3: 0.0001171875, 4: 0.00015625, 5: 0.0001953125, 6: 0.000234375, 8: 0.0003125, 10: 0.000390625}</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx225hs.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx225hs.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (5760, 5760)</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx225hs.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx225hs.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix mx225hs']</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx225hs.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx225hs.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx225hs.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixMx300">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixMx300</tt><big>(</big><em>pixel1=7.3242e-05</em>, <em>pixel2=7.3242e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx300" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix mx300 2D detector (4x4 CCDs)</p>
<p>Pixel size from a personnal communication from M. Blum</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx300.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {8: 0.000292969, 1: 3.6621e-05, 2: 7.3242e-05, 3: 0.000109971, 4: 0.000146484}</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx300.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx300.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (8192, 8192)</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx300.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx300.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix mx300']</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx300.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx300.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx300.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixMx300hs">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixMx300hs</tt><big>(</big><em>pixel1=7.8125e-05</em>, <em>pixel2=7.8125e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx300hs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix mx300hs 2D detector (4x4 CCDs)</p>
<p>Pixel size from a personnal communication from M. Blum</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx300hs.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 3.90625e-05, 2: 7.8125e-05, 3: 0.0001171875, 4: 0.00015625, 5: 0.0001953125, 6: 0.000234375, 8: 0.0003125, 10: 0.000390625}</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx300hs.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx300hs.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (7680, 7680)</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx300hs.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx300hs.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix mx300hs']</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx300hs.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx300hs.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx300hs.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixMx325">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixMx325</tt><big>(</big><em>pixel1=7.9346e-05</em>, <em>pixel2=7.9346e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx325" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix mx325 and mx325he 2D detector (4x4 CCD chips)</p>
<p>Pixel size from a personnal communication from M. Blum</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx325.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {8: 0.000317383, 1: 3.9673e-05, 2: 7.9346e-05, 3: 0.000119135, 4: 0.000158691}</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx325.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx325.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (8192, 8192)</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx325.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx325.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix mx325']</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx325.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixMx340hs">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixMx340hs</tt><big>(</big><em>pixel1=8.85417e-05</em>, <em>pixel2=8.85417e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx340hs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix mx340hs 2D detector (4x4 CCDs)</p>
<p>Pixel size from a personnal communication from M. Blum</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx340hs.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 4.42708e-05, 2: 8.85417e-05, 3: 0.0001328125, 4: 0.0001770833, 5: 0.0002213542, 6: 0.000265625, 8: 0.0003541667, 10: 0.0004427083}</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx340hs.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx340hs.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (7680, 7680)</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx340hs.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx340hs.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix mx340hs']</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx340hs.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx340hs.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx340hs.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixMx425hs">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixMx425hs</tt><big>(</big><em>pixel1=4.42708e-05</em>, <em>pixel2=4.42708e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixMx425hs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix mx425hs 2D CCD camera (5x5 CCD chip)</p>
<p>Pixel size from a personnal communication from M. Blum</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx425hs.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 4.42708e-05, 2: 8.85417e-05, 3: 0.0001328125, 4: 0.0001770833, 5: 0.0002213542, 6: 0.000265625, 8: 0.0003541667, 10: 0.0004427083}</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx425hs.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx425hs.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (9600, 9600)</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx425hs.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixMx425hs.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix mx425hs']</em><a class="headerlink" href="#pyFAI.detectors.RayonixMx425hs.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixSx165">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixSx165</tt><big>(</big><em>pixel1=3.95e-05</em>, <em>pixel2=3.95e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixSx165" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix sx165 2d Detector also known as MAR165.</p>
<p>Circular detector</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx165.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {8: 0.000316, 1: 3.95e-05, 2: 7.9e-05, 3: 0.000118616, 4: 0.000158}</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx165.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx165.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (4096, 4096)</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx165.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx165.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['MAR165', 'Rayonix Sx165']</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx165.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.RayonixSx165.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixSx165.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Circular mask</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx165.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx165.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixSx200">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixSx200</tt><big>(</big><em>pixel1=4.8e-05</em>, <em>pixel2=4.8e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixSx200" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix sx200 2d CCD Detector.</p>
<p>Pixel size are personnal communication from M. Blum.</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx200.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {8: 0.000384, 1: 4.8e-05, 2: 9.6e-05, 3: 0.000144, 4: 0.000192}</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx200.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx200.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (4096, 4096)</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx200.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx200.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix sx200']</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx200.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixSx30hs">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixSx30hs</tt><big>(</big><em>pixel1=1.5625e-05</em>, <em>pixel2=1.5625e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixSx30hs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix sx30hs 2D CCD camera (1 CCD chip)</p>
<p>Pixel size from a personnal communication from M. Blum</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx30hs.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 1.5625e-05, 2: 3.125e-05, 3: 4.6875e-05, 4: 6.25e-05, 5: 7.8125e-05, 6: 9.375e-05, 8: 0.000125, 10: 0.00015625}</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx30hs.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx30hs.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1920, 1920)</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx30hs.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx30hs.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix Sx30hs']</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx30hs.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.RayonixSx85hs">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">RayonixSx85hs</tt><big>(</big><em>pixel1=4.42708e-05</em>, <em>pixel2=4.42708e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.RayonixSx85hs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Rayonix" title="pyFAI.detectors.Rayonix"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Rayonix</span></tt></a></p>
<p>Rayonix sx85hs 2D CCD camera (1 CCD chip)</p>
<p>Pixel size from a personnal communication from M. Blum</p>
<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx85hs.BINNED_PIXEL_SIZE">
<tt class="descname">BINNED_PIXEL_SIZE</tt><em class="property"> = {1: 4.42708e-05, 2: 8.85417e-05, 3: 0.0001328125, 4: 0.0001770833, 5: 0.0002213542, 6: 0.000265625, 8: 0.0003541667, 10: 0.0004427083}</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx85hs.BINNED_PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx85hs.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (1920, 1920)</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx85hs.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.RayonixSx85hs.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Rayonix Sx85hs']</em><a class="headerlink" href="#pyFAI.detectors.RayonixSx85hs.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Titan">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Titan</tt><big>(</big><em>pixel1=6e-05</em>, <em>pixel2=6e-05</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Titan" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.Detector" title="pyFAI.detectors.Detector"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.Detector</span></tt></a></p>
<p>Titan CCD detector from Agilent. Mask not handled</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Titan.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (2048, 2048)</em><a class="headerlink" href="#pyFAI.detectors.Titan.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Titan.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Titan 2k x 2k', 'OXD Titan', 'Agilent Titan']</em><a class="headerlink" href="#pyFAI.detectors.Titan.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Titan.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Titan.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Titan.uniform_pixel">
<tt class="descname">uniform_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Titan.uniform_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.detectors.Xpad_flat">
<em class="property">class </em><tt class="descclassname">pyFAI.detectors.</tt><tt class="descname">Xpad_flat</tt><big>(</big><em>pixel1=0.00013</em>, <em>pixel2=0.00013</em>, <em>max_shape=None</em>, <em>module_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Xpad_flat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.detectors.ImXPadS10" title="pyFAI.detectors.ImXPadS10"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.detectors.ImXPadS10</span></tt></a></p>
<p>Xpad detector: generic description for
ImXPad detector with 8x7modules</p>
<dl class="attribute">
<dt id="pyFAI.detectors.Xpad_flat.BORDER_PIXEL_SIZE_RELATIVE">
<tt class="descname">BORDER_PIXEL_SIZE_RELATIVE</tt><em class="property"> = 2.5</em><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.BORDER_PIXEL_SIZE_RELATIVE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Xpad_flat.IS_CONTIGUOUS">
<tt class="descname">IS_CONTIGUOUS</tt><em class="property"> = False</em><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.IS_CONTIGUOUS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Xpad_flat.MAX_SHAPE">
<tt class="descname">MAX_SHAPE</tt><em class="property"> = (960, 560)</em><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.MAX_SHAPE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Xpad_flat.MODULE_GAP">
<tt class="descname">MODULE_GAP</tt><em class="property"> = (0.00357, 0)</em><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.MODULE_GAP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Xpad_flat.MODULE_SIZE">
<tt class="descname">MODULE_SIZE</tt><em class="property"> = (120, 80)</em><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.MODULE_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Xpad_flat.PIXEL_SIZE">
<tt class="descname">PIXEL_SIZE</tt><em class="property"> = (0.00013, 0.00013)</em><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.PIXEL_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Xpad_flat.aliases">
<tt class="descname">aliases</tt><em class="property"> = ['Xpad S540 flat', 'd5']</em><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Xpad_flat.calc_cartesian_positions">
<tt class="descname">calc_cartesian_positions</tt><big>(</big><em>d1=None</em>, <em>d2=None</em>, <em>center=True</em>, <em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.calc_cartesian_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of each pixel center in cartesian coordinate
and in meter of a couple of coordinates.
The half pixel offset is taken into account here !!!
Adapted to Nexus detector definition</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>d1</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the Y pixel positions (slow dimension)</li>
<li><strong>d2</strong> (<em>ndarray (1D or 2D)</em>) &#8211; the X pixel positions (fast dimension)</li>
<li><strong>center</strong> &#8211; retrieve the coordinate of the center of the pixel</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>&#64;parm use_cython: set to False to test Numpy implementation
:return: position in meter of the center of each pixels.
:rtype: ndarray</p>
<p>d1 and d2 must have the same shape, returned array will have
the same shape.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Xpad_flat.calc_mask">
<tt class="descname">calc_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.calc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a generic mask for Xpad detectors...
discards the first line and raw form all modules:
those are 2.5x bigger and often mis - behaving</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Xpad_flat.calc_pixels_edges">
<tt class="descname">calc_pixels_edges</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.calc_pixels_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of the pixel edges, specific to the S540, d5 detector</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Xpad_flat.force_pixel">
<tt class="descname">force_pixel</tt><em class="property"> = True</em><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.force_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.detectors.Xpad_flat.get_pixel_corners">
<tt class="descname">get_pixel_corners</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.get_pixel_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of the corner of the pixels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">4D array containing:
pixel index (slow dimension)
pixel index (fast dimension)
corner index (A, B, C or D), triangles or hexagons can be handled the same way
vertex position (z,y,x)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.detectors.Xpad_flat.uniform_pixel">
<tt class="descname">uniform_pixel</tt><em class="property"> = False</em><a class="headerlink" href="#pyFAI.detectors.Xpad_flat.uniform_pixel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.spline">
<span id="spline-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">spline</span></tt> Module<a class="headerlink" href="#module-pyFAI.spline" title="Permalink to this headline">¶</a></h1>
<p>This is piece of software aims at manipulating spline files
describing for geometric corrections of the 2D detectors using cubic-spline.</p>
<p>Mainly used at ESRF with FReLoN CCD camera.</p>
<dl class="class">
<dt id="pyFAI.spline.Spline">
<em class="property">class </em><tt class="descclassname">pyFAI.spline.</tt><tt class="descname">Spline</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class is a python representation of the spline file</p>
<p>Those file represent cubic splines for 2D detector distortions and
makes heavy use of fitpack (dierckx in netlib) &#8212; A Python-C
wrapper to FITPACK (by P. Dierckx). FITPACK is a collection of
FORTRAN programs for curve and surface fitting with splines and
tensor product splines.  See
_http://www.cs.kuleuven.ac.be/cwis/research/nalag/research/topics/fitpack.html
or _http://www.netlib.org/dierckx/index.html</p>
<dl class="method">
<dt id="pyFAI.spline.Spline.array2spline">
<tt class="descname">array2spline</tt><big>(</big><em>smoothing=1000</em>, <em>timing=False</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.array2spline" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the spline coefficients from the displacements
matrix using fitpack.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>smoothing</strong> (<em>float</em>) &#8211; the greater the smoothing, the fewer the number of knots remaining</li>
<li><strong>timing</strong> (<em>bool</em>) &#8211; print the profiling of the calculation</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.bin">
<tt class="descname">bin</tt><big>(</big><em>binning=None</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the binning of a spline (same camera with different binning)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>binning</strong> &#8211; binning factor as integer or 2-tuple of integers</td>
</tr>
<tr class="field-even field"><th class="field-name">Type:</th><td class="field-body">int or (int, int)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.comparison">
<tt class="descname">comparison</tt><big>(</big><em>ref</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.comparison" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares the current spline distortion with a reference</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ref</strong> (<em>Spline instance</em>) &#8211; another spline file</li>
<li><strong>verbose</strong> (<em>bool</em>) &#8211; print or not pylab plots</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">True or False depending if the splines are the same or not</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.correct">
<tt class="descname">correct</tt><big>(</big><em>pos</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.correct" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.fliplr">
<tt class="descname">fliplr</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.fliplr" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip the spline 
:return: new spline object</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.fliplrud">
<tt class="descname">fliplrud</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.fliplrud" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip the spline left-right and up-down
:return: new spline object</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.flipud">
<tt class="descname">flipud</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.flipud" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip the spline up-down
:return: new spline object</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.getPixelSize">
<tt class="descname">getPixelSize</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.getPixelSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of the pixel from as a 2-tuple of floats expressed
in meters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the size of the pixel from a 2D detector</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">2-tuple of floats expressed in meter.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.read">
<tt class="descname">read</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.read" title="Permalink to this definition">¶</a></dt>
<dd><p>read an ascii spline file from file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>str</em>) &#8211; file containing the cubic spline distortion file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.setPixelSize">
<tt class="descname">setPixelSize</tt><big>(</big><em>pixelSize</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.setPixelSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the size of the pixel from a 2-tuple of floats expressed
in meters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param:</th><td class="field-body">pixel size in meter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.spline2array">
<tt class="descname">spline2array</tt><big>(</big><em>timing=False</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.spline2array" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the displacement matrix using fitpack
bisplev(x, y, tck, dx = 0, dy = 0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>timing</strong> (<em>bool</em>) &#8211; profile the calculation or not</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Nothing !</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float or ndarray</td>
</tr>
</tbody>
</table>
<p>Evaluate a bivariate B-spline and its derivatives. Return a
rank-2 array of spline function values (or spline derivative
values) at points given by the cross-product of the rank-1
arrays x and y. In special cases, return an array or just a
float if either x or y or both are floats.</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.splineFuncX">
<tt class="descname">splineFuncX</tt><big>(</big><em>x</em>, <em>y</em>, <em>list_of_points=False</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.splineFuncX" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the displacement matrix using fitpack for the X
direction on the given grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>ndarray</em>) &#8211; points of the grid in the x direction</li>
<li><strong>y</strong> (<em>ndarray</em>) &#8211; points of the grid  in the y direction</li>
<li><strong>list_of_points</strong> &#8211; if true, consider the zip(x,y) instead of the of the square array</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">displacement matrix for the X direction</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.splineFuncY">
<tt class="descname">splineFuncY</tt><big>(</big><em>x</em>, <em>y</em>, <em>list_of_points=False</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.splineFuncY" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the displacement matrix using fitpack for the Y
direction</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>ndarray</em>) &#8211; points in the x direction</li>
<li><strong>y</strong> (<em>ndarray</em>) &#8211; points in the y direction</li>
<li><strong>list_of_points</strong> &#8211; if true, consider the zip(x,y) instead of the of the square array</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">displacement matrix for the Y direction</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.tilt">
<tt class="descname">tilt</tt><big>(</big><em>center=(0.0</em>, <em>0.0)</em>, <em>tiltAngle=0.0</em>, <em>tiltPlanRot=0.0</em>, <em>distanceSampleDetector=1.0</em>, <em>timing=False</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.tilt" title="Permalink to this definition">¶</a></dt>
<dd><p>The tilt method apply a virtual tilt on the detector, the
point of tilt is given by the center</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>center</strong> (<em>2-tuple of floats</em>) &#8211; position of the point of tilt, this point will not be moved.</li>
<li><strong>tiltAngle</strong> (<em>float in the range [-90:+90] degrees</em>) &#8211; the value of the tilt in degrees</li>
<li><strong>tiltPlanRot</strong> (<em>Float in the range [-180:180]</em>) &#8211; the rotation of the tilt plan with the Ox axis (0 deg for y axis invariant, 90 deg for x axis invariant)</li>
<li><strong>distanceSampleDetector</strong> (<em>float</em>) &#8211; the distance from sample to detector in meter (along the beam, so distance from sample to center)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">tilted Spline instance</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Spline</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.write">
<tt class="descname">write</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.write" title="Permalink to this definition">¶</a></dt>
<dd><p>save the cubic spline in an ascii file usable with Fit2D or
SPD</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>str</em>) &#8211; name of the file containing the cubic spline distortion file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.writeEDF">
<tt class="descname">writeEDF</tt><big>(</big><em>basename</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.writeEDF" title="Permalink to this definition">¶</a></dt>
<dd><p>save the distortion matrices into a couple of files called
basename-x.edf and basename-y.edf</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>basename</strong> (<em>str</em>) &#8211; base of the name used to save the data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.zeros">
<tt class="descname">zeros</tt><big>(</big><em>xmin=0.0</em>, <em>ymin=0.0</em>, <em>xmax=2048.0</em>, <em>ymax=2048.0</em>, <em>pixSize=None</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a spline file with no ( zero ) displacement.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>xmin</strong> (<em>float</em>) &#8211; minimum coordinate in x, usually zero</li>
<li><strong>xmax</strong> (<em>float</em>) &#8211; maximum coordinate in x (+1) usually 2048</li>
<li><strong>ymin</strong> (<em>float</em>) &#8211; minimum coordinate in y, usually zero</li>
<li><strong>ymax</strong> (<em>float</em>) &#8211; maximum coordinate y (+1) usually 2048</li>
<li><strong>pixSize</strong> (<em>float</em>) &#8211; size of the pixel</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.spline.Spline.zeros_like">
<tt class="descname">zeros_like</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#pyFAI.spline.Spline.zeros_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a spline file with no ( zero ) displacement with the
same shape as the other one given.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<em>Spline instance</em>) &#8211; another Spline instance</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.spline.main">
<tt class="descclassname">pyFAI.spline.</tt><tt class="descname">main</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.spline.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Some tests ....</p>
</dd></dl>

</div>
<div class="section" id="module-pyFAI.opencl">
<span id="opencl-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">opencl</span></tt> Module<a class="headerlink" href="#module-pyFAI.opencl" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.opencl.Device">
<em class="property">class </em><tt class="descclassname">pyFAI.opencl.</tt><tt class="descname">Device</tt><big>(</big><em>name='None'</em>, <em>dtype=None</em>, <em>version=None</em>, <em>driver_version=None</em>, <em>extensions=''</em>, <em>memory=None</em>, <em>available=None</em>, <em>cores=None</em>, <em>frequency=None</em>, <em>flop_core=None</em>, <em>idx=0</em>, <em>workgroup=1</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.Device" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple class that contains the structure of an OpenCL device</p>
<dl class="method">
<dt id="pyFAI.opencl.Device.pretty_print">
<tt class="descname">pretty_print</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.opencl.Device.pretty_print" title="Permalink to this definition">¶</a></dt>
<dd><p>Complete device description</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">string</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.opencl.OpenCL">
<em class="property">class </em><tt class="descclassname">pyFAI.opencl.</tt><tt class="descname">OpenCL</tt><a class="headerlink" href="#pyFAI.opencl.OpenCL" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple class that wraps the structure ocl_tools_extended.h</p>
<p>This is a static class.
ocl should be the only instance and shared among all python modules.</p>
<dl class="attribute">
<dt id="pyFAI.opencl.OpenCL.comput_cap">
<tt class="descname">comput_cap</tt><em class="property"> = (5, 0)</em><a class="headerlink" href="#pyFAI.opencl.OpenCL.comput_cap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.opencl.OpenCL.context_cache">
<tt class="descname">context_cache</tt><em class="property"> = {}</em><a class="headerlink" href="#pyFAI.opencl.OpenCL.context_cache" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.opencl.OpenCL.create_context">
<tt class="descname">create_context</tt><big>(</big><em>devicetype='ALL'</em>, <em>useFp64=False</em>, <em>platformid=None</em>, <em>deviceid=None</em>, <em>cached=True</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.OpenCL.create_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose a device and initiate a context.</p>
<p>Devicetypes can be GPU,gpu,CPU,cpu,DEF,ACC,ALL.
Suggested are GPU,CPU.
For each setting to work there must be such an OpenCL device and properly installed.
E.g.: If Nvidia driver is installed, GPU will succeed but CPU will fail. The AMD SDK kit is required for CPU via OpenCL.
:param devicetype: string in [&#8220;cpu&#8221;,&#8221;gpu&#8221;, &#8220;all&#8221;, &#8220;acc&#8221;]
:param useFp64: boolean specifying if double precision will be used
:param platformid: integer
:param devid: integer
:return: OpenCL context on the selected device</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.opencl.OpenCL.device_from_context">
<tt class="descname">device_from_context</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.OpenCL.device_from_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the Device from the context</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>context</strong> &#8211; OpenCL context</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">instance of Device</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.opencl.OpenCL.flop_core">
<tt class="descname">flop_core</tt><em class="property"> = 4</em><a class="headerlink" href="#pyFAI.opencl.OpenCL.flop_core" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.opencl.OpenCL.get_platform">
<tt class="descname">get_platform</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.OpenCL.get_platform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a platform according</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>int or str</em>) &#8211; identifier for a platform, either an Id (int) or it&#8217;s name</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.opencl.OpenCL.idd">
<tt class="descname">idd</tt><em class="property"> = 0</em><a class="headerlink" href="#pyFAI.opencl.OpenCL.idd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.opencl.OpenCL.idx">
<tt class="descname">idx</tt><em class="property"> = 3</em><a class="headerlink" href="#pyFAI.opencl.OpenCL.idx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.opencl.OpenCL.nb_devices">
<tt class="descname">nb_devices</tt><em class="property"> = 5</em><a class="headerlink" href="#pyFAI.opencl.OpenCL.nb_devices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.opencl.OpenCL.platforms">
<tt class="descname">platforms</tt><em class="property"> = [NVIDIA CUDA, FreeOCL, Intel(R) OpenCL, AMD Accelerated Parallel Processing]</em><a class="headerlink" href="#pyFAI.opencl.OpenCL.platforms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.opencl.OpenCL.select_device">
<tt class="descname">select_device</tt><big>(</big><em>dtype='ALL'</em>, <em>memory=None</em>, <em>extensions=[]</em>, <em>best=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.OpenCL.select_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Select a device based on few parameters (at the end, keep the one with most memory)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>type</strong> &#8211; &#8220;gpu&#8221; or &#8220;cpu&#8221; or &#8220;all&#8221; ....</li>
<li><strong>memory</strong> &#8211; minimum amount of memory (int)</li>
<li><strong>extensions</strong> &#8211; list of extensions to be present</li>
<li><strong>best</strong> &#8211; shall we look for the</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.opencl.OpenCL.workgroup">
<tt class="descname">workgroup</tt><em class="property"> = 1024</em><a class="headerlink" href="#pyFAI.opencl.OpenCL.workgroup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.opencl.Platform">
<em class="property">class </em><tt class="descclassname">pyFAI.opencl.</tt><tt class="descname">Platform</tt><big>(</big><em>name='None'</em>, <em>vendor='None'</em>, <em>version=None</em>, <em>extensions=None</em>, <em>idx=0</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.Platform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple class that contains the structure of an OpenCL platform</p>
<dl class="method">
<dt id="pyFAI.opencl.Platform.add_device">
<tt class="descname">add_device</tt><big>(</big><em>device</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.Platform.add_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Add new device to the platform</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>device</strong> &#8211; Device instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.opencl.Platform.get_device">
<tt class="descname">get_device</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.Platform.get_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a device according to key</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>int or str</em>) &#8211; identifier for a device, either it&#8217;s id (int) or it&#8217;s name</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.opencl.allocate_cl_buffers">
<tt class="descclassname">pyFAI.opencl.</tt><tt class="descname">allocate_cl_buffers</tt><big>(</big><em>buffers</em>, <em>device=None</em>, <em>context=None</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.allocate_cl_buffers" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>buffers</strong> &#8211; the buffers info use to create the pyopencl.Buffer</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a dict containing the instanciated pyopencl.Buffer</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">dict(str, pyopencl.Buffer)</td>
</tr>
</tbody>
</table>
<p>This method instanciate the pyopencl.Buffer from the buffers
description.</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.opencl.release_cl_buffers">
<tt class="descclassname">pyFAI.opencl.</tt><tt class="descname">release_cl_buffers</tt><big>(</big><em>cl_buffers</em><big>)</big><a class="headerlink" href="#pyFAI.opencl.release_cl_buffers" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cl_buffer</strong> (<em>dict(str, pyopencl.Buffer)</em>) &#8211; the buffer you want to release</td>
</tr>
</tbody>
</table>
<p>This method release the memory of the buffers store in the dict</p>
</dd></dl>

</div>
<div class="section" id="module-pyFAI.ocl_azim">
<span id="ocl-azim-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">ocl_azim</span></tt> Module<a class="headerlink" href="#module-pyFAI.ocl_azim" title="Permalink to this headline">¶</a></h1>
<p>C++ less implementation of Dimitris&#8217; code based on PyOpenCL</p>
<dl class="docutils">
<dt>TODO and trick from dimitris still missing:</dt>
<dd><ul class="first last simple">
<li>dark-current subtraction is still missing</li>
<li>In fact you might want to consider doing the conversion on the GPU when
possible. Think about it, you have a uint16 to float which for large arrays
was slow.. You load on the graphic card a uint16 (2x transfer speed) and
you convert to float inside so it should be blazing fast.</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="pyFAI.ocl_azim.Integrator1d">
<em class="property">class </em><tt class="descclassname">pyFAI.ocl_azim.</tt><tt class="descname">Integrator1d</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Attempt to implements ocl_azim using pyopencl</p>
<dl class="attribute">
<dt id="pyFAI.ocl_azim.Integrator1d.BLOCK_SIZE">
<tt class="descname">BLOCK_SIZE</tt><em class="property"> = 128</em><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.BLOCK_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.clean">
<tt class="descname">clean</tt><big>(</big><em>preserve_context=False</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>Free OpenCL related resources allocated by the library.</p>
<p>clean() is used to reinitiate the library back in a vanilla
state.  It may be asked to preserve the context created by
init or completely clean up OpenCL. Guard/Status flags that
are set will be reset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>preserve_context</strong> (<em>bool</em>) &#8211; preserves or destroys all OpenCL resources</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.configure">
<tt class="descname">configure</tt><big>(</big><em>kernel=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.configure" title="Permalink to this definition">¶</a></dt>
<dd><p>The method configure() allocates the OpenCL resources required
and compiled the OpenCL kernels.  An active context must exist
before a call to configure() and getConfiguration() must have
been called at least once. Since the compiled OpenCL kernels
carry some information on the integration parameters, a change
to any of the parameters of getConfiguration() requires a
subsequent call to configure() for them to take effect.</p>
<p>If a configuration exists and configure() is called, the
configuration is cleaned up first to avoid OpenCL memory leaks</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kernel_path</strong> &#8211; is the path to the actual kernel</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.execute">
<tt class="descname">execute</tt><big>(</big><em>image</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a 1D azimuthal integration</p>
<p>execute() may be called only after an OpenCL device is
configured and a Tth array has been loaded (at least once) It
takes the input image and based on the configuration provided
earlier it performs the 1D integration.  Notice that if the
provided image is bigger than N then only N points will be
taked into account, while if the image is smaller than N the
result may be catastrophic.  set/unset and loadTth methods
have a direct impact on the execute() method.  All the rest of
the methods will require at least a new configuration via
configure().</p>
<p>Takes an image, integrate and return the histogram and weights</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image</strong> &#8211; image to be processed as a numpy array</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">tth_out, histogram, bins</td>
</tr>
</tbody>
</table>
<p>TODO: to improve performances, the image should be casted to
float32 in an optimal way: currently using numpy machinery but
would be better if done in OpenCL</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.getConfiguration">
<tt class="descname">getConfiguration</tt><big>(</big><em>Nimage</em>, <em>Nbins</em>, <em>useFp64=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.getConfiguration" title="Permalink to this definition">¶</a></dt>
<dd><p>getConfiguration gets the description of the integrations
to be performed and keeps an internal copy</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>Nimage</strong> &#8211; number of pixel in image</li>
<li><strong>Nbins</strong> &#8211; number of bins in regrouped histogram</li>
<li><strong>useFp64</strong> &#8211; use double precision. By default the same as init!</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.get_status">
<tt class="descname">get_status</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.get_status" title="Permalink to this definition">¶</a></dt>
<dd><p>return a dictionnary with the status of the integrator: for
compatibilty with former implementation</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.init">
<tt class="descname">init</tt><big>(</big><em>devicetype='GPU'</em>, <em>useFp64=True</em>, <em>platformid=None</em>, <em>deviceid=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial configuration: Choose a device and initiate a
context.  Devicetypes can be GPU, gpu, CPU, cpu, DEF, ACC,
ALL. Suggested are GPU,CPU. For each setting to work there
must be such an OpenCL device and properly installed. E.g.: If
Nvidia driver is installed, GPU will succeed but CPU will
fail. The AMD SDK kit (AMD APP) is required for CPU via
OpenCL.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>devicetype</strong> &#8211; string in [&#8220;cpu&#8221;,&#8221;gpu&#8221;, &#8220;all&#8221;, &#8220;acc&#8221;]</li>
<li><strong>useFp64</strong> &#8211; boolean specifying if double precision will be used</li>
<li><strong>platformid</strong> &#8211; integer</li>
<li><strong>devid</strong> &#8211; integer</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.loadTth">
<tt class="descname">loadTth</tt><big>(</big><em>tth</em>, <em>dtth</em>, <em>tth_min=None</em>, <em>tth_max=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.loadTth" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the 2th arrays along with the min and max value.</p>
<p>loadTth maybe be recalled at any time of the execution in
order to update the 2th arrays.</p>
<p>loadTth is required and must be called at least once after a
configure()</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.log">
<tt class="descname">log</tt><big>(</big><em>**kwarg</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.log" title="Permalink to this definition">¶</a></dt>
<dd><p>log in a file all opencl events</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.setDummyValue">
<tt class="descname">setDummyValue</tt><big>(</big><em>dummy</em>, <em>delta_dummy</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.setDummyValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Enables dummy value functionality and uploads the value to the
OpenCL device.</p>
<p>Image values that are similar to the dummy value are set to 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dummy</strong> &#8211; value in image of missing values (masked pixels?)</li>
<li><strong>delta_dummy</strong> &#8211; precision for dummy values</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.setMask">
<tt class="descname">setMask</tt><big>(</big><em>mask</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.setMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Enables the use of a Mask during integration. The Mask can be
updated by recalling setMask at any point.</p>
<p>The Mask must be a PyFAI Mask. Pixels with 0 are masked
out. TODO: check and invert!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mask</strong> &#8211; numpy.ndarray of integer.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.setRange">
<tt class="descname">setRange</tt><big>(</big><em>lowerBound</em>, <em>upperBound</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.setRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Instructs the program to use a user - defined range for 2th
values</p>
<p>setRange is optional. By default the integration will use the
tth_min and tth_max given by loadTth() as integration
range. When setRange is called it sets a new integration range
without affecting the 2th array. All values outside that range
will then be discarded when interpolating.  Currently, if the
interval of 2th (2th + -d2th) is not all inside the range
specified, it is discarded. The bins of the histogram are
RESCALED to the defined range and not the original tth_max -
tth_min range.</p>
<p>setRange can be called at any point and as many times required
after a valid configuration is created.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lowerBound</strong> (<em>float</em>) &#8211; lower bound of the integration range</li>
<li><strong>upperBound</strong> (<em>float</em>) &#8211; upper bound of the integration range</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.setSolidAngle">
<tt class="descname">setSolidAngle</tt><big>(</big><em>solidAngle</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.setSolidAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Enables SolidAngle correction and uploads the suitable array
to the OpenCL device.</p>
<p>By default the program will assume no solidangle correction
unless setSolidAngle() is called.  From then on, all
integrations will be corrected via the SolidAngle array.</p>
<p>If the SolidAngle array needs to be changes, one may just call
setSolidAngle() again with that array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>solidAngle</strong> (<em>ndarray</em>) &#8211; the solid angle of the given pixel</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.unsetDummyValue">
<tt class="descname">unsetDummyValue</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.unsetDummyValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable a dummy value.
May be re-enabled at any time by setDummyValue</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.unsetMask">
<tt class="descname">unsetMask</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.unsetMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Disables the use of a Mask from that point.
It may be re-enabled at any point via setMask</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.unsetRange">
<tt class="descname">unsetRange</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.unsetRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable the use of a user-defined 2th range and revert to
tth_min,tth_max range</p>
<p>unsetRange instructs the program to revert to its default
integration range. If the method is called when no
user-defined range had been previously specified, no action
will be performed</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim.Integrator1d.unsetSolidAngle">
<tt class="descname">unsetSolidAngle</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim.Integrator1d.unsetSolidAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Instructs the program to not perform solidangle correction from now on.</p>
<p>SolidAngle correction may be turned back on at any point</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.ocl_azim_lut">
<span id="ocl-azim-lut-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">ocl_azim_lut</span></tt> Module<a class="headerlink" href="#module-pyFAI.ocl_azim_lut" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.ocl_azim_lut.OCL_LUT_Integrator">
<em class="property">class </em><tt class="descclassname">pyFAI.ocl_azim_lut.</tt><tt class="descname">OCL_LUT_Integrator</tt><big>(</big><em>lut</em>, <em>image_size</em>, <em>devicetype='all'</em>, <em>platformid=None</em>, <em>deviceid=None</em>, <em>checksum=None</em>, <em>profile=False</em>, <em>empty=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_lut.OCL_LUT_Integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="attribute">
<dt id="pyFAI.ocl_azim_lut.OCL_LUT_Integrator.BLOCK_SIZE">
<tt class="descname">BLOCK_SIZE</tt><em class="property"> = 16</em><a class="headerlink" href="#pyFAI.ocl_azim_lut.OCL_LUT_Integrator.BLOCK_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim_lut.OCL_LUT_Integrator.integrate">
<tt class="descname">integrate</tt><big>(</big><em>data</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>solidAngle=None</em>, <em>polarization=None</em>, <em>dark_checksum=None</em>, <em>flat_checksum=None</em>, <em>solidAngle_checksum=None</em>, <em>polarization_checksum=None</em>, <em>preprocess_only=False</em>, <em>safe=True</em>, <em>normalization_factor=1.0</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_lut.OCL_LUT_Integrator.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Before performing azimuthal integration, the preprocessing is :</p>
<p>data = (data - dark) / (flat*solidAngle*polarization)</p>
<p>Integration is performed using the CSR representation of the look-up table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dark</strong> &#8211; array of same shape as data for pre-processing</li>
<li><strong>flat</strong> &#8211; array of same shape as data for pre-processing</li>
<li><strong>solidAngle</strong> &#8211; array of same shape as data for pre-processing</li>
<li><strong>polarization</strong> &#8211; array of same shape as data for pre-processing</li>
<li><strong>dark_checksum</strong> &#8211; CRC32 checksum of the given array</li>
<li><strong>flat_checksum</strong> &#8211; CRC32 checksum of the given array</li>
<li><strong>solidAngle_checksum</strong> &#8211; CRC32 checksum of the given array</li>
<li><strong>polarization_checksum</strong> &#8211; CRC32 checksum of the given array</li>
<li><strong>safe</strong> &#8211; if True (default) compares arrays on GPU according to their checksum, unless, use the buffer location is used</li>
<li><strong>normalization_factor</strong> &#8211; divide raw signal by this value</li>
<li><strong>preprocess_only</strong> &#8211; return the dark subtracted; flat field &amp; solidAngle &amp; polarization corrected image, else</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return averaged data, weighted histogram, unweighted histogram</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim_lut.OCL_LUT_Integrator.log_profile">
<tt class="descname">log_profile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_lut.OCL_LUT_Integrator.log_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>If we are in profiling mode, prints out all timing for every single OpenCL call</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.ocl_azim_csr">
<span id="ocl-azim-csr-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">ocl_azim_csr</span></tt> Module<a class="headerlink" href="#module-pyFAI.ocl_azim_csr" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.ocl_azim_csr.OCL_CSR_Integrator">
<em class="property">class </em><tt class="descclassname">pyFAI.ocl_azim_csr.</tt><tt class="descname">OCL_CSR_Integrator</tt><big>(</big><em>lut</em>, <em>image_size</em>, <em>devicetype='all'</em>, <em>block_size=32</em>, <em>platformid=None</em>, <em>deviceid=None</em>, <em>checksum=None</em>, <em>profile=False</em>, <em>empty=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_csr.OCL_CSR_Integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="pyFAI.ocl_azim_csr.OCL_CSR_Integrator.integrate">
<tt class="descname">integrate</tt><big>(</big><em>data</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>solidAngle=None</em>, <em>polarization=None</em>, <em>dark_checksum=None</em>, <em>flat_checksum=None</em>, <em>solidAngle_checksum=None</em>, <em>polarization_checksum=None</em>, <em>preprocess_only=False</em>, <em>safe=True</em>, <em>normalization_factor=1.0</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_csr.OCL_CSR_Integrator.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Before performing azimuthal integration, the preprocessing is :</p>
<p>data = (data - dark) / (flat*solidAngle*polarization)</p>
<p>Integration is performed using the CSR representation of the look-up table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dark</strong> &#8211; array of same shape as data for pre-processing</li>
<li><strong>flat</strong> &#8211; array of same shape as data for pre-processing</li>
<li><strong>solidAngle</strong> &#8211; array of same shape as data for pre-processing</li>
<li><strong>polarization</strong> &#8211; array of same shape as data for pre-processing</li>
<li><strong>dark_checksum</strong> &#8211; CRC32 checksum of the given array</li>
<li><strong>flat_checksum</strong> &#8211; CRC32 checksum of the given array</li>
<li><strong>solidAngle_checksum</strong> &#8211; CRC32 checksum of the given array</li>
<li><strong>polarization_checksum</strong> &#8211; CRC32 checksum of the given array</li>
<li><strong>safe</strong> &#8211; if True (default) compares arrays on GPU according to their checksum, unless, use the buffer location is used</li>
<li><strong>preprocess_only</strong> &#8211; return the dark subtracted; flat field &amp; solidAngle &amp; polarization corrected image, else</li>
<li><strong>normalization_factor</strong> &#8211; divide result by this value</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return averaged data, weighted histogram, unweighted histogram</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim_csr.OCL_CSR_Integrator.log_profile">
<tt class="descname">log_profile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_csr.OCL_CSR_Integrator.log_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>If we are in profiling mode, prints out all timing for every single OpenCL call</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.ocl_azim_csr_dis">
<span id="ocl-azim-csr-dis-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">ocl_azim_csr_dis</span></tt> Module<a class="headerlink" href="#module-pyFAI.ocl_azim_csr_dis" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.ocl_azim_csr_dis.OCL_CSR_Integrator">
<em class="property">class </em><tt class="descclassname">pyFAI.ocl_azim_csr_dis.</tt><tt class="descname">OCL_CSR_Integrator</tt><big>(</big><em>lut</em>, <em>image_size</em>, <em>devicetype='all'</em>, <em>block_size=32</em>, <em>platformid=None</em>, <em>deviceid=None</em>, <em>checksum=None</em>, <em>profile=False</em>, <em>empty=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_csr_dis.OCL_CSR_Integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="pyFAI.ocl_azim_csr_dis.OCL_CSR_Integrator.integrate">
<tt class="descname">integrate</tt><big>(</big><em>data</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>solidAngle=None</em>, <em>polarization=None</em>, <em>dark_checksum=None</em>, <em>flat_checksum=None</em>, <em>solidAngle_checksum=None</em>, <em>polarization_checksum=None</em><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_csr_dis.OCL_CSR_Integrator.integrate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.ocl_azim_csr_dis.OCL_CSR_Integrator.log_profile">
<tt class="descname">log_profile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.ocl_azim_csr_dis.OCL_CSR_Integrator.log_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>If we are in profiling mode, prints out all timing for every
single OpenCL call</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.worker">
<span id="worker-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">worker</span></tt> Module<a class="headerlink" href="#module-pyFAI.worker" title="Permalink to this headline">¶</a></h1>
<p>This module contains the Worker class:</p>
<p>A tool able to perform azimuthal integration with:
additional saving capabilities like
- save as 2/3D structure in a HDF5 File
- read from HDF5 files</p>
<p>Aims at being integrated into a plugin like LImA or as model for the GUI</p>
<p>The configuration of this class is mainly done via a dictionary transmitted as a JSON string:
Here are the valid keys:</p>
<blockquote>
<div><p>&#8220;dist&#8221;,
&#8220;poni1&#8221;,
&#8220;poni2&#8221;,
&#8220;rot1&#8221;
&#8220;rot3&#8221;
&#8220;rot2&#8221;
&#8220;pixel1&#8221;
&#8220;pixel2&#8221;</p>
<p>&#8220;splineFile&#8221;
&#8220;wavelength&#8221;</p>
<p>&#8220;poni&#8221; #path of the file</p>
<p>&#8220;chi_discontinuity_at_0&#8221;
&#8220;do_mask&#8221;
&#8220;do_dark&#8221;
&#8220;do_azimuthal_range&#8221;
&#8220;do_flat&#8221;
&#8220;do_2D&#8221;
&#8220;azimuth_range_min&#8221;
&#8220;azimuth_range_max&#8221;</p>
<p>&#8220;polarization_factor&#8221;
&#8220;nbpt_rad&#8221;
&#8220;do_solid_angle&#8221;
&#8220;do_radial_range&#8221;
&#8220;do_poisson&#8221;
&#8220;delta_dummy&#8221;
&#8220;nbpt_azim&#8221;
&#8220;flat_field&#8221;
&#8220;radial_range_min&#8221;
&#8220;dark_current&#8221;
&#8220;do_polarization&#8221;
&#8220;mask_file&#8221;
&#8220;detector&#8221;
&#8220;unit&#8221;
&#8220;radial_range_max&#8221;
&#8220;val_dummy&#8221;
&#8220;do_dummy&#8221;
&#8220;method&#8221;</p>
</div></blockquote>
<p>}</p>
<dl class="class">
<dt id="pyFAI.worker.DistortionWorker">
<em class="property">class </em><tt class="descclassname">pyFAI.worker.</tt><tt class="descname">DistortionWorker</tt><big>(</big><em>detector=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>solidangle=None</em>, <em>polarization=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>device=None</em><big>)</big><a class="headerlink" href="#pyFAI.worker.DistortionWorker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple worker doing dark, flat, solid angle and polarization correction</p>
<dl class="method">
<dt id="pyFAI.worker.DistortionWorker.process">
<tt class="descname">process</tt><big>(</big><em>data</em>, <em>normalization=None</em><big>)</big><a class="headerlink" href="#pyFAI.worker.DistortionWorker.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data and apply a normalization factor
:param data: input data
:param normalization: normalization factor
:return processed data</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.worker.PixelwiseWorker">
<em class="property">class </em><tt class="descclassname">pyFAI.worker.</tt><tt class="descname">PixelwiseWorker</tt><big>(</big><em>dark=None</em>, <em>flat=None</em>, <em>solidangle=None</em>, <em>polarization=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>device=None</em><big>)</big><a class="headerlink" href="#pyFAI.worker.PixelwiseWorker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple worker doing dark, flat, solid angle and polarization correction</p>
<dl class="method">
<dt id="pyFAI.worker.PixelwiseWorker.process">
<tt class="descname">process</tt><big>(</big><em>data</em>, <em>normalization=None</em><big>)</big><a class="headerlink" href="#pyFAI.worker.PixelwiseWorker.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data and apply a normalization factor
:param data: input data
:param normalization: normalization factor
:return processed data</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.worker.Worker">
<em class="property">class </em><tt class="descclassname">pyFAI.worker.</tt><tt class="descname">Worker</tt><big>(</big><em>azimuthalIntgrator=None</em>, <em>shapeIn=(2048</em>, <em>2048)</em>, <em>shapeOut=(360</em>, <em>500)</em>, <em>unit='r_mm'</em>, <em>dummy=None</em>, <em>delta_dummy=None</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="pyFAI.worker.Worker.do_2D">
<tt class="descname">do_2D</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.do_2D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.worker.Worker.error_model">
<tt class="descname">error_model</tt><a class="headerlink" href="#pyFAI.worker.Worker.error_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.get_config">
<tt class="descname">get_config</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.get_config" title="Permalink to this definition">¶</a></dt>
<dd><p>return configuration as a dictionary</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.get_error_model">
<tt class="descname">get_error_model</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.get_error_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.get_json_config">
<tt class="descname">get_json_config</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.get_json_config" title="Permalink to this definition">¶</a></dt>
<dd><p>return configuration as a JSON string</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.get_normalization_factor">
<tt class="descname">get_normalization_factor</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.get_normalization_factor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.get_unit">
<tt class="descname">get_unit</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.get_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.worker.Worker.normalization_factor">
<tt class="descname">normalization_factor</tt><a class="headerlink" href="#pyFAI.worker.Worker.normalization_factor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.process">
<tt class="descname">process</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Process a frame
#TODO:
dark, flat, sa are missing</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param:</th><td class="field-body">data: numpy array containing the input image</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.reconfig">
<tt class="descname">reconfig</tt><big>(</big><em>shape=(2048</em>, <em>2048)</em>, <em>sync=False</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.reconfig" title="Permalink to this definition">¶</a></dt>
<dd><p>This is just to force the integrator to initialize with a given input image shape</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shape</strong> &#8211; shape of the input image</li>
<li><strong>sync</strong> &#8211; return only when synchronized</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>this is just to force the integrator to initialize</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.save_config">
<tt class="descname">save_config</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.save_config" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.setDarkcurrentFile">
<tt class="descname">setDarkcurrentFile</tt><big>(</big><em>imagefile</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.setDarkcurrentFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.setExtension">
<tt class="descname">setExtension</tt><big>(</big><em>ext</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.setExtension" title="Permalink to this definition">¶</a></dt>
<dd><p>enforce the extension of the processed data file written</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.setFlatfieldFile">
<tt class="descname">setFlatfieldFile</tt><big>(</big><em>imagefile</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.setFlatfieldFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.setJsonConfig">
<tt class="descname">setJsonConfig</tt><big>(</big><em>jsonconfig</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.setJsonConfig" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.setSubdir">
<tt class="descname">setSubdir</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.setSubdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the relative or absolute path for processed data</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.set_error_model">
<tt class="descname">set_error_model</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.set_error_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.set_normalization_factor">
<tt class="descname">set_normalization_factor</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.set_normalization_factor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.set_unit">
<tt class="descname">set_unit</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.set_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.worker.Worker.unit">
<tt class="descname">unit</tt><a class="headerlink" href="#pyFAI.worker.Worker.unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.worker.Worker.warmup">
<tt class="descname">warmup</tt><big>(</big><em>sync=False</em><big>)</big><a class="headerlink" href="#pyFAI.worker.Worker.warmup" title="Permalink to this definition">¶</a></dt>
<dd><p>Process a dummy image to ensure everything is initialized</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sync</strong> &#8211; wait for processing to be finished</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.worker.make_ai">
<tt class="descclassname">pyFAI.worker.</tt><tt class="descname">make_ai</tt><big>(</big><em>config</em><big>)</big><a class="headerlink" href="#pyFAI.worker.make_ai" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an Azimuthal integrator from the configuration
Static method !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>config</strong> &#8211; dict with all parameters</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">configured (but uninitialized) AzimuthalIntgrator</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pyFAI.io">
<span id="io-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">io</span></tt> Module<a class="headerlink" href="#module-pyFAI.io" title="Permalink to this headline">¶</a></h1>
<p>Module for &#8220;high-performance&#8221; writing in either 1D with Ascii , 
or 2D with FabIO or even nD with n varying from  2 to 4 using HDF5</p>
<p>Stand-alone module which tries to offer interface to HDF5 via H5Py and
capabilities to write EDF or other formats using fabio.</p>
<p>Can be imported without h5py but then limited to fabio &amp; ascii formats.</p>
<p>TODO:
* add monitor to HDF5</p>
<dl class="class">
<dt id="pyFAI.io.AsciiWriter">
<em class="property">class </em><tt class="descclassname">pyFAI.io.</tt><tt class="descname">AsciiWriter</tt><big>(</big><em>filename=None</em>, <em>prefix='fai_'</em>, <em>extension='.dat'</em><big>)</big><a class="headerlink" href="#pyFAI.io.AsciiWriter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.io.Writer" title="pyFAI.io.Writer"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.io.Writer</span></tt></a></p>
<p>Ascii file writer (.xy or .dat)</p>
<dl class="method">
<dt id="pyFAI.io.AsciiWriter.init">
<tt class="descname">init</tt><big>(</big><em>fai_cfg=None</em>, <em>lima_cfg=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.AsciiWriter.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the directory that will host the output file(s)</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.AsciiWriter.write">
<tt class="descname">write</tt><big>(</big><em>data</em>, <em>index=0</em><big>)</big><a class="headerlink" href="#pyFAI.io.AsciiWriter.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.io.FabioWriter">
<em class="property">class </em><tt class="descclassname">pyFAI.io.</tt><tt class="descname">FabioWriter</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.FabioWriter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.io.Writer" title="pyFAI.io.Writer"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.io.Writer</span></tt></a></p>
<p>Image file writer based on FabIO</p>
<p>TODO !!!</p>
<dl class="method">
<dt id="pyFAI.io.FabioWriter.init">
<tt class="descname">init</tt><big>(</big><em>fai_cfg=None</em>, <em>lima_cfg=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.FabioWriter.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the directory that will host the output file(s)</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.FabioWriter.write">
<tt class="descname">write</tt><big>(</big><em>data</em>, <em>index=0</em><big>)</big><a class="headerlink" href="#pyFAI.io.FabioWriter.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.io.HDF5Writer">
<em class="property">class </em><tt class="descclassname">pyFAI.io.</tt><tt class="descname">HDF5Writer</tt><big>(</big><em>filename</em>, <em>hpath='data'</em>, <em>fast_scan_width=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.HDF5Writer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.io.Writer" title="pyFAI.io.Writer"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.io.Writer</span></tt></a></p>
<p>Class allowing to write HDF5 Files.</p>
<dl class="attribute">
<dt id="pyFAI.io.HDF5Writer.CONFIG">
<tt class="descname">CONFIG</tt><em class="property"> = 'pyFAI'</em><a class="headerlink" href="#pyFAI.io.HDF5Writer.CONFIG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.io.HDF5Writer.DATASET_NAME">
<tt class="descname">DATASET_NAME</tt><em class="property"> = 'data'</em><a class="headerlink" href="#pyFAI.io.HDF5Writer.DATASET_NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.io.HDF5Writer.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.io.HDF5Writer.close" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.io.HDF5Writer.flush">
<tt class="descname">flush</tt><big>(</big><em>radial=None</em>, <em>azimuthal=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.HDF5Writer.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Update some data like axis units and so on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>radial</strong> &#8211; position in radial direction</li>
<li><strong>azimuthal</strong> &#8211; position in azimuthal direction</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.HDF5Writer.init">
<tt class="descname">init</tt><big>(</big><em>fai_cfg=None</em>, <em>lima_cfg=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.HDF5Writer.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the HDF5 file for writing
:param fai_cfg: the configuration of the worker as a dictionary</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.HDF5Writer.write">
<tt class="descname">write</tt><big>(</big><em>data</em>, <em>index=0</em><big>)</big><a class="headerlink" href="#pyFAI.io.HDF5Writer.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimalistic method to limit the overhead.
:param data: array with intensities or tuple (2th,I) or (I,2th,chi)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.io.Nexus">
<em class="property">class </em><tt class="descclassname">pyFAI.io.</tt><tt class="descname">Nexus</tt><big>(</big><em>filename</em>, <em>mode='r'</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Writer class to handle Nexus/HDF5 data
Manages:
entry</p>
<blockquote>
<div><dl class="docutils">
<dt>pyFAI-subentry</dt>
<dd>detector</dd>
</dl>
</div></blockquote>
<p>#TODO: make it thread-safe !!!</p>
<dl class="method">
<dt id="pyFAI.io.Nexus.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.close" title="Permalink to this definition">¶</a></dt>
<dd><p>close the filename and update all entries</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.deep_copy">
<tt class="descname">deep_copy</tt><big>(</big><em>name</em>, <em>obj</em>, <em>where='/'</em>, <em>toplevel=None</em>, <em>excluded=None</em>, <em>overwrite=False</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.deep_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>perform a deep copy:
create a &#8220;name&#8221; entry in self containing a copy of the object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>where</strong> &#8211; path to the toplevel object (i.e. root)</li>
<li><strong>toplevel</strong> &#8211; firectly the top level Group</li>
<li><strong>excluded</strong> &#8211; list of keys to be excluded</li>
<li><strong>overwrite</strong> &#8211; replace content if already existing</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.find_detector">
<tt class="descname">find_detector</tt><big>(</big><em>all=False</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.find_detector" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to find a detector within a NeXus file, takes the first compatible detector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>all</strong> &#8211; return all detectors found as a list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pyFAI.io.Nexus.get_attr">
<em class="property">classmethod </em><tt class="descname">get_attr</tt><big>(</big><em>dset</em>, <em>name</em>, <em>default=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.get_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the attribute of the dataset</p>
<p>Handles the ascii -&gt; unicode issue in python3 #275</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dset</strong> &#8211; a HDF5 dataset (or a group)</li>
<li><strong>name</strong> &#8211; name of the attribute</li>
<li><strong>default</strong> &#8211; default value to be returned</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">attribute value decoded in python3 or default</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.get_class">
<tt class="descname">get_class</tt><big>(</big><em>grp</em>, <em>class_type='NXcollection'</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.get_class" title="Permalink to this definition">¶</a></dt>
<dd><p>return all sub-groups of the given type within a group</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>grp</strong> &#8211; HDF5 group</li>
<li><strong>class_type</strong> &#8211; name of the NeXus class</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.get_data">
<tt class="descname">get_data</tt><big>(</big><em>grp</em>, <em>class_type='NXdata'</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>return all dataset of the the NeXus class NXdata</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>grp</strong> &#8211; HDF5 group</li>
<li><strong>class_type</strong> &#8211; name of the NeXus class</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.get_entries">
<tt class="descname">get_entries</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.get_entries" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieves all entry sorted the latest first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of HDF5 groups</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.get_entry">
<tt class="descname">get_entry</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.get_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves an entry from its name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> &#8211; name of the entry to retrieve</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">HDF5 group of NXclass == NXentry</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.new_class">
<tt class="descname">new_class</tt><big>(</big><em>grp</em>, <em>name</em>, <em>class_type='NXcollection'</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.new_class" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new sub-group with  type class_type
:param grp: parent group
:param name: name of the sub-group
:param class_type: NeXus class name
:return: subgroup created</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.new_detector">
<tt class="descname">new_detector</tt><big>(</big><em>name='detector'</em>, <em>entry='entry'</em>, <em>subentry='pyFAI'</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.new_detector" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new entry/pyFAI/Detector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>detector</strong> &#8211; name of the detector</li>
<li><strong>entry</strong> &#8211; name of the entry</li>
<li><strong>subentry</strong> &#8211; all pyFAI description of detectors should be in a pyFAI sub-entry</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.new_entry">
<tt class="descname">new_entry</tt><big>(</big><em>entry='entry'</em>, <em>program_name='pyFAI'</em>, <em>title='description of experiment'</em>, <em>force_time=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.new_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new entry</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>entry</strong> &#8211; name of the entry</li>
<li><strong>program_name</strong> &#8211; value of the field as string</li>
<li><strong>title</strong> &#8211; value of the field as string</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>&#64;force_time: enforce the start_time (as string!)
:return: the corresponding HDF5 group</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Nexus.new_instrument">
<tt class="descname">new_instrument</tt><big>(</big><em>entry='entry'</em>, <em>instrument_name='id00'</em><big>)</big><a class="headerlink" href="#pyFAI.io.Nexus.new_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an instrument in an entry or create both the entry and the instrument if</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.io.Writer">
<em class="property">class </em><tt class="descclassname">pyFAI.io.</tt><tt class="descname">Writer</tt><big>(</big><em>filename=None</em>, <em>extension=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.Writer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Abstract class for writers.</p>
<dl class="attribute">
<dt id="pyFAI.io.Writer.CONFIG_ITEMS">
<tt class="descname">CONFIG_ITEMS</tt><em class="property"> = ['filename', 'dirname', 'extension', 'subdir', 'hpath']</em><a class="headerlink" href="#pyFAI.io.Writer.CONFIG_ITEMS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.io.Writer.flush">
<tt class="descname">flush</tt><big>(</big><em>*arg</em>, <em>**kwarg</em><big>)</big><a class="headerlink" href="#pyFAI.io.Writer.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>To be implemented</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Writer.init">
<tt class="descname">init</tt><big>(</big><em>fai_cfg=None</em>, <em>lima_cfg=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.Writer.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the directory that will host the output file(s)
:param fai_cfg: configuration for worker
:param lima_cfg: configuration for acquisition</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Writer.setJsonConfig">
<tt class="descname">setJsonConfig</tt><big>(</big><em>json_config=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.Writer.setJsonConfig" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the JSON configuration</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.io.Writer.write">
<tt class="descname">write</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyFAI.io.Writer.write" title="Permalink to this definition">¶</a></dt>
<dd><p>To be implemented</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.io.from_isotime">
<tt class="descclassname">pyFAI.io.</tt><tt class="descname">from_isotime</tt><big>(</big><em>text</em>, <em>use_tz=False</em><big>)</big><a class="headerlink" href="#pyFAI.io.from_isotime" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>text</strong> &#8211; string representing the time is iso format</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.io.get_isotime">
<tt class="descclassname">pyFAI.io.</tt><tt class="descname">get_isotime</tt><big>(</big><em>forceTime=None</em><big>)</big><a class="headerlink" href="#pyFAI.io.get_isotime" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>forceTime</strong> (<em>float</em>) &#8211; enforce a given time (current by default)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the current time as an ISO8601 string</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">string</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.io.is_hdf5">
<tt class="descclassname">pyFAI.io.</tt><tt class="descname">is_hdf5</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.io.is_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a file is actually a HDF5 file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; this file has better to exist</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pyFAI.calibration">
<span id="calibration-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">calibration</span></tt> Module<a class="headerlink" href="#module-pyFAI.calibration" title="Permalink to this headline">¶</a></h1>
<p>pyFAI-calib</p>
<p>A tool for determining the geometry of a detector using a reference sample.</p>
<dl class="class">
<dt id="pyFAI.calibration.AbstractCalibration">
<em class="property">class </em><tt class="descclassname">pyFAI.calibration.</tt><tt class="descname">AbstractCalibration</tt><big>(</big><em>dataFiles=None</em>, <em>darkFiles=None</em>, <em>flatFiles=None</em>, <em>pixelSize=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>wavelength=None</em>, <em>calibrant=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Everything that is common to Calibration and Recalibration</p>
<dl class="attribute">
<dt id="pyFAI.calibration.AbstractCalibration.HELP">
<tt class="descname">HELP</tt><em class="property"> = {'reset': 'Reset the geometry to the initial guess (rotation to zero, distance to 0.1m, poni at the center of the image)', 'delete': 'delete a group of points, provide the letter.', 'set': &quot;set the value of a parameter to the given value, i.e 'set wavelength 0.1 nm', units are optional&quot;, 'chiplot': 'plot control point radial error as function of azimuthal angle, optional parameters: the rings for which this need to be plotted', 'help': &quot;Try to get the help of a given action, like 'refine?'. Use done when finished. Most command are composed of 'action parameter value' like 'set wavelength 1 A'.&quot;, 'weight': 'toggle from weighted to unweighted mode...', 'get': 'print he value of a parameter', 'fix': &quot;fixes the value of a parameter so that its value will not be optimized, i.e. 'fix wavelength'&quot;, 'validate2': 'measures the offset of the center as function of azimuthal angle by cross-correlation of 2 plots, 180 deg appart. Option: number of azimuthal sliced, default: 36', 'show': &quot;Just print out the current parameter set. Optional parameters are units for length, rotation and wavelength, i.e. 'show mm deg A'&quot;, 'bound': &quot;sets the upper and lower bound of a parameter: 'bound dist 0.1 0.2'&quot;, 'free': &quot;frees the parameter so that the value can be optimized, i.e. 'free wavelength'&quot;, 'bounds': 'sets the upper and lower bound of all parameters', 'abort': 'quit immediately, discarding any unsaved changes', 'done': 'finishes the processing, performs an integration and quits', 'refine': 'performs a new cycle of refinement', 'integrate': 'perform the azimuthal integration and display results', 'validate': 'plot the offset between the calibrated image and the back-projected image', 'recalib': 'extract a new set of rings and re-perform the calibration. One can specify how many rings to extract and the algorithm to use (blob, massif, watershed) and the nb_pts_per_deg in azimuth', 'assign': 'Change the assignment of a group of points to a rings', 'define': 'Re-define the value for a constant internal parameter of the program like max_iter, nPt_1D, nPt_2D_azim, nPt_2D_rad, integrator_method, error_model. Warning: attribute change may be harmful !'}</em><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.HELP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibration.AbstractCalibration.PARAMETERS">
<tt class="descname">PARAMETERS</tt><em class="property"> = ['dist', 'poni1', 'poni2', 'rot1', 'rot2', 'rot3', 'wavelength']</em><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.PARAMETERS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibration.AbstractCalibration.PTS_PER_DEG">
<tt class="descname">PTS_PER_DEG</tt><em class="property"> = 0.3</em><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.PTS_PER_DEG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibration.AbstractCalibration.UNITS">
<tt class="descname">UNITS</tt><em class="property"> = {'poni1': 'meter', 'poni2': 'meter', 'rot1': 'radian', 'rot3': 'radian', 'rot2': 'radian', 'wavelength': 'meter', 'dist': 'meter'}</em><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.UNITS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibration.AbstractCalibration.VALID_URL">
<tt class="descname">VALID_URL</tt><em class="property"> = ['', 'file', 'hdf5', 'nxs', 'h5']</em><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.VALID_URL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.analyse_options">
<tt class="descname">analyse_options</tt><big>(</big><em>options=None</em>, <em>args=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.analyse_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyzes options and arguments</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">option,arguments</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.chiplot">
<tt class="descname">chiplot</tt><big>(</big><em>rings=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.chiplot" title="Permalink to this definition">¶</a></dt>
<dd><p>plot delta_2theta/2theta = f(chi) and fit the curve.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rings</strong> &#8211; list of rings to consider</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.configure_parser">
<tt class="descname">configure_parser</tt><big>(</big><em>version='calibration from pyFAI  version 0.12.0: 06/06/2016'</em>, <em>usage='pyFAI-calib [options] input_image.edf'</em>, <em>description=None</em>, <em>epilog=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.configure_parser" title="Permalink to this definition">¶</a></dt>
<dd><p>Common configuration for parsers</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.extract_cpt">
<tt class="descname">extract_cpt</tt><big>(</big><em>method='massif'</em>, <em>pts_per_deg=1.0</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.extract_cpt" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs an automatic keypoint extraction:
Can be used in recalib or in calib after a first calibration has been performed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>method</strong> &#8211; method for keypoint extraction</li>
<li><strong>pts_per_deg</strong> &#8211; number of control points per azimuthal degree (increase for better precision)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.get_pixelSize">
<tt class="descname">get_pixelSize</tt><big>(</big><em>ans</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.get_pixelSize" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a comma separated sting into pixel size</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.postProcess">
<tt class="descname">postProcess</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.postProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Common part: shows the result of the azimuthal integration in 1D and 2D</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.preprocess">
<tt class="descname">preprocess</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>Common part:
do dark, flat correction thresholding, ...
and read missing data from keyboard if needed</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.prompt">
<tt class="descname">prompt</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.prompt" title="Permalink to this definition">¶</a></dt>
<dd><p>prompt for commands to guide the calibration process</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True when the user is happy with what he has, False to request another refinement</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.read_dSpacingFile">
<tt class="descname">read_dSpacingFile</tt><big>(</big><em>verbose=True</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.read_dSpacingFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the name of the calibrant / file with d-spacing</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.read_pixelsSize">
<tt class="descname">read_pixelsSize</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.read_pixelsSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the pixel size from prompt if not available</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.read_wavelength">
<tt class="descname">read_wavelength</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.read_wavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the wavelength</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.refine">
<tt class="descname">refine</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the common geometry refinement part</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.reset_geometry">
<tt class="descname">reset_geometry</tt><big>(</big><em>how='center'</em>, <em>refine=False</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.reset_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the geometry: no tilt in all cases</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>how</strong> &#8211; multiple options
* center: set the PONI at the center of the detector
* ring: center the poni at the middle of the inner-most ring
//* best: try both option and keeps the best</td>
</tr>
</tbody>
</table>
<p>//:param refine: launch the refinement</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.set_data">
<tt class="descname">set_data</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>call-back function for the peak-picker</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.validate_calibration">
<tt class="descname">validate_calibration</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.validate_calibration" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the calibration and calculate the offset in the diffraction image</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.AbstractCalibration.validate_center">
<tt class="descname">validate_center</tt><big>(</big><em>slices=36</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.validate_center" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the position of the center by cross-correlating two spectra 180 deg appart.
Output values are in micron.</p>
<p>Designed for orthogonal setup with centered beam...</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>slices</strong> &#8211; number of slices on which perform</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibration.AbstractCalibration.win_error">
<tt class="descname">win_error</tt><em class="property"> = 'We are under windows with a 32 bit version of python, matplotlib is not able to display too many images without crashing, this is why the window showing the diffraction image is closed'</em><a class="headerlink" href="#pyFAI.calibration.AbstractCalibration.win_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.calibration.Calibration">
<em class="property">class </em><tt class="descclassname">pyFAI.calibration.</tt><tt class="descname">Calibration</tt><big>(</big><em>dataFiles=None</em>, <em>darkFiles=None</em>, <em>flatFiles=None</em>, <em>pixelSize=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>gaussianWidth=None</em>, <em>wavelength=None</em>, <em>calibrant=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.Calibration" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.calibration.AbstractCalibration" title="pyFAI.calibration.AbstractCalibration"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.calibration.AbstractCalibration</span></tt></a></p>
<p>class doing the calibration of frames</p>
<dl class="method">
<dt id="pyFAI.calibration.Calibration.gui_peakPicker">
<tt class="descname">gui_peakPicker</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.Calibration.gui_peakPicker" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.Calibration.initgeoRef">
<tt class="descname">initgeoRef</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.Calibration.initgeoRef" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to initialise the GeometryRefinement (dist, poni, rot)
Returns a dictionary of key value pairs</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.Calibration.parse">
<tt class="descname">parse</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.Calibration.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>parse options from command line</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.Calibration.preprocess">
<tt class="descname">preprocess</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.Calibration.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>do dark, flat correction thresholding, ...</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.Calibration.refine">
<tt class="descname">refine</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.Calibration.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the geometry refinement part specific to Calibration
Sets up the initial guess when starting pyFAI-calib</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.calibration.CheckCalib">
<em class="property">class </em><tt class="descclassname">pyFAI.calibration.</tt><tt class="descname">CheckCalib</tt><big>(</big><em>poni=None</em>, <em>img=None</em>, <em>unit='2th_deg'</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.CheckCalib" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="pyFAI.calibration.CheckCalib.get_1dsize">
<tt class="descname">get_1dsize</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.CheckCalib.get_1dsize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.CheckCalib.integrate">
<tt class="descname">integrate</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.CheckCalib.integrate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.CheckCalib.parse">
<tt class="descname">parse</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.CheckCalib.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.CheckCalib.rebuild">
<tt class="descname">rebuild</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.CheckCalib.rebuild" title="Permalink to this definition">¶</a></dt>
<dd><p>Rebuild the diffraction image and measures the offset with the reference
:return: offset</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.CheckCalib.show">
<tt class="descname">show</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.CheckCalib.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the image with the the errors</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibration.CheckCalib.size1d">
<tt class="descname">size1d</tt><a class="headerlink" href="#pyFAI.calibration.CheckCalib.size1d" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.CheckCalib.smooth_mask">
<tt class="descname">smooth_mask</tt><big>(</big><em>hwhm=5</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.CheckCalib.smooth_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>smooth out around the mask to avoid aligning on the mask</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.calibration.MultiCalib">
<em class="property">class </em><tt class="descclassname">pyFAI.calibration.</tt><tt class="descname">MultiCalib</tt><big>(</big><em>dataFiles=None</em>, <em>darkFiles=None</em>, <em>flatFiles=None</em>, <em>pixelSize=None</em>, <em>splineFile=None</em>, <em>detector=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.MultiCalib" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="pyFAI.calibration.MultiCalib.get_pixelSize">
<tt class="descname">get_pixelSize</tt><big>(</big><em>ans</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.MultiCalib.get_pixelSize" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a comma separated sting into pixel size</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.MultiCalib.parse">
<tt class="descname">parse</tt><big>(</big><em>exe=None</em>, <em>description=None</em>, <em>epilog=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.MultiCalib.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>parse options from command line
:param exe: name of the program (MX-calibrate)
:param description: Description of the program</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.MultiCalib.process">
<tt class="descname">process</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.MultiCalib.process" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.MultiCalib.read_dSpacingFile">
<tt class="descname">read_dSpacingFile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.MultiCalib.read_dSpacingFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the name of the calibrant or the file with d-spacing</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.MultiCalib.read_pixelsSize">
<tt class="descname">read_pixelsSize</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.MultiCalib.read_pixelsSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the pixel size from prompt if not available</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.MultiCalib.read_wavelength">
<tt class="descname">read_wavelength</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.MultiCalib.read_wavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the wavelength</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.MultiCalib.regression">
<tt class="descname">regression</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.MultiCalib.regression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.calibration.Recalibration">
<em class="property">class </em><tt class="descclassname">pyFAI.calibration.</tt><tt class="descname">Recalibration</tt><big>(</big><em>dataFiles=None</em>, <em>darkFiles=None</em>, <em>flatFiles=None</em>, <em>pixelSize=None</em>, <em>splineFile=None</em>, <em>detector=None</em>, <em>wavelength=None</em>, <em>calibrant=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.Recalibration" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyFAI.calibration.AbstractCalibration" title="pyFAI.calibration.AbstractCalibration"><tt class="xref py py-class docutils literal"><span class="pre">pyFAI.calibration.AbstractCalibration</span></tt></a></p>
<p>class doing the re-calibration of frames</p>
<dl class="method">
<dt id="pyFAI.calibration.Recalibration.parse">
<tt class="descname">parse</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.Recalibration.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>parse options from command line</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.Recalibration.preprocess">
<tt class="descname">preprocess</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.Recalibration.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>do dark, flat correction thresholding, ...</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.Recalibration.read_dSpacingFile">
<tt class="descname">read_dSpacingFile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.Recalibration.read_dSpacingFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the name of the file with d-spacing</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibration.Recalibration.refine">
<tt class="descname">refine</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibration.Recalibration.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the geometry refinement part specific to Recalibration</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.calibration.calib">
<tt class="descclassname">pyFAI.calibration.</tt><tt class="descname">calib</tt><big>(</big><em>img</em>, <em>calibrant</em>, <em>detector</em>, <em>basename='from_ipython'</em>, <em>reconstruct=False</em>, <em>dist=0.1</em>, <em>gaussian=None</em>, <em>interactive=True</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.calib" title="Permalink to this definition">¶</a></dt>
<dd><p>Procedural interfact for calibration</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>img</strong> &#8211; 2d array representing the calibration image</li>
<li><strong>calibrant</strong> &#8211; Instance of Calibrant, set-up with wavelength</li>
<li><strong>detector</strong> &#8211; Detector instance containing the mask</li>
<li><strong>basename</strong> &#8211; output file base</li>
<li><strong>recontruct</strong> &#8211; perform image reconstruction of masked pixel ?</li>
<li><strong>dist</strong> &#8211; initial distance</li>
<li><strong>gaussian</strong> &#8211; width of the gaussian used for difference of gaussian in the &#8220;massif&#8221; peak-picking algorithm</li>
<li><strong>interactive</strong> &#8211; set to False for testing</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">AzimuthalIntegrator instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.calibration.get_detector">
<tt class="descclassname">pyFAI.calibration.</tt><tt class="descname">get_detector</tt><big>(</big><em>detector</em>, <em>datafiles=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibration.get_detector" title="Permalink to this definition">¶</a></dt>
<dd><p>Detector factory taking into account the binning knowing the datafiles
:param detector: string or detector or other junk
:param datafiles: can be a list of images to be opened and their shape used.
:return pyFAI.detector.Detector instance</p>
</dd></dl>

</div>
<div class="section" id="module-pyFAI.peak_picker">
<span id="peak-picker-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">peak_picker</span></tt> Module<a class="headerlink" href="#module-pyFAI.peak_picker" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.peak_picker.ControlPoints">
<em class="property">class </em><tt class="descclassname">pyFAI.peak_picker.</tt><tt class="descname">ControlPoints</tt><big>(</big><em>filename=None</em>, <em>calibrant=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class contains a set of control points with (optionally) their ring number hence d-spacing and diffraction  2Theta angle ...</p>
<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.append">
<tt class="descname">append</tt><big>(</big><em>points</em>, <em>ring=None</em>, <em>annotate=None</em>, <em>plot=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.append" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>point</strong> &#8211; list of points</li>
<li><strong>ring</strong> &#8211; ring number</li>
<li><strong>annotate</strong> &#8211; matplotlib.annotate reference</li>
<li><strong>plot</strong> &#8211; matplotlib.plot reference</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">PointGroup instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.append_2theta_deg">
<tt class="descname">append_2theta_deg</tt><big>(</big><em>points</em>, <em>angle=None</em>, <em>ring=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.append_2theta_deg" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>point</strong> &#8211; list of points</li>
<li><strong>angle</strong> &#8211; 2-theta angle in degrees</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.check">
<tt class="descname">check</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.check" title="Permalink to this definition">¶</a></dt>
<dd><p>check internal consistency of the class</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.peak_picker.ControlPoints.dSpacing">
<tt class="descname">dSpacing</tt><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.dSpacing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.get">
<tt class="descname">get</tt><big>(</big><em>ring=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.get" title="Permalink to this definition">¶</a></dt>
<dd><p>retireves the last set of points for a given ring (by default the last)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ring</strong> &#8211; index of ring to search for</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.getList">
<tt class="descname">getList</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.getList" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the list of control points suitable for geometry refinement with ring number</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.getList2theta">
<tt class="descname">getList2theta</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.getList2theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the list of control points suitable for geometry refinement</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.getListRing">
<tt class="descname">getListRing</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.getListRing" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the list of control points suitable for geometry refinement with ring number</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.getWeightedList">
<tt class="descname">getWeightedList</tt><big>(</big><em>image</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.getWeightedList" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the list of control points suitable for geometry refinement with ring number and intensities
:param image:
:return: a (x,4) array with pos0, pos1, ring nr and intensity</p>
<p>#TODO: refine the value of the intensity using 2nd order polynomia</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.get_dSpacing">
<tt class="descname">get_dSpacing</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.get_dSpacing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.get_wavelength">
<tt class="descname">get_wavelength</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.get_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.load">
<tt class="descname">load</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.load" title="Permalink to this definition">¶</a></dt>
<dd><p>load all control points from a file</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.pop">
<tt class="descname">pop</tt><big>(</big><em>ring=None</em>, <em>lbl=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the set of points, either from its code or from a given ring (by default the last)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ring</strong> &#8211; index of ring of which remove the last group</li>
<li><strong>lbl</strong> &#8211; code of the ring to remove</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.readRingNrFromKeyboard">
<tt class="descname">readRingNrFromKeyboard</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.readRingNrFromKeyboard" title="Permalink to this definition">¶</a></dt>
<dd><p>Ask the ring number values for the given points</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all stored values and resets them to default</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.save">
<tt class="descname">save</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a set of control points to a file
:param filename: name of the file
:return: None</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.setWavelength_change2th">
<tt class="descname">setWavelength_change2th</tt><big>(</big><em>value=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.setWavelength_change2th" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.setWavelength_changeDs">
<tt class="descname">setWavelength_changeDs</tt><big>(</big><em>value=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.setWavelength_changeDs" title="Permalink to this definition">¶</a></dt>
<dd><p>This is probably not a good idea, but who knows !</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.set_dSpacing">
<tt class="descname">set_dSpacing</tt><big>(</big><em>lst</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.set_dSpacing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.ControlPoints.set_wavelength">
<tt class="descname">set_wavelength</tt><big>(</big><em>value=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.set_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.peak_picker.ControlPoints.wavelength">
<tt class="descname">wavelength</tt><a class="headerlink" href="#pyFAI.peak_picker.ControlPoints.wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.peak_picker.PeakPicker">
<em class="property">class </em><tt class="descclassname">pyFAI.peak_picker.</tt><tt class="descname">PeakPicker</tt><big>(</big><em>data</em>, <em>reconst=False</em>, <em>mask=None</em>, <em>pointfile=None</em>, <em>calibrant=None</em>, <em>wavelength=None</em>, <em>detector=None</em>, <em>method='massif'</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class is in charge of peak picking, i.e. find bragg spots in the image
Two methods can be used : massif or blob</p>
<dl class="attribute">
<dt id="pyFAI.peak_picker.PeakPicker.VALID_METHODS">
<tt class="descname">VALID_METHODS</tt><em class="property"> = ['massif', 'blob', 'watershed']</em><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.VALID_METHODS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.closeGUI">
<tt class="descname">closeGUI</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.closeGUI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.contour">
<tt class="descname">contour</tt><big>(</big><em>data</em>, <em>cmap='autumn'</em>, <em>linewidths=2</em>, <em>linestyles='dashed'</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Overlay a contour-plot</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> &#8211; 2darray with the 2theta values in radians...</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.display_points">
<tt class="descname">display_points</tt><big>(</big><em>minIndex=0</em>, <em>reset=False</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.display_points" title="Permalink to this definition">¶</a></dt>
<dd><p>display all points and their ring annotations
:param minIndex: ring index to start with
:param reset: remove all point before re-displaying them</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.finish">
<tt class="descname">finish</tt><big>(</big><em>filename=None</em>, <em>callback=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.finish" title="Permalink to this definition">¶</a></dt>
<dd><p>Ask the ring number for the given points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; file with the point coordinates saved</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.gui">
<tt class="descname">gui</tt><big>(</big><em>log=False</em>, <em>maximize=False</em>, <em>pick=True</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.gui" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>log</strong> &#8211; show z in log scale</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.peak_picker.PeakPicker.help">
<tt class="descname">help</tt><em class="property"> = ['Please select rings on the diffraction image. In parenthesis, some modified shortcuts for single button mouse (Apple):', ' * Right-click (click+n):         try an auto find for a ring', ' * Right-click + Ctrl (click+b):  create new group with one point', ' * Right-click + Shift (click+v): add one point to current group', ' * Right-click + m (click+m):     find more points for current group', ' * Center-click or (click+d):     erase current group', ' * Center-click + 1 or (click+1): erase closest point from current group']</em><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.help" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.init">
<tt class="descname">init</tt><big>(</big><em>method</em>, <em>sync=True</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Unified initializer</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.load">
<tt class="descname">load</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.load" title="Permalink to this definition">¶</a></dt>
<dd><p>load a filename and plot data on the screen (if GUI)</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.massif_contour">
<tt class="descname">massif_contour</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.massif_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Overlays a mask over a diffraction image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> &#8211; mask to be overlaid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.on_minus_pts_clicked">
<tt class="descname">on_minus_pts_clicked</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.on_minus_pts_clicked" title="Permalink to this definition">¶</a></dt>
<dd><p>callback function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.on_option_clicked">
<tt class="descname">on_option_clicked</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.on_option_clicked" title="Permalink to this definition">¶</a></dt>
<dd><p>callback function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.on_plus_pts_clicked">
<tt class="descname">on_plus_pts_clicked</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.on_plus_pts_clicked" title="Permalink to this definition">¶</a></dt>
<dd><p>callback function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.on_refine_clicked">
<tt class="descname">on_refine_clicked</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.on_refine_clicked" title="Permalink to this definition">¶</a></dt>
<dd><p>callback function</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.onclick">
<tt class="descname">onclick</tt><big>(</big><em>event</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.onclick" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when a mouse is clicked</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.peaks_from_area">
<tt class="descname">peaks_from_area</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.peaks_from_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of peaks within an area</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mask</strong> &#8211; 2d array with mask.</li>
<li><strong>Imin</strong> &#8211; minimum of intensity above the background to keep the point</li>
<li><strong>keep</strong> &#8211; maximum number of points to keep</li>
<li><strong>method</strong> &#8211; enforce the use of detection using &#8220;massif&#8221; or &#8220;blob&#8221; or &#8220;watershed&#8221;</li>
<li><strong>ring</strong> &#8211; ring number to which assign the  points</li>
<li><strong>dmin</strong> &#8211; minimum distance between two peaks (in pixels)</li>
<li><strong>seed</strong> &#8211; good starting points.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of peaks [y,x], [y,x], ...]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.remove_grp">
<tt class="descname">remove_grp</tt><big>(</big><em>lbl</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.remove_grp" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a group of points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lbl</strong> &#8211; label of the group of points</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset control point and graph (if needed)</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PeakPicker.sync_init">
<tt class="descname">sync_init</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PeakPicker.sync_init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.peak_picker.PointGroup">
<em class="property">class </em><tt class="descclassname">pyFAI.peak_picker.</tt><tt class="descname">PointGroup</tt><big>(</big><em>points=None</em>, <em>ring=None</em>, <em>annotate=None</em>, <em>plot=None</em>, <em>force_label=None</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PointGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Class contains a group of points ...
They all belong to the same Debye-Scherrer ring</p>
<dl class="attribute">
<dt id="pyFAI.peak_picker.PointGroup.code">
<tt class="descname">code</tt><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.code" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerical value for the label: mainly for sorting</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyFAI.peak_picker.PointGroup.get_label">
<em class="property">classmethod </em><tt class="descname">get_label</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.get_label" title="Permalink to this definition">¶</a></dt>
<dd><p>return the next label</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PointGroup.get_ring">
<tt class="descname">get_ring</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.get_ring" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.peak_picker.PointGroup.label">
<tt class="descname">label</tt><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.label" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.peak_picker.PointGroup.last_label">
<tt class="descname">last_label</tt><em class="property"> = 0</em><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.last_label" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pyFAI.peak_picker.PointGroup.reset_label">
<em class="property">classmethod </em><tt class="descname">reset_label</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.reset_label" title="Permalink to this definition">¶</a></dt>
<dd><p>reset intenal counter</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.peak_picker.PointGroup.ring">
<tt class="descname">ring</tt><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.ring" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pyFAI.peak_picker.PointGroup.set_label">
<em class="property">classmethod </em><tt class="descname">set_label</tt><big>(</big><em>label</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.set_label" title="Permalink to this definition">¶</a></dt>
<dd><p>update the internal counter if needed</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.peak_picker.PointGroup.set_ring">
<tt class="descname">set_ring</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.peak_picker.PointGroup.set_ring" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.massif">
<span id="massif-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">massif</span></tt> Module<a class="headerlink" href="#module-pyFAI.massif" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.massif.Massif">
<em class="property">class </em><tt class="descclassname">pyFAI.massif.</tt><tt class="descname">Massif</tt><big>(</big><em>data=None</em><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A massif is defined as an area around a peak, it is used to find neighboring peaks</p>
<dl class="attribute">
<dt id="pyFAI.massif.Massif.TARGET_SIZE">
<tt class="descname">TARGET_SIZE</tt><em class="property"> = 1024</em><a class="headerlink" href="#pyFAI.massif.Massif.TARGET_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.calculate_massif">
<tt class="descname">calculate_massif</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.calculate_massif" title="Permalink to this definition">¶</a></dt>
<dd><p>defines a map of the massif around x and returns the mask</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.delValleySize">
<tt class="descname">delValleySize</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.delValleySize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.find_peaks">
<tt class="descname">find_peaks</tt><big>(</big><em>x</em>, <em>nmax=200</em>, <em>annotate=None</em>, <em>massif_contour=None</em>, <em>stdout=&lt;open file '&lt;stdout&gt;'</em>, <em>mode 'w' at 0x7fceb9e2e150&gt;</em><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.find_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>All in one function that finds a maximum from the given seed (x)
then calculates the region extension and extract position of the neighboring peaks.
:param x: seed for the calculation, input coordinates
:param nmax: maximum number of peak per region
:param annotate: call back method taking number of points + coordinate as input.
:param massif_contour: callback to show the contour of a massif with the given index.
:param stdout: this is the file where output is written by default.
:return: list of peaks</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.getBinnedData">
<tt class="descname">getBinnedData</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.getBinnedData" title="Permalink to this definition">¶</a></dt>
<dd><p>:return binned data</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.getBluredData">
<tt class="descname">getBluredData</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.getBluredData" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a blurred image</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.getLabeledMassif">
<tt class="descname">getLabeledMassif</tt><big>(</big><em>pattern=None</em><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.getLabeledMassif" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an image composed of int with a different value for each massif</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.getMedianData">
<tt class="descname">getMedianData</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.getMedianData" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a spacial median filtered image</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.getValleySize">
<tt class="descname">getValleySize</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.getValleySize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.initValleySize">
<tt class="descname">initValleySize</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.initValleySize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.nearest_peak">
<tt class="descname">nearest_peak</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.nearest_peak" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> &#8211; coordinates of the peak</td>
</tr>
</tbody>
</table>
<p>:returns the coordinates of the nearest peak</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.peaks_from_area">
<tt class="descname">peaks_from_area</tt><big>(</big><em>mask</em>, <em>Imin=None</em>, <em>keep=1000</em>, <em>dmin=0.0</em>, <em>seed=None</em>, <em>**kwarg</em><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.peaks_from_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of peaks within an area</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mask</strong> &#8211; 2d array with mask.</li>
<li><strong>Imin</strong> &#8211; minimum of intensity above the background to keep the point</li>
<li><strong>keep</strong> &#8211; maximum number of points to keep</li>
<li><strong>kwarg</strong> &#8211; ignored parameters</li>
<li><strong>dmin</strong> &#8211; minimum distance to another peak</li>
<li><strong>seed</strong> &#8211; list of good guesses to start with</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of peaks [y,x], [y,x], ...]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.massif.Massif.setValleySize">
<tt class="descname">setValleySize</tt><big>(</big><em>size</em><big>)</big><a class="headerlink" href="#pyFAI.massif.Massif.setValleySize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.massif.Massif.valley_size">
<tt class="descname">valley_size</tt><a class="headerlink" href="#pyFAI.massif.Massif.valley_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the minimum distance between two massifs</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.blob_detection">
<span id="blob-detection-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">blob_detection</span></tt> Module<a class="headerlink" href="#module-pyFAI.blob_detection" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.blob_detection.BlobDetection">
<em class="property">class </em><tt class="descclassname">pyFAI.blob_detection.</tt><tt class="descname">BlobDetection</tt><big>(</big><em>img</em>, <em>cur_sigma=0.25</em>, <em>init_sigma=0.5</em>, <em>dest_sigma=1</em>, <em>scale_per_octave=2</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Performs a blob detection:
<a class="reference external" href="http://en.wikipedia.org/wiki/Blob_detection">http://en.wikipedia.org/wiki/Blob_detection</a>
using a Difference of Gaussian + Pyramid of Gaussians</p>
<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.direction">
<tt class="descname">direction</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform and plot the two main directions of the peaks, considering their previously
calculated scale ,by calculating the Hessian at different sizes as the combination of
gaussians and their first and second derivatives</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.nearest_peak">
<tt class="descname">nearest_peak</tt><big>(</big><em>p</em>, <em>refine=True</em>, <em>Imin=None</em><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.nearest_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the nearest peak from a position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> &#8211; input position (y,x) 2-tuple of float</li>
<li><strong>refine</strong> &#8211; shall the position be refined on the raw data</li>
<li><strong>Imin</strong> &#8211; minimum of intensity above the background</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.peaks_from_area">
<tt class="descname">peaks_from_area</tt><big>(</big><em>mask</em>, <em>keep=None</em>, <em>refine=True</em>, <em>Imin=None</em>, <em>dmin=0.0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.peaks_from_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of peaks within an area</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mask</strong> &#8211; 2d array with mask.</li>
<li><strong>refine</strong> &#8211; shall the position be refined on the raw data</li>
<li><strong>Imin</strong> &#8211; minimum of intensity above the background</li>
<li><strong>kwarg</strong> &#8211; ignored parameters</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of peaks [y,x], [y,x], ...]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.process">
<tt class="descname">process</tt><big>(</big><em>max_octave=None</em><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the keypoint extraction for max_octave cycles or until all octaves have been processed.
:param max_octave: number of octave to process</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.refine_Hessian">
<tt class="descname">refine_Hessian</tt><big>(</big><em>kpx</em>, <em>kpy</em>, <em>kps</em><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.refine_Hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>Refine the keypoint location based on a 3 point derivative, and delete uncoherent keypoints</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>kpx</strong> &#8211; x_pos of keypoint</li>
<li><strong>kpy</strong> &#8211; y_pos of keypoint</li>
<li><strong>kps</strong> &#8211; s_pos of keypoint</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return arrays of corrected coordinates of keypoints, values and locations of keypoints</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.refine_Hessian_SG">
<tt class="descname">refine_Hessian_SG</tt><big>(</big><em>kpx</em>, <em>kpy</em>, <em>kps</em><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.refine_Hessian_SG" title="Permalink to this definition">¶</a></dt>
<dd><p>Savitzky Golay algorithm to check if a point is really the maximum
:param kpx: x_pos of keypoint
:param kpy: y_pos of keypoint
:param kps: s_pos of keypoint
:return array of corrected keypoints</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.refinement">
<tt class="descname">refinement</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.refinement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.show_neighboor">
<tt class="descname">show_neighboor</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.show_neighboor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.blob_detection.BlobDetection.show_stats">
<tt class="descname">show_stats</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.show_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Shows a window with the repartition of keypoint in function of scale/intensity</p>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.blob_detection.BlobDetection.tresh">
<tt class="descname">tresh</tt><em class="property"> = 0.6</em><a class="headerlink" href="#pyFAI.blob_detection.BlobDetection.tresh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.blob_detection.image_test">
<tt class="descclassname">pyFAI.blob_detection.</tt><tt class="descname">image_test</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.image_test" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyFAI.blob_detection.local_max">
<tt class="descclassname">pyFAI.blob_detection.</tt><tt class="descname">local_max</tt><big>(</big><em>dogs</em>, <em>mask=None</em>, <em>n_5=True</em><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.local_max" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dogs</strong> &#8211; 3d array with (sigma,y,x) containing difference of gaussians</td>
</tr>
</tbody>
</table>
<p>&#64;parm mask: mask out keypoint next to the mask (or inside the mask)
:param n_5: look for a larger neighborhood</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.blob_detection.make_gaussian">
<tt class="descclassname">pyFAI.blob_detection.</tt><tt class="descname">make_gaussian</tt><big>(</big><em>im</em>, <em>sigma</em>, <em>xc</em>, <em>yc</em><big>)</big><a class="headerlink" href="#pyFAI.blob_detection.make_gaussian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyFAI.calibrant">
<span id="calibrant-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">calibrant</span></tt> Module<a class="headerlink" href="#module-pyFAI.calibrant" title="Permalink to this headline">¶</a></h1>
<p>Calibrant</p>
<p>A module containing classical calibrant and also tools to generate d-spacing.</p>
<p>Interesting formula:
<a class="reference external" href="http://geoweb3.princeton.edu/research/MineralPhy/xtalgeometry.pdf">http://geoweb3.princeton.edu/research/MineralPhy/xtalgeometry.pdf</a></p>
<dl class="class">
<dt id="pyFAI.calibrant.Calibrant">
<em class="property">class </em><tt class="descclassname">pyFAI.calibrant.</tt><tt class="descname">Calibrant</tt><big>(</big><em>filename=None</em>, <em>dSpacing=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A calibrant is a reference compound where the d-spacing (interplanar distances)
are known. They are expressed in Angstrom (in the file)</p>
<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.append_2th">
<tt class="descname">append_2th</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.append_2th" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.append_dSpacing">
<tt class="descname">append_dSpacing</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.append_dSpacing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibrant.Calibrant.dSpacing">
<tt class="descname">dSpacing</tt><a class="headerlink" href="#pyFAI.calibrant.Calibrant.dSpacing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.fake_calibration_image">
<tt class="descname">fake_calibration_image</tt><big>(</big><em>ai</em>, <em>shape=None</em>, <em>Imax=1.0</em>, <em>U=0</em>, <em>V=0</em>, <em>W=0.0001</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.fake_calibration_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a fake calibration image from an azimuthal integrator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ai</strong> &#8211; azimuthal integrator</li>
<li><strong>Imax</strong> &#8211; maximum intensity of rings</li>
<li><strong>V, W</strong> (<em>U,</em>) &#8211; width of the peak from Caglioti&#8217;s law (FWHM^2 = Utan(th)^2 + Vtan(th) + W)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.get_2th">
<tt class="descname">get_2th</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.get_2th" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.get_2th_index">
<tt class="descname">get_2th_index</tt><big>(</big><em>angle</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.get_2th_index" title="Permalink to this definition">¶</a></dt>
<dd><p>return the index in the 2theta angle index</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.get_dSpacing">
<tt class="descname">get_dSpacing</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.get_dSpacing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.get_wavelength">
<tt class="descname">get_wavelength</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.get_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.load_file">
<tt class="descname">load_file</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.load_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.save_dSpacing">
<tt class="descname">save_dSpacing</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.save_dSpacing" title="Permalink to this definition">¶</a></dt>
<dd><p>save the d-spacing to a file</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.setWavelength_change2th">
<tt class="descname">setWavelength_change2th</tt><big>(</big><em>value=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.setWavelength_change2th" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.setWavelength_changeDs">
<tt class="descname">setWavelength_changeDs</tt><big>(</big><em>value=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.setWavelength_changeDs" title="Permalink to this definition">¶</a></dt>
<dd><p>This is probably not a good idea, but who knows !</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.set_dSpacing">
<tt class="descname">set_dSpacing</tt><big>(</big><em>lst</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.set_dSpacing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Calibrant.set_wavelength">
<tt class="descname">set_wavelength</tt><big>(</big><em>value=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Calibrant.set_wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibrant.Calibrant.wavelength">
<tt class="descname">wavelength</tt><a class="headerlink" href="#pyFAI.calibrant.Calibrant.wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.calibrant.Cell">
<em class="property">class </em><tt class="descclassname">pyFAI.calibrant.</tt><tt class="descname">Cell</tt><big>(</big><em>a=1</em>, <em>b=1</em>, <em>c=1</em>, <em>alpha=90</em>, <em>beta=90</em>, <em>gamma=90</em>, <em>lattice='triclinic'</em>, <em>lattice_type='P'</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This is a cell object, able to calculate the volume and d-spacing according to formula from:</p>
<p><a class="reference external" href="http://geoweb3.princeton.edu/research/MineralPhy/xtalgeometry.pdf">http://geoweb3.princeton.edu/research/MineralPhy/xtalgeometry.pdf</a></p>
<dl class="classmethod">
<dt id="pyFAI.calibrant.Cell.cubic">
<em class="property">classmethod </em><tt class="descname">cubic</tt><big>(</big><em>a</em>, <em>lattice_type='P'</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.cubic" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for cubic lattices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>a</strong> &#8211; unit cell length</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Cell.d">
<tt class="descname">d</tt><big>(</big><em>hkl</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.d" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the actual d-spacing for a 3-tuple of integer representing a
family of Miller plans</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hkl</strong> &#8211; 3-tuple of integers</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the inter-planar distance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Cell.d_spacing">
<tt class="descname">d_spacing</tt><big>(</big><em>dmin=1.0</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.d_spacing" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate all d-spacing down to dmin</p>
<p>applies selection rules</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dmin</strong> &#8211; minimum value of spacing requested</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict d-spacing as string, list of tuple with Miller indices
preceded with the numerical value</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pyFAI.calibrant.Cell.diamond">
<em class="property">classmethod </em><tt class="descname">diamond</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.diamond" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for Diamond type FCC like Si and Ge</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>a</strong> &#8211; unit cell length</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Cell.get_type">
<tt class="descname">get_type</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.get_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pyFAI.calibrant.Cell.hexagonal">
<em class="property">classmethod </em><tt class="descname">hexagonal</tt><big>(</big><em>a</em>, <em>c</em>, <em>lattice_type='P'</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.hexagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for hexagonal lattices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; unit cell length</li>
<li><strong>c</strong> &#8211; unit cell length</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibrant.Cell.lattices">
<tt class="descname">lattices</tt><em class="property"> = ['cubic', 'tetragonal', 'hexagonal', 'rhombohedral', 'orthorhombic', 'monoclinic', 'triclinic']</em><a class="headerlink" href="#pyFAI.calibrant.Cell.lattices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pyFAI.calibrant.Cell.monoclinic">
<em class="property">classmethod </em><tt class="descname">monoclinic</tt><big>(</big><em>a</em>, <em>b</em>, <em>c</em>, <em>beta</em>, <em>lattice_type='P'</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.monoclinic" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for hexagonal lattices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; unit cell length</li>
<li><strong>b</strong> &#8211; unit cell length</li>
<li><strong>c</strong> &#8211; unit cell length</li>
<li><strong>beta</strong> &#8211; unit cell angle</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pyFAI.calibrant.Cell.orthorhombic">
<em class="property">classmethod </em><tt class="descname">orthorhombic</tt><big>(</big><em>a</em>, <em>b</em>, <em>c</em>, <em>lattice_type='P'</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.orthorhombic" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for orthorhombic lattices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; unit cell length</li>
<li><strong>b</strong> &#8211; unit cell length</li>
<li><strong>c</strong> &#8211; unit cell length</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pyFAI.calibrant.Cell.rhombohedral">
<em class="property">classmethod </em><tt class="descname">rhombohedral</tt><big>(</big><em>a</em>, <em>alpha</em>, <em>lattice_type='P'</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.rhombohedral" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for hexagonal lattices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; unit cell length</li>
<li><strong>alpha</strong> &#8211; unit cell angle</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Cell.save">
<tt class="descname">save</tt><big>(</big><em>name</em>, <em>long_name=None</em>, <em>doi=None</em>, <em>dmin=1.0</em>, <em>dest_dir=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save informations about the cell in a d-spacing file, usable as Calibrant</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; name of the calibrant</li>
<li><strong>doi</strong> &#8211; reference of the publication used to parametrize the cell</li>
<li><strong>dmin</strong> &#8211; minimal d-spacing</li>
<li><strong>dest_dir</strong> &#8211; name of the directory where to save the result</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibrant.Cell.selection_rules">
<tt class="descname">selection_rules</tt><em class="property"> = None</em><a class="headerlink" href="#pyFAI.calibrant.Cell.selection_rules" title="Permalink to this definition">¶</a></dt>
<dd><p>contains a list of functions returning True(allowed)/False(forbiden)/None(unknown)</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.Cell.set_type">
<tt class="descname">set_type</tt><big>(</big><em>lattice_type</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.set_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pyFAI.calibrant.Cell.tetragonal">
<em class="property">classmethod </em><tt class="descname">tetragonal</tt><big>(</big><em>a</em>, <em>c</em>, <em>lattice_type='P'</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.Cell.tetragonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for tetragonal lattices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; unit cell length</li>
<li><strong>c</strong> &#8211; unit cell length</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibrant.Cell.type">
<tt class="descname">type</tt><a class="headerlink" href="#pyFAI.calibrant.Cell.type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibrant.Cell.types">
<tt class="descname">types</tt><em class="property"> = {'I': 'Body centered', 'P': 'Primitive', 'C': 'Side centered', 'R': 'Rhombohedral', 'F': 'Face centered'}</em><a class="headerlink" href="#pyFAI.calibrant.Cell.types" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyFAI.calibrant.Cell.volume">
<tt class="descname">volume</tt><a class="headerlink" href="#pyFAI.calibrant.Cell.volume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.calibrant.calibrant_factory">
<em class="property">class </em><tt class="descclassname">pyFAI.calibrant.</tt><tt class="descname">calibrant_factory</tt><big>(</big><em>basedir=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.calibrant_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Behaves like a dict but is actually a factory:
Each time one retrieves an object it is a new geniune new calibrant (unmodified)</p>
<dl class="method">
<dt id="pyFAI.calibrant.calibrant_factory.get">
<tt class="descname">get</tt><big>(</big><em>what</em>, <em>notfound=None</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.calibrant_factory.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.calibrant_factory.has_key">
<tt class="descname">has_key</tt><big>(</big><em>k</em><big>)</big><a class="headerlink" href="#pyFAI.calibrant.calibrant_factory.has_key" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.calibrant_factory.items">
<tt class="descname">items</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibrant.calibrant_factory.items" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.calibrant_factory.keys">
<tt class="descname">keys</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibrant.calibrant_factory.keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.calibrant.calibrant_factory.values">
<tt class="descname">values</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.calibrant.calibrant_factory.values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyFAI.distortion">
<span id="distortion-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">distortion</span></tt> Module<a class="headerlink" href="#module-pyFAI.distortion" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.distortion.Distortion">
<em class="property">class </em><tt class="descclassname">pyFAI.distortion.</tt><tt class="descname">Distortion</tt><big>(</big><em>detector='detector'</em>, <em>shape=None</em>, <em>resize=False</em>, <em>empty=0</em>, <em>mask=None</em>, <em>method='LUT'</em>, <em>device=None</em>, <em>workgroup=8</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Distortion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class applies a distortion correction on an image.</p>
<p>New version compatible both with CSR and LUT...</p>
<dl class="method">
<dt id="pyFAI.distortion.Distortion.calc_LUT">
<tt class="descname">calc_LUT</tt><big>(</big><em>use_common=True</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Distortion.calc_LUT" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Look-up table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">look up table either in CSR or LUT format depending on serl.method</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Distortion.calc_init">
<tt class="descname">calc_init</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Distortion.calc_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize all arrays</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Distortion.calc_pos">
<tt class="descname">calc_pos</tt><big>(</big><em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Distortion.calc_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the pixel boundary position on the regular grid</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">pixel corner positions (in pixel units) on the regular grid</td>
</tr>
</tbody>
</table>
<p>&#64;rtyep: ndarray of shape (nrow, ncol, 4, 2)</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Distortion.calc_size">
<tt class="descname">calc_size</tt><big>(</big><em>use_cython=True</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Distortion.calc_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the number of pixels falling into every single bin and</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">max of pixel falling into a single bin</td>
</tr>
</tbody>
</table>
<p>Considering the &#8220;half-CCD&#8221; spline from ID11 which describes a (1025,2048) detector,
the physical location of pixels should go from:
[-17.48634 : 1027.0543, -22.768829 : 2028.3689]
We chose to discard pixels falling outside the [0:1025,0:2048] range with a lose of intensity</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Distortion.correct">
<tt class="descname">correct</tt><big>(</big><em>image</em>, <em>dummy=None</em>, <em>delta_dummy=None</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Distortion.correct" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct an image based on the look-up table calculated ...</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>image</strong> &#8211; 2D-array with the image</li>
<li><strong>dummy</strong> &#8211; value suggested for bad pixels</li>
<li><strong>delta_dummy</strong> &#8211; precision of the dummy value</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">corrected 2D image</p>
</td>
</tr>
</tbody>
</table>
<p>#TODO: #225</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Distortion.reset">
<tt class="descname">reset</tt><big>(</big><em>method=None</em>, <em>device=None</em>, <em>workgroup=None</em>, <em>prepare=True</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Distortion.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the distortion correction and re-calculate the look-up table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>method</strong> &#8211; can be &#8220;lut&#8221; or &#8220;csr&#8221;, &#8220;lut&#8221; looks faster</li>
<li><strong>device</strong> &#8211; can be None, &#8220;cpu&#8221; or &#8220;gpu&#8221; or the id as a 2-tuple of integer</li>
<li><strong>worgroup</strong> &#8211; enforce the workgroup size for CSR.</li>
<li><strong>prepare</strong> &#8211; set to false to only reset and not re-initialize</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyFAI.distortion.Distortion.shape_out">
<tt class="descname">shape_out</tt><a class="headerlink" href="#pyFAI.distortion.Distortion.shape_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate/cache the output shape</p>
<p>:return output shape</p>
</dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Distortion.uncorrect">
<tt class="descname">uncorrect</tt><big>(</big><em>image</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Distortion.uncorrect" title="Permalink to this definition">¶</a></dt>
<dd><p>Take an image which has been corrected and transform it into it&#8217;s raw (with loss of information)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image</strong> &#8211; 2D-array with the image</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">uncorrected 2D image and a mask (pixels in raw image</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyFAI.distortion.Quad">
<em class="property">class </em><tt class="descclassname">pyFAI.distortion.</tt><tt class="descname">Quad</tt><big>(</big><em>buffer</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line-block">
<div class="line-block">
<div class="line">xxxxxA</div>
</div>
<div class="line">xxxxxxxI&#8217;xxxxxxxx     x</div>
</div>
</div>
</div></blockquote>
<p>xxxxxxxxIxxxxxx       |               x</p>
</div></blockquote>
<p>Bxxxxxxxxxxxx        |             |               x
x                    |             |               x
x                    |             |               x</p>
<blockquote>
<div><p>x                   |             |                x
x                   |             |                x
x                   |             |                x
x                   |             |                x
x                   |             |                x</p>
<blockquote>
<div>x                  |             |                 x
x                  |             |                 x
x                  |             |                 x
x                 O|             P              A&#8217;  x</div></blockquote>
</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;J&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;+&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;L&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</dt>
<dd><p class="first">x                  |                                 x
x                  |                                  x
x                  |                                  x</p>
<blockquote class="last">
<div><p>x                 |     xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxD
CxxxxxxxxxxxxxxxxxKxxxxx</p>
<blockquote>
<div><div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
<dl class="method">
<dt id="pyFAI.distortion.Quad.calc_area">
<tt class="descname">calc_area</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.calc_area" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.calc_area_AB">
<tt class="descname">calc_area_AB</tt><big>(</big><em>I1</em>, <em>I2</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.calc_area_AB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.calc_area_BC">
<tt class="descname">calc_area_BC</tt><big>(</big><em>J1</em>, <em>J2</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.calc_area_BC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.calc_area_CD">
<tt class="descname">calc_area_CD</tt><big>(</big><em>K1</em>, <em>K2</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.calc_area_CD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.calc_area_DA">
<tt class="descname">calc_area_DA</tt><big>(</big><em>L1</em>, <em>L2</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.calc_area_DA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.calc_area_old">
<tt class="descname">calc_area_old</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.calc_area_old" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.calc_area_vectorial">
<tt class="descname">calc_area_vectorial</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.calc_area_vectorial" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.get_box">
<tt class="descname">get_box</tt><big>(</big><em>i</em>, <em>j</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.get_box" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.get_box_size0">
<tt class="descname">get_box_size0</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.get_box_size0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.get_box_size1">
<tt class="descname">get_box_size1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.get_box_size1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.get_idx">
<tt class="descname">get_idx</tt><big>(</big><em>i</em>, <em>j</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.get_idx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.get_offset0">
<tt class="descname">get_offset0</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.get_offset0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.get_offset1">
<tt class="descname">get_offset1</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.get_offset1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.init_slope">
<tt class="descname">init_slope</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.init_slope" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.integrateAB">
<tt class="descname">integrateAB</tt><big>(</big><em>start</em>, <em>stop</em>, <em>calc_area</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.integrateAB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.populate_box">
<tt class="descname">populate_box</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.populate_box" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyFAI.distortion.Quad.reinit">
<tt class="descname">reinit</tt><big>(</big><em>A0</em>, <em>A1</em>, <em>B0</em>, <em>B1</em>, <em>C0</em>, <em>C1</em>, <em>D0</em>, <em>D1</em><big>)</big><a class="headerlink" href="#pyFAI.distortion.Quad.reinit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.distortion.test">
<tt class="descclassname">pyFAI.distortion.</tt><tt class="descname">test</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.distortion.test" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="id7">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">worker</span></tt> Module<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-pyFAI.worker"></span><p>This module contains the Worker class:</p>
<p>A tool able to perform azimuthal integration with:
additional saving capabilities like
- save as 2/3D structure in a HDF5 File
- read from HDF5 files</p>
<p>Aims at being integrated into a plugin like LImA or as model for the GUI</p>
<p>The configuration of this class is mainly done via a dictionary transmitted as a JSON string:
Here are the valid keys:</p>
<blockquote>
<div><p>&#8220;dist&#8221;,
&#8220;poni1&#8221;,
&#8220;poni2&#8221;,
&#8220;rot1&#8221;
&#8220;rot3&#8221;
&#8220;rot2&#8221;
&#8220;pixel1&#8221;
&#8220;pixel2&#8221;</p>
<p>&#8220;splineFile&#8221;
&#8220;wavelength&#8221;</p>
<p>&#8220;poni&#8221; #path of the file</p>
<p>&#8220;chi_discontinuity_at_0&#8221;
&#8220;do_mask&#8221;
&#8220;do_dark&#8221;
&#8220;do_azimuthal_range&#8221;
&#8220;do_flat&#8221;
&#8220;do_2D&#8221;
&#8220;azimuth_range_min&#8221;
&#8220;azimuth_range_max&#8221;</p>
<p>&#8220;polarization_factor&#8221;
&#8220;nbpt_rad&#8221;
&#8220;do_solid_angle&#8221;
&#8220;do_radial_range&#8221;
&#8220;do_poisson&#8221;
&#8220;delta_dummy&#8221;
&#8220;nbpt_azim&#8221;
&#8220;flat_field&#8221;
&#8220;radial_range_min&#8221;
&#8220;dark_current&#8221;
&#8220;do_polarization&#8221;
&#8220;mask_file&#8221;
&#8220;detector&#8221;
&#8220;unit&#8221;
&#8220;radial_range_max&#8221;
&#8220;val_dummy&#8221;
&#8220;do_dummy&#8221;
&#8220;method&#8221;</p>
</div></blockquote>
<p>}</p>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">pyFAI.worker.</tt><tt class="descname">DistortionWorker</tt><big>(</big><em>detector=None</em>, <em>dark=None</em>, <em>flat=None</em>, <em>solidangle=None</em>, <em>polarization=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>device=None</em><big>)</big></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple worker doing dark, flat, solid angle and polarization correction</p>
<dl class="method">
<dt>
<tt class="descname">process</tt><big>(</big><em>data</em>, <em>normalization=None</em><big>)</big></dt>
<dd><p>Process the data and apply a normalization factor
:param data: input data
:param normalization: normalization factor
:return processed data</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">pyFAI.worker.</tt><tt class="descname">PixelwiseWorker</tt><big>(</big><em>dark=None</em>, <em>flat=None</em>, <em>solidangle=None</em>, <em>polarization=None</em>, <em>mask=None</em>, <em>dummy=None</em>, <em>delta_dummy=None</em>, <em>device=None</em><big>)</big></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple worker doing dark, flat, solid angle and polarization correction</p>
<dl class="method">
<dt>
<tt class="descname">process</tt><big>(</big><em>data</em>, <em>normalization=None</em><big>)</big></dt>
<dd><p>Process the data and apply a normalization factor
:param data: input data
:param normalization: normalization factor
:return processed data</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">pyFAI.worker.</tt><tt class="descname">Worker</tt><big>(</big><em>azimuthalIntgrator=None</em>, <em>shapeIn=(2048</em>, <em>2048)</em>, <em>shapeOut=(360</em>, <em>500)</em>, <em>unit='r_mm'</em>, <em>dummy=None</em>, <em>delta_dummy=None</em><big>)</big></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt>
<tt class="descname">do_2D</tt><big>(</big><big>)</big></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<tt class="descname">error_model</tt></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">get_config</tt><big>(</big><big>)</big></dt>
<dd><p>return configuration as a dictionary</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">get_error_model</tt><big>(</big><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">get_json_config</tt><big>(</big><big>)</big></dt>
<dd><p>return configuration as a JSON string</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">get_normalization_factor</tt><big>(</big><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">get_unit</tt><big>(</big><big>)</big></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<tt class="descname">normalization_factor</tt></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">process</tt><big>(</big><em>data</em><big>)</big></dt>
<dd><p>Process a frame
#TODO:
dark, flat, sa are missing</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param:</th><td class="field-body">data: numpy array containing the input image</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">reconfig</tt><big>(</big><em>shape=(2048</em>, <em>2048)</em>, <em>sync=False</em><big>)</big></dt>
<dd><p>This is just to force the integrator to initialize with a given input image shape</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shape</strong> &#8211; shape of the input image</li>
<li><strong>sync</strong> &#8211; return only when synchronized</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">reset</tt><big>(</big><big>)</big></dt>
<dd><p>this is just to force the integrator to initialize</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">save_config</tt><big>(</big><em>filename=None</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">setDarkcurrentFile</tt><big>(</big><em>imagefile</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">setExtension</tt><big>(</big><em>ext</em><big>)</big></dt>
<dd><p>enforce the extension of the processed data file written</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">setFlatfieldFile</tt><big>(</big><em>imagefile</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">setJsonConfig</tt><big>(</big><em>jsonconfig</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">setSubdir</tt><big>(</big><em>path</em><big>)</big></dt>
<dd><p>Set the relative or absolute path for processed data</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">set_error_model</tt><big>(</big><em>value</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">set_normalization_factor</tt><big>(</big><em>value</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">set_unit</tt><big>(</big><em>value</em><big>)</big></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<tt class="descname">unit</tt></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">warmup</tt><big>(</big><em>sync=False</em><big>)</big></dt>
<dd><p>Process a dummy image to ensure everything is initialized</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sync</strong> &#8211; wait for processing to be finished</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">pyFAI.worker.</tt><tt class="descname">make_ai</tt><big>(</big><em>config</em><big>)</big></dt>
<dd><p>Create an Azimuthal integrator from the configuration
Static method !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>config</strong> &#8211; dict with all parameters</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">configured (but uninitialized) AzimuthalIntgrator</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pyFAI.units">
<span id="units-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">units</span></tt> Module<a class="headerlink" href="#module-pyFAI.units" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyFAI.units.Enum">
<em class="property">class </em><tt class="descclassname">pyFAI.units.</tt><tt class="descname">Enum</tt><a class="headerlink" href="#pyFAI.units.Enum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></p>
<p>Simple class half way between a dict and a class, behaving as an enum</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.units.eq_2th">
<tt class="descclassname">pyFAI.units.</tt><tt class="descname">eq_2th</tt><big>(</big><em>x</em>, <em>y</em>, <em>z</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.units.eq_2th" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the 2theta aperture of the cone</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; horizontal position, towards the center of the ring, from sample position</li>
<li><strong>y</strong> &#8211; Vertical position, to the roof, from sample position</li>
<li><strong>z</strong> &#8211; distance from sample along the beam</li>
<li><strong>wavelength</strong> &#8211; in meter</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.units.eq_logq">
<tt class="descclassname">pyFAI.units.</tt><tt class="descname">eq_logq</tt><big>(</big><em>x</em>, <em>y</em>, <em>z</em>, <em>wavelength</em><big>)</big><a class="headerlink" href="#pyFAI.units.eq_logq" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the log (decimal) of the scattering vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; horizontal position, towards the center of the ring, from sample position</li>
<li><strong>y</strong> &#8211; Vertical position, to the roof, from sample position</li>
<li><strong>z</strong> &#8211; distance from sample along the beam</li>
<li><strong>wavelength</strong> &#8211; in meter</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.units.eq_q">
<tt class="descclassname">pyFAI.units.</tt><tt class="descname">eq_q</tt><big>(</big><em>x</em>, <em>y</em>, <em>z</em>, <em>wavelength</em><big>)</big><a class="headerlink" href="#pyFAI.units.eq_q" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the modulus of the scattering vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; horizontal position, towards the center of the ring, from sample position</li>
<li><strong>y</strong> &#8211; Vertical position, to the roof, from sample position</li>
<li><strong>z</strong> &#8211; distance from sample along the beam</li>
<li><strong>wavelength</strong> &#8211; in meter</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.units.eq_r">
<tt class="descclassname">pyFAI.units.</tt><tt class="descname">eq_r</tt><big>(</big><em>x</em>, <em>y</em>, <em>z=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#pyFAI.units.eq_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the radius</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; horizontal position, towards the center of the ring, from sample position</li>
<li><strong>y</strong> &#8211; Vertical position, to the roof, from sample position</li>
<li><strong>z</strong> &#8211; distance from sample along the beam</li>
<li><strong>wavelength</strong> &#8211; in meter</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.units.eq_rd2">
<tt class="descclassname">pyFAI.units.</tt><tt class="descname">eq_rd2</tt><big>(</big><em>x</em>, <em>y</em>, <em>z</em>, <em>wavelength</em><big>)</big><a class="headerlink" href="#pyFAI.units.eq_rd2" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the reciprocal spacing squared</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; horizontal position, towards the center of the ring, from sample position</li>
<li><strong>y</strong> &#8211; Vertical position, to the roof, from sample position</li>
<li><strong>z</strong> &#8211; distance from sample along the beam</li>
<li><strong>wavelength</strong> &#8211; in meter</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.units.to_unit">
<tt class="descclassname">pyFAI.units.</tt><tt class="descname">to_unit</tt><big>(</big><em>obj</em>, <em>type_=(2th_deg</em>, <em>2th_rad</em>, <em>q_nm^-1</em>, <em>q_A^-1</em>, <em>r_mm</em>, <em>r_m</em>, <em>d*2_A^-2</em>, <em>d*2_nm^-2</em>, <em>log(q)_m)</em><big>)</big><a class="headerlink" href="#pyFAI.units.to_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyFAI.utils">
<span id="utils-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">utils</span></tt> Module<a class="headerlink" href="#module-pyFAI.utils" title="Permalink to this headline">¶</a></h1>
<p>Utilities, mainly for image treatment</p>
<dl class="class">
<dt id="pyFAI.utils.FixedParameters">
<em class="property">class </em><tt class="descclassname">pyFAI.utils.</tt><tt class="descname">FixedParameters</tt><a class="headerlink" href="#pyFAI.utils.FixedParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">set</span></tt></p>
<p>Like a set, made for FixedParameters in geometry refinement</p>
<dl class="method">
<dt id="pyFAI.utils.FixedParameters.add_or_discard">
<tt class="descname">add_or_discard</tt><big>(</big><em>key</em>, <em>value=True</em><big>)</big><a class="headerlink" href="#pyFAI.utils.FixedParameters.add_or_discard" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a value to a set if value, else discard it
:param key: element to added or discared from set
:type value: boolean. If None do nothing !
:return: None</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.averageDark">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">averageDark</tt><big>(</big><em>lstimg</em>, <em>center_method='mean'</em>, <em>cutoff=None</em>, <em>quantiles=(0.5</em>, <em>0.5)</em><big>)</big><a class="headerlink" href="#pyFAI.utils.averageDark" title="Permalink to this definition">¶</a></dt>
<dd><p>Averages a serie of dark (or flat) images.
Centers the result on the mean or the median ...
but averages all frames within  cutoff*std</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lstimg</strong> &#8211; list of 2D images or a 3D stack</li>
<li><strong>center_method</strong> &#8211; is the center calculated by a &#8220;mean&#8221; or a &#8220;median&#8221;, or &#8220;quantile&#8221;</li>
<li><strong>cutoff</strong> &#8211; keep all data where (I-center)/std &lt; cutoff</li>
<li><strong>quantiles</strong> &#8211; 2-tuple of floats average out data between the two quantiles</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2D image averaged</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.averageImages">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">averageImages</tt><big>(</big><em>listImages</em>, <em>output=None</em>, <em>threshold=0.1</em>, <em>minimum=None</em>, <em>maximum=None</em>, <em>darks=None</em>, <em>flats=None</em>, <em>filter_='mean'</em>, <em>correct_flat_from_dark=False</em>, <em>cutoff=None</em>, <em>quantiles=None</em>, <em>fformat='edf'</em><big>)</big><a class="headerlink" href="#pyFAI.utils.averageImages" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of filenames and create an average frame discarding all saturated pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>listImages</strong> &#8211; list of string representing the filenames</li>
<li><strong>output</strong> &#8211; name of the optional output file</li>
<li><strong>threshold</strong> &#8211; what is the upper limit? all pixel &gt; max*(1-threshold) are discareded.</li>
<li><strong>minimum</strong> &#8211; minimum valid value or True</li>
<li><strong>maximum</strong> &#8211; maximum valid value</li>
<li><strong>darks</strong> &#8211; list of dark current images for subtraction</li>
<li><strong>flats</strong> &#8211; list of flat field images for division</li>
<li><strong>filter</strong> &#8211; can be &#8220;min&#8221;, &#8220;max&#8221;, &#8220;median&#8221;, &#8220;mean&#8221;, &#8220;sum&#8221;, &#8220;quantiles&#8221; (default=&#8217;mean&#8217;)</li>
<li><strong>correct_flat_from_dark</strong> &#8211; shall the flat be re-corrected ?</li>
<li><strong>cutoff</strong> &#8211; keep all data where (I-center)/std &lt; cutoff</li>
<li><strong>quantiles</strong> &#8211; 2-tuple containing the lower and upper quantile (0&lt;q&lt;1) to average out.</li>
<li><strong>fformat</strong> &#8211; file format of the output image, default: edf</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">filename with the data or the data ndarray in case format=None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.binning">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">binning</tt><big>(</big><em>input_img</em>, <em>binsize</em>, <em>norm=True</em><big>)</big><a class="headerlink" href="#pyFAI.utils.binning" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>input_img</strong> &#8211; input ndarray</li>
<li><strong>binsize</strong> &#8211; int or 2-tuple representing the size of the binning</li>
<li><strong>norm</strong> &#8211; if False, do average instead of sum</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">binned input ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.boundingBox">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">boundingBox</tt><big>(</big><em>img</em><big>)</big><a class="headerlink" href="#pyFAI.utils.boundingBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to guess the bounding box around a valid massif</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>img</strong> &#8211; 2D array like</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">4-typle (d0_min, d1_min, d0_max, d1_max)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.calc_checksum">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">calc_checksum</tt><big>(</big><em>ary</em>, <em>safe=True</em><big>)</big><a class="headerlink" href="#pyFAI.utils.calc_checksum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the checksum by default (or returns its buffer location if unsafe)</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.center_of_mass">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">center_of_mass</tt><big>(</big><em>img</em><big>)</big><a class="headerlink" href="#pyFAI.utils.center_of_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the center of mass of of the array.
Like scipy.ndimage.measurements.center_of_mass
:param img: 2-D array
:return: 2-tuple of float with the center of mass</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.concatenate_cl_kernel">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">concatenate_cl_kernel</tt><big>(</big><em>filenames</em><big>)</big><a class="headerlink" href="#pyFAI.utils.concatenate_cl_kernel" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filenames</strong> &#8211; filenames containing the kernels</td>
</tr>
</tbody>
</table>
<p>this method concatenates all the kernel from the list</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.convert_CamelCase">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">convert_CamelCase</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#pyFAI.utils.convert_CamelCase" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a function name in CamelCase into camel_case</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.deg2rad">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">deg2rad</tt><big>(</big><em>dd</em><big>)</big><a class="headerlink" href="#pyFAI.utils.deg2rad" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert degrees to radian in the range -pi-&gt;pi</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dd</strong> &#8211; angle in degrees</td>
</tr>
</tbody>
</table>
<p>Nota: depending on the platform it could be 0&lt;2pi
A branch is cheaper than a trigo operation</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.dog">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">dog</tt><big>(</big><em>s1</em>, <em>s2</em>, <em>shape=None</em><big>)</big><a class="headerlink" href="#pyFAI.utils.dog" title="Permalink to this definition">¶</a></dt>
<dd><p>2D difference of gaussian
typically 1 to 10 parameters</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.dog_filter">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">dog_filter</tt><big>(</big><em>input_img</em>, <em>sigma1</em>, <em>sigma2</em>, <em>mode='reflect'</em>, <em>cval=0.0</em><big>)</big><a class="headerlink" href="#pyFAI.utils.dog_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>2-dimensional Difference of Gaussian filter implemented with FFTw</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_img</strong> (<em>array-like</em>) &#8211; input_img array to filter</li>
<li><strong>sigma</strong> (<em>scalar or sequence of scalars</em>) &#8211; standard deviation for Gaussian kernel.
The standard deviations of the Gaussian filter are given for each axis as a sequence,
or as a single number, in which case it is equal for all axes.</li>
<li><strong>mode</strong> &#8211; {&#8216;reflect&#8217;,&#8217;constant&#8217;,&#8217;nearest&#8217;,&#8217;mirror&#8217;, &#8216;wrap&#8217;}, optional
The <tt class="docutils literal"><span class="pre">mode</span></tt> parameter determines how the array borders are
handled, where <tt class="docutils literal"><span class="pre">cval</span></tt> is the value when mode is equal to
&#8216;constant&#8217;. Default is &#8216;reflect&#8217;</li>
<li><strong>cval</strong> &#8211; scalar, optional
Value to fill past edges of input if <tt class="docutils literal"><span class="pre">mode</span></tt> is &#8216;constant&#8217;. Default is 0.0</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.expand">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">expand</tt><big>(</big><em>input_img</em>, <em>sigma</em>, <em>mode='constant'</em>, <em>cval=0.0</em><big>)</big><a class="headerlink" href="#pyFAI.utils.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand array a with its reflection on boundaries</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; 2D array</li>
<li><strong>sigma</strong> &#8211; float or 2-tuple of floats.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param mode:&#8221;constant&#8221;, &#8220;nearest&#8221;, &#8220;reflect&#8221; or mirror
:param cval: filling value used for constant, 0.0 by default</p>
<p>Nota: sigma is the half-width of the kernel. For gaussian convolution it is adviced that it is 4*sigma_of_gaussian</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.expand2d">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">expand2d</tt><big>(</big><em>vect</em>, <em>size2</em>, <em>vertical=True</em><big>)</big><a class="headerlink" href="#pyFAI.utils.expand2d" title="Permalink to this definition">¶</a></dt>
<dd><p>This expands a vector to a 2d-array.</p>
<p>The resul is the same as
if vertical:</p>
<blockquote>
<div>numpy.outer(numpy.ones(size2), vect)</div></blockquote>
<dl class="docutils">
<dt>else:</dt>
<dd>numpy.outer(vect, numpy.ones( size2))</dd>
</dl>
<p>This is a ninja optimization: replace <a href="#id8"><span class="problematic" id="id9">*</span></a>1 with a memcopy, saves 50% of time at the ms level.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vect</strong> &#8211; 1d vector</li>
<li><strong>size2</strong> &#8211; size</li>
<li><strong>vertical</strong> &#8211; if False,</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.expand_args">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">expand_args</tt><big>(</big><em>args</em><big>)</big><a class="headerlink" href="#pyFAI.utils.expand_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes an argv and expand it (under Windows, cmd does not convert <a href="#id10"><span class="problematic" id="id11">*</span></a>.tif into a list of files.
Keeps only valid files (thanks to glob)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> &#8211; list of files or wilcards</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list of actual args</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.float_">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">float_</tt><big>(</big><em>val</em><big>)</big><a class="headerlink" href="#pyFAI.utils.float_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert anything to a float ... or None if not applicable</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.gaussian">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">gaussian</tt><big>(</big><em>M</em>, <em>std</em><big>)</big><a class="headerlink" href="#pyFAI.utils.gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Gaussian window of length M with standard-deviation std.</p>
<p>This differs from the scipy.signal.gaussian implementation as:
- The default for sym=False (needed for gaussian filtering without shift)
- This implementation is normalized</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>M</strong> &#8211; length of the windows (int)</li>
<li><strong>std</strong> &#8211; standatd deviation sigma</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The FWHM is 2*numpy.sqrt(2 * numpy.pi)*std</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.gaussian_filter">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">gaussian_filter</tt><big>(</big><em>input_img</em>, <em>sigma</em>, <em>mode='reflect'</em>, <em>cval=0.0</em><big>)</big><a class="headerlink" href="#pyFAI.utils.gaussian_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>2-dimensional Gaussian filter implemented with FFTw</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_img</strong> (<em>array-like</em>) &#8211; input array to filter</li>
<li><strong>sigma</strong> (<em>scalar or sequence of scalars</em>) &#8211; standard deviation for Gaussian kernel.
The standard deviations of the Gaussian filter are given for each axis as a sequence,
or as a single number, in which case it is equal for all axes.</li>
<li><strong>mode</strong> &#8211; {&#8216;reflect&#8217;,&#8217;constant&#8217;,&#8217;nearest&#8217;,&#8217;mirror&#8217;, &#8216;wrap&#8217;}, optional
The <tt class="docutils literal"><span class="pre">mode</span></tt> parameter determines how the array borders are
handled, where <tt class="docutils literal"><span class="pre">cval</span></tt> is the value when mode is equal to
&#8216;constant&#8217;. Default is &#8216;reflect&#8217;</li>
<li><strong>cval</strong> &#8211; scalar, optional
Value to fill past edges of input if <tt class="docutils literal"><span class="pre">mode</span></tt> is &#8216;constant&#8217;. Default is 0.0</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.get_calibration_dir">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">get_calibration_dir</tt><big>(</big><big>)</big><a class="headerlink" href="#pyFAI.utils.get_calibration_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>get the full path of a calibration directory</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the full path of the calibrant file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.get_cl_file">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">get_cl_file</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.utils.get_cl_file" title="Permalink to this definition">¶</a></dt>
<dd><p>get the full path of a openCL file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the full path of the openCL source file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.get_ui_file">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">get_ui_file</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.utils.get_ui_file" title="Permalink to this definition">¶</a></dt>
<dd><p>get the full path of a user-interface file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the full path of the ui</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.int_">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">int_</tt><big>(</big><em>val</em><big>)</big><a class="headerlink" href="#pyFAI.utils.int_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert anything to an int ... or None if not applicable</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.is_far_from_group">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">is_far_from_group</tt><big>(</big><em>pt</em>, <em>lst_pts</em>, <em>d2</em><big>)</big><a class="headerlink" href="#pyFAI.utils.is_far_from_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells if a point is far from a group of points, distance greater than d2 (distance squared)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pt</strong> &#8211; point of interest</li>
<li><strong>lst_pts</strong> &#8211; list of points</li>
<li><strong>d2</strong> &#8211; minimum distance squarred</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True If the point is far from all others.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pyFAI.utils.lazy_property">
<em class="property">class </em><tt class="descclassname">pyFAI.utils.</tt><tt class="descname">lazy_property</tt><big>(</big><em>fget</em><big>)</big><a class="headerlink" href="#pyFAI.utils.lazy_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>meant to be used for lazy evaluation of an object attribute.
property should represent non-mutable data, as it replaces itself.</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.maximum_position">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">maximum_position</tt><big>(</big><em>img</em><big>)</big><a class="headerlink" href="#pyFAI.utils.maximum_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as scipy.ndimage.measurements.maximum_position:
Find the position of the maximum of the values of the array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>img</strong> &#8211; 2-D image</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">2-tuple of int with the position of the maximum</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.measure_offset">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">measure_offset</tt><big>(</big><em>img1</em>, <em>img2</em>, <em>method='numpy'</em>, <em>withLog=False</em>, <em>withCorr=False</em><big>)</big><a class="headerlink" href="#pyFAI.utils.measure_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Measure the actual offset between 2 images
:param img1: ndarray, first image
:param img2: ndarray, second image, same shape as img1
:param withLog: shall we return logs as well ? boolean
:return: tuple of floats with the offsets</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.readFloatFromKeyboard">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">readFloatFromKeyboard</tt><big>(</big><em>text</em>, <em>dictVar</em><big>)</big><a class="headerlink" href="#pyFAI.utils.readFloatFromKeyboard" title="Permalink to this definition">¶</a></dt>
<dd><p>Read float from the keyboard ....</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>text</strong> &#8211; string to be displayed</li>
<li><strong>dictVar</strong> &#8211; dict of this type: {1: [set_dist_min],3: [set_dist_min, set_dist_guess, set_dist_max]}</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.read_cl_file">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">read_cl_file</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyFAI.utils.read_cl_file" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; read an OpenCL file and apply a preprocessor</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">preprocessed source code</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.relabel">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">relabel</tt><big>(</big><em>label</em>, <em>data</em>, <em>blured</em>, <em>max_size=None</em><big>)</big><a class="headerlink" href="#pyFAI.utils.relabel" title="Permalink to this definition">¶</a></dt>
<dd><p>Relabel limits the number of region in the label array.
They are ranked relatively to their max(I0)-max(blur(I0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>label</strong> &#8211; a label array coming out of scipy.ndimage.measurement.label</li>
<li><strong>data</strong> &#8211; an array containing the raw data</li>
<li><strong>blured</strong> &#8211; an array containing the blured data</li>
<li><strong>max_size</strong> &#8211; the max number of label wanted</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return array like label</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.removeSaturatedPixel">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">removeSaturatedPixel</tt><big>(</big><em>ds</em>, <em>threshold=0.1</em>, <em>minimum=None</em>, <em>maximum=None</em><big>)</big><a class="headerlink" href="#pyFAI.utils.removeSaturatedPixel" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ds</strong> &#8211; a dataset as  ndarray</li>
<li><strong>threshold</strong> &#8211; what is the upper limit? all pixel &gt; max*(1-threshold) are discareded.</li>
<li><strong>minimum</strong> &#8211; minumum valid value (or True for auto-guess)</li>
<li><strong>maximum</strong> &#8211; maximum valid value</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">another dataset</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.roundfft">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">roundfft</tt><big>(</big><em>N</em><big>)</big><a class="headerlink" href="#pyFAI.utils.roundfft" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the integer &gt;=N for which size the Fourier analysis is faster (fron the FFT point of view)
Credit: Alessandro Mirone, ESRF, 2012</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>N</strong> &#8211; interger on which one would like to do a Fourier transform</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">integer with a better choice</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.shift">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">shift</tt><big>(</big><em>input_img</em>, <em>shift_val</em><big>)</big><a class="headerlink" href="#pyFAI.utils.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift an array like  scipy.ndimage.interpolation.shift(input_img, shift_val, mode=&#8221;wrap&#8221;, order=0) but faster
:param input_img: 2d numpy array
:param shift_val: 2-tuple of integers
:return: shifted image</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.shiftFFT">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">shiftFFT</tt><big>(</big><em>input_img</em>, <em>shift_val</em>, <em>method='fftw'</em><big>)</big><a class="headerlink" href="#pyFAI.utils.shiftFFT" title="Permalink to this definition">¶</a></dt>
<dd><p>Do shift using FFTs
Shift an array like  scipy.ndimage.interpolation.shift(input, shift, mode=&#8221;wrap&#8221;, order=&#8221;infinity&#8221;) but faster
:param input_img: 2d numpy array
:param shift_val: 2-tuple of float
:return: shifted image</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.str_">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">str_</tt><big>(</big><em>val</em><big>)</big><a class="headerlink" href="#pyFAI.utils.str_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert anything to a string ... but None -&gt; &#8220;&#8221;</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.utils.unBinning">
<tt class="descclassname">pyFAI.utils.</tt><tt class="descname">unBinning</tt><big>(</big><em>binnedArray</em>, <em>binsize</em>, <em>norm=True</em><big>)</big><a class="headerlink" href="#pyFAI.utils.unBinning" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>binnedArray</strong> &#8211; input ndarray</li>
<li><strong>binsize</strong> &#8211; 2-tuple representing the size of the binning</li>
<li><strong>norm</strong> &#8211; if True (default) decrease the intensity by binning factor. If False, it is non-conservative</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">unBinned input ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pyFAI.gui_utils">
<span id="gui-utils-module"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">gui_utils</span></tt> Module<a class="headerlink" href="#module-pyFAI.gui_utils" title="Permalink to this headline">¶</a></h1>
<p>gui_utils</p>
<p>Module to handle matplotlib and the Qt backend</p>
<dl class="class">
<dt id="pyFAI.gui_utils.Event">
<em class="property">class </em><tt class="descclassname">pyFAI.gui_utils.</tt><tt class="descname">Event</tt><big>(</big><em>width</em>, <em>height</em><big>)</big><a class="headerlink" href="#pyFAI.gui_utils.Event" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Dummy class for dummy things</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.gui_utils.maximize_fig">
<tt class="descclassname">pyFAI.gui_utils.</tt><tt class="descname">maximize_fig</tt><big>(</big><em>fig=None</em><big>)</big><a class="headerlink" href="#pyFAI.gui_utils.maximize_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to set the figure fullscreen</p>
</dd></dl>

<dl class="function">
<dt id="pyFAI.gui_utils.update_fig">
<tt class="descclassname">pyFAI.gui_utils.</tt><tt class="descname">update_fig</tt><big>(</big><em>fig=None</em><big>)</big><a class="headerlink" href="#pyFAI.gui_utils.update_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>Update a matplotlib figure with a Qt4 backend</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fig</strong> &#8211; pylab figure</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">pyFAI</span></tt> Package</a></li>
<li><a class="reference internal" href="#module-pyFAI.azimuthalIntegrator"><tt class="docutils literal"><span class="pre">azimuthalIntegrator</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.integrate_widget"><tt class="docutils literal"><span class="pre">integrate_widget</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.geometry"><tt class="docutils literal"><span class="pre">geometry</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.geometryRefinement"><tt class="docutils literal"><span class="pre">geometryRefinement</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.detectors"><tt class="docutils literal"><span class="pre">detectors</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.spline"><tt class="docutils literal"><span class="pre">spline</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.opencl"><tt class="docutils literal"><span class="pre">opencl</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.ocl_azim"><tt class="docutils literal"><span class="pre">ocl_azim</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.ocl_azim_lut"><tt class="docutils literal"><span class="pre">ocl_azim_lut</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.ocl_azim_csr"><tt class="docutils literal"><span class="pre">ocl_azim_csr</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.ocl_azim_csr_dis"><tt class="docutils literal"><span class="pre">ocl_azim_csr_dis</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.worker"><tt class="docutils literal"><span class="pre">worker</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.io"><tt class="docutils literal"><span class="pre">io</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.calibration"><tt class="docutils literal"><span class="pre">calibration</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.peak_picker"><tt class="docutils literal"><span class="pre">peak_picker</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.massif"><tt class="docutils literal"><span class="pre">massif</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.blob_detection"><tt class="docutils literal"><span class="pre">blob_detection</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.calibrant"><tt class="docutils literal"><span class="pre">calibrant</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.distortion"><tt class="docutils literal"><span class="pre">distortion</span></tt> Module</a></li>
<li><a class="reference internal" href="#id7"><tt class="docutils literal"><span class="pre">worker</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.units"><tt class="docutils literal"><span class="pre">units</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.utils"><tt class="docutils literal"><span class="pre">utils</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyFAI.gui_utils"><tt class="docutils literal"><span class="pre">gui_utils</span></tt> Module</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="modules.html"
                        title="previous chapter">pyFAI API</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../operations/index.html"
                        title="next chapter">Installation of Python Fast Azimuthal Integration library</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/api/pyFAI.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../operations/index.html" title="Installation of Python Fast Azimuthal Integration library"
             >next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="pyFAI API"
             >previous</a> |</li>
        <li><a href="../index.html">pyFAI 0.12.0 documentation</a> &raquo;</li>
          <li><a href="modules.html" >pyFAI API</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2016, Jerome Kieffer.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>